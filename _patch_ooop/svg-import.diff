--- filter/prj/build.lst	30 Oct 2006 08:51:08 -0000	1.25
+++ filter/prj/build.lst	19 Jun 2007 07:19:44 -0000
@@ -1,4 +1,4 @@
-fl	filter	:	svtools unotools goodies xmloff cppu tools cppuhelper sal svx javaunohelper jvmaccess XALAN:xalan LIBXSLT:libxslt NULL
+fl	filter	:	svtools unotools goodies xmloff cppu tools cppuhelper sal svx javaunohelper jvmaccess XALAN:xalan LIBXSLT:libxslt LIBSVG:libsvg NULL
 fl	filter									usr1	-	all	fl_mkout			NULL
 fl	filter\prj								get		-	all	fl_prj				NULL
 fl	filter\inc								nmake	-	all	fl_inc				NULL
--- filter/source/config/fragments/fcfg_drawgraphics.mk	2005-03-21 12:45:41.000000000 +0100
+++ filter/source/config/fragments/fcfg_drawgraphics.mk	2007-06-14 11:55:42.000000000 +0200
@@ -54,6 +54,7 @@ F4_DRAWGRAPHICS = \
     SGF___StarOffice_Writer_SGF \
     SGV___StarDraw_2_0 \
     SVM___StarView_Metafile \
+    SVG___Scalable_Vector_Graphics \
     TGA___Truevision_TARGA \
     TIF___Tag_Image_File \
     WMF___MS_Windows_Metafile \
--- filter/source/config/fragments/filters/SVG___Scalable_Vector_Graphics.xcu	1970-01-01 01:00:00.000000000 +0100
+++ filter/source/config/fragments/filters/SVG___Scalable_Vector_Graphics.xcu	2007-06-14 11:55:42.000000000 +0200
@@ -0,0 +1,13 @@
+	<node oor:name="SVG - Scalable Vector Graphics" oor:op="replace">
+		<prop oor:name="Flags"><value>IMPORT ALIEN USESOPTIONS 3RDPARTYFILTER PREFERRED</value></prop>
+		<prop oor:name="UIComponent"/>
+		<prop oor:name="FilterService"><value>com.sun.star.comp.Draw.SVGFilter</value></prop>
+		<prop oor:name="UserData"><value></value></prop>
+		<prop oor:name="UIName">
+			<value xml:lang="x-default">SVG - Scalable Vector Graphics</value>
+		</prop>
+		<prop oor:name="FileFormatVersion"><value>0</value></prop>
+		<prop oor:name="Type"><value>svg_Scalable_Vector_Graphics</value></prop>
+		<prop oor:name="TemplateName"/>
+		<prop oor:name="DocumentService"><value>com.sun.star.drawing.DrawingDocument</value></prop>
+	</node>
--- filter/source/config/fragments/types/svg_Scalable_Vector_Graphics.xcu	20 Jul 2005 11:40:16 -0000	1.6
+++ filter/source/config/fragments/types/svg_Scalable_Vector_Graphics.xcu	14 Jun 2007 14:41:57 -0000
@@ -1,12 +1,12 @@
 	<node oor:name="svg_Scalable_Vector_Graphics" oor:op="replace" >
-		<prop oor:name="DetectService"/>
+		<prop oor:name="DetectService"><value>com.sun.star.comp.filters.XMLFilterDetect</value></prop>
 		<prop oor:name="URLPattern"/>
 		<prop oor:name="Extensions"><value>svg</value></prop>
 		<prop oor:name="MediaType"><value>image/svg+xml</value></prop>
-		<prop oor:name="Preferred"><value>false</value></prop>
-		<prop oor:name="PreferredFilter"/>
+		<prop oor:name="Preferred"><value>true</value></prop>
+		<prop oor:name="PreferredFilter"><value>SVG - Scalable Vector Graphics</value></prop>
 		<prop oor:name="UIName">
 			<value>SVG - Scalable Vector Graphics</value>
 		</prop>
-		<prop oor:name="ClipboardFormat"/>
+		<prop oor:name="ClipboardFormat"><value>doctype:xmlns="http://www.w3.org/2000/svg"</value></prop>
 	</node>
--- filter/source/svg/exports.map	2003-04-15 16:36:54.000000000 +0200
+++ filter/source/svg/exports.map	2007-06-14 11:55:42.000000000 +0200
@@ -1,4 +1,4 @@
-PDFFILTER_1_0 {
+SVGFILTER_1_0 {
         global:
                 component_getImplementationEnvironment;
                 component_getFactory;
@@ -6,4 +6,4 @@ PDFFILTER_1_0 {
 
         local:
                 *;
-}; 
\ Chybí znak konce řádku na konci souboru
+}; 
--- filter/source/svg/makefile.mk	2007-02-06 14:53:59.000000000 +0100
+++ filter/source/svg/makefile.mk	2007-06-14 13:56:27.000000000 +0200
@@ -42,17 +42,62 @@
 # --- Settings ----------------------------------
 
 .INCLUDE :  	settings.mk
+.INCLUDE :	libs.mk
+
+.IF "$(GUI)"=="UNX" || "$(GUI)"=="MAC" || "$(GUI)$(COM)"=="WNTGCC"
+
+.IF "$(SYSTEM_LIBSVG)" == "YES"
+LIBSVG=$(LIBSVG_LIBS)
+.ELSE
+LIBSVG=-lsvglib
+.ENDIF
+
+JPEG=$(JPEG3RDLIB)
+
+.IF "$(SYSTEM_LIBXML)" == "YES"
+LIBXML=$(LIBXML_LIBS)
+.ELSE
+LIBXML=-lxml2
+.ENDIF
+
+.ELSE
+
+LIBSVG=$(LIBPRE) svglib.lib
+JPEG=$(LIBPRE) jpeglib.lib
+LIBXML=-lxml2
+
+.ENDIF
+
+.IF "$(SYSTEM_JPEG)" != "YES"
+INCPRE+=$(SOLARVER)$/$(INPATH)$/inc$/external
+.ENDIF
+
+.IF "$(SYSTEM_LIBXML)" == "YES"
+INCPRE+=$(LIBXML_CFLAGS)
+.ELSE
+INCPRE+=$(SOLARVER)$/$(INPATH)$/inc$/external
+.ENDIF
+
+.IF "$(SYSTEM_LIBSVG)" == "YES"
+INCPRE+=$(LIBSVG_CFLAGS)
+.ELSE
+INCPRE+=$(SOLARVER)$/$(INPATH)/inc$/libsvg
+.ENDIF
+
+
+#cheesy and does not work with anything that is not *nix
+LIBPNG=`pkg-config --libs libpng`
+INCPRE+=$(`pkg-config --cflags libpng`)
 
 # --- Types -------------------------------------
 
 SLOFILES=	$(SLO)$/svguno.obj			\
 			$(SLO)$/svgfilter.obj		\
+			$(SLO)$/svgimport.obj		\
 			$(SLO)$/svgexport.obj		\
 			$(SLO)$/svgfontexport.obj	\
-			$(SLO)$/svgwriter.obj	
-.IF "$(SOLAR_JAVA)"!=""
-SLOFILES+=		$(SLO)$/svgimport.obj
-.ENDIF
+			$(SLO)$/svgreader.obj		\
+			$(SLO)$/svgwriter.obj
 
 # --- Library -----------------------------------
 
@@ -61,20 +106,19 @@
 SHL1STDLIBS=\
 	$(SVXLIB)			\
 	$(XMLOFFLIB)		\
-	$(GOODIESLIB)		\
+	$(BASEGFXLIB)		\
 	$(VCLLIB)			\
 	$(UNOTOOLSLIB)		\
 	$(TOOLSLIB)			\
 	$(COMPHELPERLIB)	\
 	$(CPPUHELPERLIB)	\
 	$(CPPULIB)			\
-	$(SALLIB) 
-
-.IF "$(SOLAR_JAVA)"!=""
-SHL1STDLIBS+=\
-	$(JVMACCESSLIB)
-.ENDIF
-
+	$(SALLIB)			\
+	$(LIBSVG)			\
+	$(LIBXML)			\
+	$(JPEG)				\
+	$(LIBPNG)			\
+	$(ZLIB3RDLIB)
 
 SHL1DEPN=
 SHL1IMPLIB=	i$(SHL1TARGET)
--- filter/source/svg/SOTranscoder.java	2005-09-08 23:54:21.000000000 +0200
+++ filter/source/svg/SOTranscoder.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,53 +0,0 @@
-/*************************************************************************
- *
- *  OpenOffice.org - a multi-platform office productivity suite
- *
- *  $RCSfile: SOTranscoder.java,v $
- *
- *  $Revision: 1.2 $
- *
- *  last change: $Author: rt $ $Date: 2005/09/08 21:54:21 $
- *
- *  The Contents of this file are made available subject to
- *  the terms of GNU Lesser General Public License Version 2.1.
- *
- *
- *    GNU Lesser General Public License Version 2.1
- *    =============================================
- *    Copyright 2005 by Sun Microsystems, Inc.
- *    901 San Antonio Road, Palo Alto, CA 94303, USA
- *
- *    This library is free software; you can redistribute it and/or
- *    modify it under the terms of the GNU Lesser General Public
- *    License version 2.1, as published by the Free Software Foundation.
- *
- *    This library is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *    Lesser General Public License for more details.
- *
- *    You should have received a copy of the GNU Lesser General Public
- *    License along with this library; if not, write to the Free Software
- *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- *    MA  02111-1307  USA
- *
- ************************************************************************/
-
-import java.io.*;
-import org.apache.batik.transcoder.image.PNGTranscoder;
-import org.apache.batik.transcoder.TranscoderInput;
-import org.apache.batik.transcoder.TranscoderOutput;
-
-public class SOTranscoder
-{
-    public static void main(String [] args) throws Exception 
-	{
-        PNGTranscoder	aTranscoder = new PNGTranscoder();
-        OutputStream	aOStm = new FileOutputStream( args[ 1 ] );
-
-        aTranscoder.transcode( new TranscoderInput( new File( args[ 0 ] ).toURL().toString() ), new TranscoderOutput( aOStm ) );
-
-        aOStm.flush();
-        aOStm.close();
-    }
-}
--- filter/source/svg/svgfilter.cxx	2007-06-14 11:52:22.000000000 +0200
+++ filter/source/svg/svgfilter.cxx	2007-06-14 11:55:42.000000000 +0200
@@ -96,12 +96,9 @@ sal_Bool SAL_CALL SVGFilter::filter( con
     if( pFocusWindow )
     	pFocusWindow->EnterWait();
 
-#ifdef SOLAR_JAVA
     if( mxDstDoc.is() )
         bRet = implImport( rDescriptor );
-    else
-#endif
-    if( mxSrcDoc.is() )
+    else if( mxSrcDoc.is() )
 	{
 		uno::Reference< frame::XDesktop > xDesktop( mxMSF->createInstance( ::rtl::OUString::createFromAscii( "com.sun.star.frame.Desktop" ) ), 
 													uno::UNO_QUERY);
@@ -169,13 +166,11 @@ void SAL_CALL SVGFilter::setSourceDocume
 
 // -----------------------------------------------------------------------------
 
-#ifdef SOLAR_JAVA
 void SAL_CALL SVGFilter::setTargetDocument( const Reference< XComponent >& xDoc ) 
 	throw (::com::sun::star::lang::IllegalArgumentException, RuntimeException)
 {
 	mxDstDoc = xDoc;
 }
-#endif
 
 // -----------------------------------------------------------------------------
 
--- filter/source/svg/svgfilter.hxx	2006-12-01 15:30:42.000000000 +0100
+++ filter/source/svg/svgfilter.hxx	2007-06-14 11:55:42.000000000 +0200
@@ -57,11 +57,9 @@
 #ifndef _COM_SUN_STAR_DOCUMENT_XFILTER_HPP_
 #include <com/sun/star/document/XFilter.hpp>
 #endif
-#ifdef SOLAR_JAVA
 #ifndef _COM_SUN_STAR_DOCUMENT_XIMPORTER_HPP_
 #include <com/sun/star/document/XImporter.hpp>
 #endif
-#endif // SOLAR_JAVA
 #ifndef _COM_SUN_STAR_DOCUMENT_XEXPORTER_HPP_
 #include <com/sun/star/document/XExporter.hpp>
 #endif
@@ -77,18 +75,9 @@
 #ifndef _COM_SUN_STAR_LANG_XCOMPONENT_HPP_
 #include <com/sun/star/lang/XComponent.hpp>
 #endif
-#ifndef _CPPUHELPER_IMPLBASE1_HXX_
-#include <cppuhelper/implbase1.hxx>
-#endif
-#ifdef SOLAR_JAVA
 #ifndef _CPPUHELPER_IMPLBASE5_HXX_
 #include <cppuhelper/implbase5.hxx>
 #endif
-#else // !SOLAR_JAVA
-#ifndef _CPPUHELPER_IMPLBASE4_HXX_
-#include <cppuhelper/implbase4.hxx>
-#endif
-#endif
 #ifndef _COM_SUN_STAR_LANG_XMULTISERVICEFACTORY_HPP_
 #include <com/sun/star/lang/XMultiServiceFactory.hpp>
 #endif
@@ -113,9 +102,6 @@
 #ifndef _COM_SUN_STAR_FRAME_XDESKTOP_HPP_
 #include <com/sun/star/frame/XDesktop.hpp>
 #endif
-#include <com/sun/star/java/XJavaVM.hpp>
-#include <com/sun/star/java/XJavaThreadRegister_11.hpp>
-#include <com/sun/star/lang/XMultiServiceFactory.hpp>
 
 #include <hash_map>
 #include <osl/diagnose.h>
@@ -137,14 +123,12 @@
 #include <svx/svdobj.hxx>
 #include <xmloff/xmlexp.hxx>
 
-#include "svgfilter.hxx"
 #include "svgscript.hxx"
 
 using namespace ::com::sun::star::uno;
 using namespace ::com::sun::star::container;
 using namespace ::com::sun::star::lang;
 using namespace ::com::sun::star::beans;
-using namespace ::com::sun::star::java;
 using namespace ::com::sun::star::drawing;
 using namespace ::com::sun::star::presentation;
 using namespace ::com::sun::star::document;
@@ -231,18 +215,11 @@ class SVGFontExport;
 class SVGActionWriter;
 class EditFieldInfo;
 
-#ifdef SOLAR_JAVA
 class SVGFilter : public cppu::WeakImplHelper5 < XFilter,
 											     XImporter,
                                                  XExporter,
 												 XInitialization,
 												 XServiceInfo >
-#else // !SOLAR_JAVA
-class SVGFilter : public cppu::WeakImplHelper4 < XFilter,
-                                                 XExporter,
-                                                 XInitialization,
-                                                 XServiceInfo >
-#endif
 {
 	typedef ::std::hash_map< Reference< XInterface >, ObjectRepresentation, HashReferenceXInterface > ObjectMap;
 
@@ -259,15 +236,11 @@ private:
 
 	ObjectMap*							mpObjects;
 	Reference< XComponent >				mxSrcDoc;
-#ifdef SOLAR_JAVA
 	Reference< XComponent >				mxDstDoc;
-#endif
 	Reference< XDrawPage > 				mxDefaultPage;
 	Link								maOldFieldHdl;
 
-#ifdef SOLAR_JAVA
     sal_Bool                            implImport( const Sequence< PropertyValue >& rDescriptor ) throw (RuntimeException);
-#endif
 
     sal_Bool                            implExport( const Sequence< PropertyValue >& rDescriptor ) throw (RuntimeException);
     Reference< XDocumentHandler >       implCreateExportDocumentHandler( const Reference< XOutputStream >& rxOStm );
@@ -306,10 +279,8 @@ protected:
     virtual sal_Bool SAL_CALL filter( const Sequence< PropertyValue >& rDescriptor ) throw(RuntimeException);
     virtual void SAL_CALL cancel( ) throw (RuntimeException);
 
-#ifdef SOLAR_JAVA
 	// XImporter
     virtual void SAL_CALL setTargetDocument( const Reference< XComponent >& xDoc ) throw(IllegalArgumentException, RuntimeException);
-#endif
 
 	// XExporter
     virtual void SAL_CALL setSourceDocument( const Reference< XComponent >& xDoc ) throw(IllegalArgumentException, RuntimeException);
--- filter/source/svg/svgimport.cxx	2006-12-01 15:31:12.000000000 +0100
+++ filter/source/svg/svgimport.cxx	2007-06-14 11:55:42.000000000 +0200
@@ -37,8 +37,409 @@
 #include "precompiled_filter.hxx"
 
 #include "svgfilter.hxx" 
+#include "svgreader.hxx" 
+
+#include <svg.h>
+
 #include "rtl/ref.hxx"
-#include "jvmaccess/virtualmachine.hxx"
+
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+
+#include <iostream>
+
+// ----------------------------------------------
+// libsvg callbacks
+static svg_status_t impl_BeginGroup( void *closure, double opacity )
+{
+    SVGReader *pReader = static_cast<SVGReader*>( closure );
+
+    pReader->BeginGroup();
+    // FIXME set opacity?
+    
+    return SVG_STATUS_SUCCESS;
+}
+
+static svg_status_t impl_BeginElement( void *closure )
+{
+    SVGReader *pReader = static_cast<SVGReader*>( closure );
+
+    pReader->BeginElement();
+
+    return SVG_STATUS_SUCCESS;
+}
+
+static svg_status_t impl_EndElement( void *closure )
+{
+    // nothing to do...
+    return SVG_STATUS_SUCCESS;
+}
+
+static svg_status_t impl_EndGroup( void *closure, double opacity )
+{
+    SVGReader *pReader = static_cast<SVGReader*>( closure );
+
+    // FIXME set opacity?
+
+    return pReader->EndGroup()? SVG_STATUS_SUCCESS: SVG_STATUS_PARSE_ERROR;
+}
+
+static svg_status_t impl_MoveTo( void *closure, double x, double y )
+{
+    SVGReader *pReader = static_cast<SVGReader*>( closure );
+    fprintf( stderr, "move_to\n" );
+
+    return SVG_STATUS_SUCCESS;
+}
+
+static svg_status_t impl_LineTo( void *closure, double x, double y )
+{
+    SVGReader *pReader = static_cast<SVGReader*>( closure );
+    fprintf( stderr, "line_to\n" );
+
+    return SVG_STATUS_SUCCESS;
+}
+
+static svg_status_t impl_CurveTo( void *closure,
+        double x1, double y1,
+        double x2, double y2,
+        double x3, double y3 )
+{
+    SVGReader *pReader = static_cast<SVGReader*>( closure );
+    fprintf( stderr, "curve_to\n" );
+
+    return SVG_STATUS_SUCCESS;
+}
+
+static svg_status_t impl_QuadraticCurveTo( void *closure,
+        double x1, double y1,
+        double x2, double y2 )
+{
+    SVGReader *pReader = static_cast<SVGReader*>( closure );
+    fprintf( stderr, "quadratic_curve_to\n" );
+
+    return SVG_STATUS_SUCCESS;
+}
+
+static svg_status_t impl_ArcTo( void *closure,
+        double rx,
+        double ry,
+        double x_axis_rotation,
+        int    large_arc_flag,
+        int    sweep_flag,
+        double x,
+        double y )
+{
+    SVGReader *pReader = static_cast<SVGReader*>( closure );
+    fprintf( stderr, "arc_to\n" );
+
+    return SVG_STATUS_SUCCESS;
+}
+
+static svg_status_t impl_ClosePath( void *closure )
+{
+    SVGReader *pReader = static_cast<SVGReader*>( closure );
+    fprintf( stderr, "close_path\n" );
+
+    return SVG_STATUS_SUCCESS;
+}
+
+static svg_status_t impl_SetColor( void *closure, const svg_color_t *color )
+{
+    SVGReader *pReader = static_cast<SVGReader*>( closure );
+    fprintf( stderr, "set_color\n" );
+
+    return SVG_STATUS_SUCCESS;
+}
+
+static svg_status_t impl_SetFillOpacity( void *closure, double fill_opacity )
+{
+    SVGReader *pReader = static_cast<SVGReader*>( closure );
+    fprintf( stderr, "set_fill_opacity\n" );
+
+    return SVG_STATUS_SUCCESS;
+}
+
+static svg_status_t impl_SetFillPaint( void *closure, const svg_paint_t *paint )
+{
+    SVGReader *pReader = static_cast<SVGReader*>( closure );
+
+    pReader->CurrentAttr().SetFillPaint( paint );
+
+    return SVG_STATUS_SUCCESS;
+}
+
+static svg_status_t impl_SetFillRule( void *closure, svg_fill_rule_t fill_rule )
+{
+    SVGReader *pReader = static_cast<SVGReader*>( closure );
+    fprintf( stderr, "set_fill_rule\n" );
+
+    return SVG_STATUS_SUCCESS;
+}
+
+static svg_status_t impl_SetFontFamily( void *closure, const char *family )
+{
+    SVGReader *pReader = static_cast<SVGReader*>( closure );
+    fprintf( stderr, "set_font_family\n" );
+
+    return SVG_STATUS_SUCCESS;
+}
+
+static svg_status_t impl_SetFontSize( void *closure, double size )
+{
+    SVGReader *pReader = static_cast<SVGReader*>( closure );
+    fprintf( stderr, "set_font_size\n" );
+
+    return SVG_STATUS_SUCCESS;
+}
+
+static svg_status_t impl_SetFontStyle( void *closure, svg_font_style_t font_style )
+{
+    SVGReader *pReader = static_cast<SVGReader*>( closure );
+    fprintf( stderr, "set_font_style\n" );
+
+    return SVG_STATUS_SUCCESS;
+}
+
+static svg_status_t impl_SetFontWeight( void *closure, unsigned int font_weight )
+{
+    SVGReader *pReader = static_cast<SVGReader*>( closure );
+    fprintf( stderr, "set_font_weight\n" );
+
+    return SVG_STATUS_SUCCESS;
+}
+
+static svg_status_t impl_SetOpacity( void *closure, double opacity )
+{
+    SVGReader *pReader = static_cast<SVGReader*>( closure );
+    fprintf( stderr, "set_opacity\n" );
+
+    return SVG_STATUS_SUCCESS;
+}
+
+static svg_status_t impl_SetStrokeDashArray( void *closure, double *dash_array, int num_dashes )
+{
+    SVGReader *pReader = static_cast<SVGReader*>( closure );
+    fprintf( stderr, "set_stroke_dash_array\n" );
+
+    return SVG_STATUS_SUCCESS;
+}
+
+static svg_status_t impl_SetStrokeDashOffset( void *closure, svg_length_t *offset )
+{
+    SVGReader *pReader = static_cast<SVGReader*>( closure );
+    fprintf( stderr, "set_stroke_dash_offset\n" );
+
+    return SVG_STATUS_SUCCESS;
+}
+
+static svg_status_t impl_SetStrokeLineCap( void *closure, svg_stroke_line_cap_t line_cap )
+{
+    SVGReader *pReader = static_cast<SVGReader*>( closure );
+    fprintf( stderr, "set_stroke_line_cap\n" );
+
+    return SVG_STATUS_SUCCESS;
+}
+
+static svg_status_t impl_SetStrokeLineJoin( void *closure, svg_stroke_line_join_t line_join )
+{
+    SVGReader *pReader = static_cast<SVGReader*>( closure );
+    
+    pReader->CurrentAttr().SetStrokeLineJoin( line_join );
+
+    return SVG_STATUS_SUCCESS;
+}
+
+static svg_status_t impl_SetStrokeMiterLimit( void *closure, double limit )
+{
+    SVGReader *pReader = static_cast<SVGReader*>( closure );
+    fprintf( stderr, "set_stroke_miter_limit\n" );
+
+    return SVG_STATUS_SUCCESS;
+}
+
+static svg_status_t impl_SetStrokeOpacity( void *closure, double stroke_opacity )
+{
+    SVGReader *pReader = static_cast<SVGReader*>( closure );
+    fprintf( stderr, "set_stroke_opacity\n" );
+
+    return SVG_STATUS_SUCCESS;
+}
+
+static svg_status_t impl_SetStrokePaint( void *closure, const svg_paint_t *paint )
+{
+    SVGReader *pReader = static_cast<SVGReader*>( closure );
+    
+    pReader->CurrentAttr().SetStrokePaint( paint );
+
+    return SVG_STATUS_SUCCESS;
+}
+
+static svg_status_t impl_SetStrokeWidth( void *closure, svg_length_t *width )
+{
+    SVGReader *pReader = static_cast<SVGReader*>( closure );
+    
+    pReader->CurrentAttr().SetStrokeWidth( width );
+
+    return SVG_STATUS_SUCCESS;
+}
+
+static svg_status_t impl_SetTextAnchor( void *closure, svg_text_anchor_t text_anchor )
+{
+    SVGReader *pReader = static_cast<SVGReader*>( closure );
+    fprintf( stderr, "set_text_anchor\n" );
+
+    return SVG_STATUS_SUCCESS;
+}
+
+static svg_status_t impl_Transform( void *closure,
+        double a, double b,
+        double c, double d,
+        double e, double f )
+{
+    SVGReader *pReader = static_cast<SVGReader*>( closure );
+    
+    pReader->CurrentAttr().Transform( a, b, c, d, e, f );
+
+    return SVG_STATUS_SUCCESS;
+}
+
+static svg_status_t impl_ApplyViewBox( void *closure,
+        svg_view_box_t view_box,
+        svg_length_t *width,
+        svg_length_t *height )
+{
+    SVGReader *pReader = static_cast<SVGReader*>( closure );
+    fprintf( stderr, "apply_view_box\n" );
+
+    return SVG_STATUS_SUCCESS;
+}
+
+static svg_status_t impl_SetViewportDimension( void *closure,
+			    	     svg_length_t *width,
+			    	     svg_length_t *height )
+{
+    SVGReader *pReader = static_cast<SVGReader*>( closure );
+
+    pReader->SetViewportDimension( width, height );
+
+    return SVG_STATUS_SUCCESS;
+}
+
+static svg_status_t impl_RenderLine( void *closure,
+        svg_length_t *x1,
+        svg_length_t *y1,
+        svg_length_t *x2,
+        svg_length_t *y2 )
+{
+    SVGReader *pReader = static_cast<SVGReader*>( closure );
+    fprintf( stderr, "render_line\n" );
+
+    return SVG_STATUS_SUCCESS;
+}
+
+static svg_status_t impl_RenderPath( void *closure )
+{
+    SVGReader *pReader = static_cast<SVGReader*>( closure );
+    fprintf( stderr, "render_path\n" );
+
+    return SVG_STATUS_SUCCESS;
+}
+
+static svg_status_t impl_RenderEllipse( void *closure,
+        svg_length_t *cx,
+        svg_length_t *cy,
+        svg_length_t *rx,
+        svg_length_t *ry )
+{
+    SVGReader *pReader = static_cast<SVGReader*>( closure );
+
+    return pReader->Ellipse( cx, cy, rx, ry )? SVG_STATUS_SUCCESS: SVG_STATUS_PARSE_ERROR;
+}
+
+static svg_status_t impl_RenderRect( void *closure,
+        svg_length_t *x,
+        svg_length_t *y,
+        svg_length_t *width,
+        svg_length_t *height,
+        svg_length_t *rx,
+        svg_length_t *ry )
+{
+    SVGReader *pReader = static_cast<SVGReader*>( closure );
+
+    return pReader->Rect( x, y, width, height, rx, ry )? SVG_STATUS_SUCCESS: SVG_STATUS_PARSE_ERROR;
+}
+
+static svg_status_t impl_RenderText( void *closure,
+        svg_length_t *x,
+        svg_length_t *y,
+        const char   *utf8 )
+{
+    SVGReader *pReader = static_cast<SVGReader*>( closure );
+    fprintf( stderr, "render_text\n" );
+
+    return SVG_STATUS_SUCCESS;
+}
+
+static svg_status_t impl_RenderImage( void *closure,
+        unsigned char *data,
+        unsigned int data_width,
+        unsigned int data_height,
+        svg_length_t *x,
+        svg_length_t *y,
+        svg_length_t *width,
+        svg_length_t *height )
+{
+    SVGReader *pReader = static_cast<SVGReader*>( closure );
+    fprintf( stderr, "render_image\n" );
+
+    return SVG_STATUS_SUCCESS;
+}
+
+static svg_render_engine_t aRenderEngine =
+{
+    impl_BeginGroup,
+    impl_BeginElement,
+    impl_EndElement,
+    impl_EndGroup,
+
+    impl_MoveTo,
+    impl_LineTo,
+    impl_CurveTo,
+    impl_QuadraticCurveTo,
+    impl_ArcTo,
+    impl_ClosePath,
+
+    impl_SetColor,
+    impl_SetFillOpacity,
+    impl_SetFillPaint,
+    impl_SetFillRule,
+    impl_SetFontFamily,
+    impl_SetFontSize,
+    impl_SetFontStyle,
+    impl_SetFontWeight,
+    impl_SetOpacity,
+    impl_SetStrokeDashArray,
+    impl_SetStrokeDashOffset,
+    impl_SetStrokeLineCap,
+    impl_SetStrokeLineJoin,
+    impl_SetStrokeMiterLimit,
+    impl_SetStrokeOpacity,
+    impl_SetStrokePaint,
+    impl_SetStrokeWidth,
+    impl_SetTextAnchor,
+
+    impl_Transform,
+    impl_ApplyViewBox,
+    impl_SetViewportDimension,
+    
+    impl_RenderLine,
+    impl_RenderPath,
+    impl_RenderEllipse,
+    impl_RenderRect,
+    impl_RenderText,
+    impl_RenderImage
+};
+
 // -------------
 // - SVGFilter -
 // -------------
@@ -46,6 +447,105 @@
 sal_Bool SVGFilter::implImport( const Sequence< PropertyValue >& rDescriptor )
 	throw (RuntimeException)
 {
+    // get the filename
+    rtl::OUString						aFileName;
+    sal_Int32							nLength = rDescriptor.getLength();
+    const PropertyValue*				pValue = rDescriptor.getConstArray();
+    sal_Bool							bRet = sal_False;
+
+    for( sal_Int32 i = 0 ; ( i < nLength ) && !aFileName.getLength(); i++)
+    {
+        if( pValue[ i ].Name.equalsAscii( "URL" ) )
+            pValue[ i ].Value >>= aFileName;
+    }
+    
+    if ( aFileName.getLength() && !aFileName.compareToAscii( "file://", 7 ) )
+        aFileName = aFileName.copy( 7 );
+    else
+        return sal_False; // FIXME cannot handle non-local files now...
+
+    std::cerr << "SVGFilter::implImport(); parsing " << aFileName << std::endl;
+
+    // access to the document
+    Reference< XDrawPagesSupplier > xDrawPagesSupplier( mxDstDoc, UNO_QUERY );
+    if ( !xDrawPagesSupplier.is() )
+        return sal_False;
+
+    Reference< XDrawPages > xDrawPages( xDrawPagesSupplier->getDrawPages() );
+    if ( !xDrawPages.is() || !xDrawPages->getCount() )
+        return sal_False;
+
+    Reference< XDrawPage > xDrawPage;
+    if ( !( xDrawPages->getByIndex( 0 ) >>= xDrawPage ) )
+        return sal_False;
+
+    Reference< XShapes > xShapes( xDrawPage, UNO_QUERY );
+
+    // parse the file
+    svg_t *pSvg;
+    SVGReader aReader( Reference< XMultiServiceFactory >( mxDstDoc, UNO_QUERY ), xShapes );
+
+    if ( svg_create( &pSvg ) != SVG_STATUS_SUCCESS )
+        return sal_False;
+
+    // FIXME be able to read from a stream instead of a filename
+    if ( svg_parse( pSvg, rtl::OUStringToOString( aFileName, RTL_TEXTENCODING_UTF8 ).getStr() ) != SVG_STATUS_SUCCESS )
+        return sal_False;
+
+    if ( svg_render( pSvg, &aRenderEngine, &aReader ) != SVG_STATUS_SUCCESS )
+        return sal_False;
+    
+    if ( svg_destroy( pSvg ) != SVG_STATUS_SUCCESS )
+        return sal_False;
+
+    /*
+    Reference< XPropertySet > xPagePropSet( xDrawPage, UNO_QUERY );
+
+    Reference< XShape >       xShape( Reference< XMultiServiceFactory >( mxDstDoc, UNO_QUERY )->createInstance(
+                rtl::OUString::createFromAscii( "com.sun.star.drawing.RectangleShape" ) ), UNO_QUERY );
+
+    if ( !xPagePropSet.is() || !xShapes.is() || !xShape.is() )
+        return sal_False;
+
+    Reference< XPropertySet > xPropSet( xShape, UNO_QUERY );
+    sal_Int32                 nPageWidth = 0, nPageHeight = 0;
+
+    if ( !xPropSet.is() ||
+         !( xPagePropSet->getPropertyValue( rtl::OUString::createFromAscii( "Width" ) ) >>= nPageWidth ) ||
+         !( xPagePropSet->getPropertyValue( rtl::OUString::createFromAscii( "Height" ) ) >>= nPageHeight ) )
+        return sal_False;
+
+    xShapes->add( xShape );
+
+    ::com::sun::star::awt::Point	aPos;
+    ::com::sun::star::awt::Size		aSize;
+//    GraphicObject					aGraphObj;
+//    String							aGraphURL( RTL_CONSTASCII_USTRINGPARAM( "vnd.sun.star.GraphicObject:" ) );
+    Any								aValue;
+//    Size							aGraphicSize;
+    const MapMode					aTargetMapMode( MAP_100TH_MM );
+
+//    if( aGraphObj.GetPrefMapMode().GetMapUnit() == MAP_PIXEL )
+//        aGraphicSize = Application::GetDefaultDevice()->PixelToLogic( aGraphObj.GetPrefSize(), aTargetMapMode );
+//    else
+//        aGraphicSize = OutputDevice::LogicToLogic( aGraphObj.GetPrefSize(), aGraphObj.GetPrefMapMode(), aTargetMapMode );
+
+//    aGraphURL += String( aGraphObj.GetUniqueID(), RTL_TEXTENCODING_ASCII_US );
+//    aValue <<= rtl::OUString( aGraphURL );
+//    xPropSet->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "GraphicURL" ) ), aValue );
+
+    aPos.X = 0;//( nPageWidth - aGraphicSize.Width() ) >> 1;
+    aPos.Y = 0;//( nPageHeight - aGraphicSize.Height() ) >> 1;
+
+    aSize.Width = 10000;//aGraphicSize.Width();
+    aSize.Height = 10000;//aGraphicSize.Height();
+
+    xShape->setPosition( aPos );
+    xShape->setSize( aSize );
+*/
+    return sal_True;
+
+#if 0
     Reference< XMultiServiceFactory >	xServiceFactory( ::comphelper::getProcessServiceFactory() ) ;
 	rtl::OUString							aTmpFileName;
 	String								aFileName;
@@ -192,5 +692,6 @@ sal_Bool SVGFilter::implImport( const Se
         }            
     }
     return bRet;
+#endif
 }
     
--- filter/source/svg/svgreader.cxx	1970-01-01 01:00:00.000000000 +0100
+++ filter/source/svg/svgreader.cxx	2007-06-14 13:54:23.000000000 +0200
@@ -0,0 +1,496 @@
+ /*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include "svgreader.hxx"
+
+#include <unotools/processfactory.hxx>
+
+#include <iostream>
+
+using namespace ::com::sun::star;
+using namespace ::com::sun::star::beans;
+using namespace ::com::sun::star::drawing;
+using namespace ::com::sun::star::lang;
+using namespace ::com::sun::star::uno;
+using namespace ::basegfx;
+
+// consts //
+
+const double USER_UNIT = 10.0; // FIXME? 10.0 considered a nice magic value ;-)
+
+// forward declarations //
+
+// return svg_length_t in 100th's of mm
+sal_Int32 ToInt( const svg_length_t *length );
+
+// shapes & properties names //
+
+static const rtl::OUString RECTANGLE_SHAPE(        RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.drawing.RectangleShape" ) );
+static const rtl::OUString ELLIPSE_SHAPE(          RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.drawing.EllipseShape" ) );
+static const rtl::OUString SHAPE_COLLECTION(       RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.drawing.ShapeCollection" ) );
+
+static const rtl::OUString PROPERTY_CORNER_RADIUS( RTL_CONSTASCII_USTRINGPARAM( "CornerRadius" ) );
+
+static const rtl::OUString PROPERTY_LINE_STYLE(    RTL_CONSTASCII_USTRINGPARAM( "LineStyle" ) );
+static const rtl::OUString PROPERTY_LINE_COLOR(    RTL_CONSTASCII_USTRINGPARAM( "LineColor" ) );
+static const rtl::OUString PROPERTY_LINE_WIDTH(    RTL_CONSTASCII_USTRINGPARAM( "LineWidth" ) );
+static const rtl::OUString PROPERTY_LINE_JOINT(    RTL_CONSTASCII_USTRINGPARAM( "LineJoint" ) );
+
+static const rtl::OUString PROPERTY_FILL_STYLE(    RTL_CONSTASCII_USTRINGPARAM( "FillStyle" ) );
+static const rtl::OUString PROPERTY_FILL_COLOR(    RTL_CONSTASCII_USTRINGPARAM( "FillColor" ) );
+
+static const rtl::OUString PROPERTY_TRANSFORMATION(RTL_CONSTASCII_USTRINGPARAM( "Transformation" ) );
+
+// SVGAttributes //
+
+SVGAttributes::SVGAttributes()
+{
+}
+
+SVGAttributes& SVGAttributes::operator=( const SVGAttributes &rAttr )
+{
+    m_aLineStyle = rAttr.m_aLineStyle;
+    m_aLineColor = rAttr.m_aLineColor;
+    m_aLineWidth = rAttr.m_aLineWidth;
+    m_aLineJoint = rAttr.m_aLineJoint;
+
+    m_aFillStyle = rAttr.m_aFillStyle;
+    m_aFillColor = rAttr.m_aFillColor;
+
+    m_aTransform = rAttr.m_aTransform;
+
+    return *this;
+}
+
+void SVGAttributes::ApplyProperties( Reference< XPropertySet > &xPropertySet )
+{
+    if ( !xPropertySet.is() )
+        return;
+
+#define APPLY_PROPERTY( name, value ) \
+    if ( !!value && xPropertySet->getPropertySetInfo()->hasPropertyByName( name ) ) \
+    { \
+        xPropertySet->setPropertyValue( name, makeAny( *value ) ); \
+    }
+
+    APPLY_PROPERTY( PROPERTY_LINE_STYLE, m_aLineStyle );
+    APPLY_PROPERTY( PROPERTY_LINE_COLOR, m_aLineColor );
+    APPLY_PROPERTY( PROPERTY_LINE_WIDTH, m_aLineWidth );
+    APPLY_PROPERTY( PROPERTY_LINE_JOINT, m_aLineJoint );
+
+    APPLY_PROPERTY( PROPERTY_FILL_STYLE, m_aFillStyle );
+    APPLY_PROPERTY( PROPERTY_FILL_COLOR, m_aFillColor );
+
+#undef APPLY_PROPERTY
+}
+
+void SVGAttributes::ApplyTransformation( Reference< XPropertySet > &xPropertySet,
+        sal_Int32 nX, sal_Int32 nY,
+        sal_Int32 nWidth, sal_Int32 nHeight,
+        sal_Int32 nCenterX, sal_Int32 nCenterY )
+{
+    // shouldn't happen, but to be safe...
+    if ( nWidth == 0 )
+        nWidth = 1;
+    if ( nHeight == 0 )
+        nHeight = 1;
+
+    B2DHomMatrix aTransform;
+    aTransform.scale( nWidth, nHeight );
+    aTransform.translate( nX, nY );
+
+    if ( !!m_aTransform )
+        aTransform *= *m_aTransform;
+
+    /*if ( nCenterX != 0 || nCenterY != 0 )
+    {
+        fprintf( stderr, "Center: %d, %d\n", -nCenterX, -nCenterY );
+        Vector2D aCorrection( -nCenterX, -nCenterY );
+        aCorrection *= *m_aTransform;
+
+        Matrix3D aCorrectionMatrix;
+        aCorrectionMatrix.Translate( aCorrection );
+
+        fprintf( stderr, "Correction: %f, %f\n", aCorrection.X(), aCorrection.Y() );
+
+        aTransform *= aCorrectionMatrix;
+    }*/
+
+    HomogenMatrix3 aMatrix(
+            HomogenMatrixLine3( aTransform.get( 0, 0 ), aTransform.get( 0, 1 ), aTransform.get( 0, 2 ) ),
+            HomogenMatrixLine3( aTransform.get( 1, 0 ), aTransform.get( 1, 1 ), aTransform.get( 1, 2 ) ),
+            HomogenMatrixLine3( aTransform.get( 2, 0 ), aTransform.get( 2, 1 ), aTransform.get( 2, 2 ) ) );
+    
+    fprintf( stderr, "m_aTransform:\n  %f, %f, %f\n  %f, %f, %f\n  %f, %f, %f\n",
+            aTransform.get( 0, 0 ), aTransform.get( 0, 1 ), aTransform.get( 0, 2 ),
+            aTransform.get( 1, 0 ), aTransform.get( 1, 1 ), aTransform.get( 1, 2 ),
+            aTransform.get( 2, 0 ), aTransform.get( 2, 1 ), aTransform.get( 2, 2 ) );
+
+    fprintf( stderr, "Matrix:\n  %f, %f, %f\n  %f, %f, %f\n  %f, %f, %f\n",
+            aMatrix.Line1.Column1, aMatrix.Line1.Column2, aMatrix.Line1.Column3,
+            aMatrix.Line2.Column1, aMatrix.Line2.Column2, aMatrix.Line2.Column3,
+            aMatrix.Line3.Column1, aMatrix.Line3.Column2, aMatrix.Line3.Column3 );
+
+    xPropertySet->setPropertyValue( PROPERTY_TRANSFORMATION, makeAny( aMatrix ) );
+}
+
+void SVGAttributes::SetStrokePaint( const svg_paint_t *paint )
+{
+    if ( !paint )
+        return;
+
+    switch ( paint->type )
+    {
+        case SVG_PAINT_TYPE_NONE:
+            m_aLineStyle = boost::optional<LineStyle>(LineStyle_NONE);
+            break;
+
+        case SVG_PAINT_TYPE_COLOR:
+            m_aLineStyle = boost::optional<LineStyle>(LineStyle_SOLID);
+            m_aLineColor = boost::optional<sal_Int32>(( svg_color_get_red(   &(paint->p.color) ) << 16 ) +
+                           ( svg_color_get_green( &(paint->p.color) ) << 8 ) +
+                             svg_color_get_blue(  &(paint->p.color) ));
+            break;
+
+        case SVG_PAINT_TYPE_GRADIENT:
+            fprintf( stderr, "TODO paint type: GRADIENT\n" );
+            break;
+
+        case SVG_PAINT_TYPE_PATTERN:
+            fprintf( stderr, "TODO paint type: PATTERN\n" );
+            break;
+
+        default:
+            fprintf( stderr, "Unknown paint type\n" );
+    }
+}
+
+void SVGAttributes::SetStrokeWidth( const svg_length_t *width )
+{
+    m_aLineWidth = boost::optional<sal_Int32>(ToInt( width ));
+}
+
+void SVGAttributes::SetStrokeLineJoin( svg_stroke_line_join_t line_join )
+{
+    switch ( line_join )
+    {
+        case SVG_STROKE_LINE_JOIN_BEVEL: m_aLineJoint = boost::optional<LineJoint>(LineJoint_BEVEL); break;
+        case SVG_STROKE_LINE_JOIN_MITER: m_aLineJoint = boost::optional<LineJoint>(LineJoint_MITER); break;
+        case SVG_STROKE_LINE_JOIN_ROUND: m_aLineJoint = boost::optional<LineJoint>(LineJoint_ROUND); break;
+        default:
+            fprintf( stderr, "Unknown line join type\n" );
+    }
+}
+
+void SVGAttributes::SetFillPaint( const svg_paint_t *paint )
+{
+    if ( !paint )
+        return;
+
+    switch ( paint->type )
+    {
+        case SVG_PAINT_TYPE_NONE:
+            m_aFillStyle = boost::optional<FillStyle>(FillStyle_NONE);
+            break;
+
+        case SVG_PAINT_TYPE_COLOR:
+            m_aFillStyle = boost::optional<FillStyle>(FillStyle_SOLID);
+            m_aFillColor = boost::optional<sal_Int32>(( svg_color_get_red(   &(paint->p.color) ) << 16 ) +
+                           ( svg_color_get_green( &(paint->p.color) ) << 8 ) +
+                             svg_color_get_blue(  &(paint->p.color) ));
+            break;
+
+        case SVG_PAINT_TYPE_GRADIENT:
+            fprintf( stderr, "TODO paint type: GRADIENT\n" );
+            break;
+
+        case SVG_PAINT_TYPE_PATTERN:
+            fprintf( stderr, "TODO paint type: PATTERN\n" );
+            break;
+
+        default:
+            fprintf( stderr, "Unknown paint type\n" );
+    }
+}
+
+void SVGAttributes::Transform( double a, double b, double c, double d, double e, double f )
+{
+    fprintf( stderr, "abcdef: %f, %f, %f, %f, %f, %f\n",
+             a, b, c, d, e, f );
+
+    B2DHomMatrix aTransform;
+    aTransform.set( 0, 0, a );   aTransform.set( 0, 1, c );   aTransform.set( 0, 2, e*USER_UNIT );
+    aTransform.set( 1, 0, b );   aTransform.set( 1, 1, d );   aTransform.set( 1, 2, f*USER_UNIT );
+    aTransform.set( 2, 0, 0.0 ); aTransform.set( 2, 1, 0.0 ); aTransform.set( 2, 2, 1.0 );
+
+    if ( !!m_aTransform )
+        *m_aTransform *= aTransform;
+    else
+        m_aTransform = boost::optional<B2DHomMatrix>(aTransform);
+#if 0
+    Vector2D aTRScale;
+    double   fTRShear;
+    double   fTRRotate;
+    Vector2D aTRTranslate;
+    aTransform.DecomposeAndCorrect( aTRScale, fTRShear, fTRRotate, aTRTranslate );
+
+    fprintf( stderr, "Scale == ( %f, %f ), Shear == %f, Rotate == %f, Translate == ( %f, %f )\n",
+            aTRScale[0], aTRScale[1],
+            fTRShear,
+            fTRRotate,
+            aTRTranslate[0], aTRTranslate[1] );
+
+    m_aTransform =
+        HomogenMatrix3( HomogenMatrixLine3( a, c, e*USER_UNIT ),
+                        HomogenMatrixLine3( b, d, f*USER_UNIT ),
+                        HomogenMatrixLine3( 0.0, 0.0, 1.0 ) );
+
+//#if 0
+    Matrix3D aMatrix;
+    aMatrix.Rotate( 10.0 );
+    aMatrix.Translate( 100000.0, 50000.0 );
+
+    m_aTransform =
+        HomogenMatrix3( HomogenMatrixLine3( aMatrix[0][0], aMatrix[0][1], aMatrix[0][2] ),
+                        HomogenMatrixLine3( aMatrix[1][0], aMatrix[1][1], aMatrix[1][2] ),
+                        HomogenMatrixLine3( aMatrix[2][0], aMatrix[2][1], aMatrix[2][2] ) );
+#endif
+}
+
+// SVGGroup //
+
+SVGGroup::SVGGroup( const SVGAttributes &rAttr )
+    : m_aAttr( rAttr ),
+      m_xShapes( utl::getProcessServiceFactory()->createInstance( SHAPE_COLLECTION ), UNO_QUERY )
+{
+}
+
+Reference< XShapeGroup > SVGGroup::AsShapeGroup(const Reference< XShapeGrouper > &xShapeGrouper )
+{
+    return xShapeGrouper->group( m_xShapes );
+}
+
+void SVGGroup::Add( const Reference< XShape >& xShape )
+{
+    m_xShapes->add( xShape );
+}
+
+// SVGReader //
+
+SVGReader::SVGReader( const Reference< XMultiServiceFactory >& xServiceFactory,
+                      const Reference< XShapes >& xShapes )
+    : m_xServiceFactory( xServiceFactory ),
+      m_xShapes( xShapes ),
+      m_bReadingElement( false ),
+      m_aViewportSize( 1, 1 )
+{
+}
+
+SVGAttributes& SVGReader::CurrentAttr()
+{
+    if ( m_bReadingElement || m_aGroups.empty() )
+        return m_aElementAttr;
+    else
+        return m_aGroups.top().Attr();
+}
+
+void SVGReader::BeginElement()
+{
+    m_bReadingElement = true;
+
+    if ( m_aGroups.empty() )
+        m_aElementAttr = SVGAttributes();
+    else
+        m_aElementAttr = m_aGroups.top().Attr();
+}
+
+void SVGReader::BeginGroup()
+{
+    m_bReadingElement = false;
+
+    if ( m_aGroups.empty() )
+        m_aGroups.push( SVGGroup() );
+    else
+        m_aGroups.push( SVGGroup( m_aGroups.top().Attr() ) );
+}
+
+bool SVGReader::EndGroup()
+{
+    if ( m_aGroups.empty() )
+        return false; // error
+
+    Reference< XShapeGrouper > xShapeGrouper( m_xShapes, UNO_QUERY );
+
+    // group the shapes
+    Reference< XShape > xShape( m_aGroups.top().AsShapeGroup( xShapeGrouper ), UNO_QUERY );
+    m_aGroups.pop();
+
+    if ( m_aGroups.empty() )
+    {
+        sal_Int32 nPageWidth = 0, nPageHeight = 0;
+                                        
+        // get the page size
+        Reference< XPropertySet> xPagePropertySet( m_xShapes, UNO_QUERY );
+        xPagePropertySet->getPropertyValue( rtl::OUString::createFromAscii( "Width" ) ) >>= nPageWidth;
+        xPagePropertySet->getPropertyValue( rtl::OUString::createFromAscii( "Height" ) ) >>= nPageHeight;
+        
+        xShape->setSize( m_aViewportSize );
+//        xShape->setPosition( awt::Point( ( nPageWidth - m_aViewportSize.Width )/2,
+//                                         ( nPageHeight - m_aViewportSize.Height )/2 ) );
+
+        m_xShapes->add( xShape );
+    }
+    else
+        m_aGroups.top().Add( xShape );
+
+    return true;
+}
+
+void SVGReader::SetViewportDimension( svg_length_t *width, svg_length_t *height )
+{
+    m_aViewportSize = awt::Size( std::max( sal_Int32(1), ToInt( width ) ),
+                                 std::max( sal_Int32(1), ToInt( height ) ) );
+}
+
+bool SVGReader::Rect( svg_length_t *x, svg_length_t *y,
+        svg_length_t *width, svg_length_t *height,
+        svg_length_t *rx, svg_length_t *ry )
+{
+    if ( m_aGroups.empty() )
+        return false; // error
+
+    sal_Int32 nWidth  = ToInt( width );
+    sal_Int32 nHeight = ToInt( height );
+
+    if ( nWidth <= 0 || nHeight <= 0 )
+        return true; // no shape rendered
+
+    // create the shape
+    Reference< XPropertySet > xPropertySet;
+    CreateShape( RECTANGLE_SHAPE, xPropertySet );
+
+    // position, size, shear and rotate
+    m_aElementAttr.ApplyTransformation( xPropertySet,
+            ToInt( x ), ToInt( y ), nWidth, nHeight );
+    
+    // corner radius
+    sal_Int32 nRX = ToInt( rx );
+    sal_Int32 nRY = ToInt( ry );
+    if ( nRX != 0 || nRY != 0 )
+    {
+        if ( nRX == nRY || nRY == 0 )
+            xPropertySet->setPropertyValue( PROPERTY_CORNER_RADIUS, makeAny( nRX ) );
+        else if ( nRX == 0 )
+            xPropertySet->setPropertyValue( PROPERTY_CORNER_RADIUS, makeAny( nRY ) );
+        else
+        {
+            /* FIXME temporary! */
+            xPropertySet->setPropertyValue( PROPERTY_CORNER_RADIUS, makeAny( ( nRX + nRY )/2 ) );
+            fprintf( stderr, "Rect(): FIXME nRX != nRY - convert to a path according to the SVG spec.\n" );
+        }
+    }
+
+    return true;
+}
+
+bool SVGReader::Ellipse( svg_length_t *cx, svg_length_t *cy,
+        svg_length_t *rx, svg_length_t *ry )
+{
+    if ( m_aGroups.empty() )
+        return false; // error
+
+    sal_Int32 nX = ToInt( cx );
+    sal_Int32 nY = ToInt( cy );
+    sal_Int32 nRadiusX = ToInt( rx );
+    sal_Int32 nRadiusY = ToInt( ry );
+
+    if ( nRadiusX < 0 || nRadiusY < 0 )
+        return false; // error
+
+    if ( nRadiusX == 0 || nRadiusY == 0 )
+        return true; // no shape rendered
+
+    // create the shape
+    Reference< XPropertySet > xPropertySet;
+    CreateShape( ELLIPSE_SHAPE, xPropertySet );
+
+    Reference< XShape > xShape( xPropertySet, UNO_QUERY );
+    fprintf( stderr, "Position (before):\n  %d, %d\n", xShape->getPosition().X, xShape->getPosition().Y );
+            
+    // position, size, shear and rotate
+    m_aElementAttr.ApplyTransformation( xPropertySet,
+            nX, nY, 2*nRadiusX, 2*nRadiusY,
+            nRadiusX, nRadiusY);
+
+    fprintf( stderr, "Position (after):\n  %d, %d\n", xShape->getPosition().X, xShape->getPosition().Y );
+    
+    return true;
+}
+
+void SVGReader::CreateShape( const rtl::OUString & rServiceName,
+        Reference< XPropertySet > &xPropertySet )
+{
+    Reference< XShape > xShape( m_xServiceFactory->createInstance( rServiceName ), UNO_QUERY );
+
+    // add to the document and to the top group
+    m_xShapes->add( xShape );
+    m_aGroups.top().Add( xShape );
+
+    // properties for this shape
+    xPropertySet = Reference< XPropertySet>::query( xShape );
+    m_aElementAttr.ApplyProperties( xPropertySet );
+}
+
+sal_Int32 ToInt( const svg_length_t *length )
+{
+    if ( !length )
+        return 0;
+
+    switch ( length->unit )
+    {
+        case SVG_LENGTH_UNIT_CM: return sal_Int32( length->value * 1000.0 );
+        case SVG_LENGTH_UNIT_EM: fprintf( stderr, "TODO: legth type EM not implemented.\n" ); return 1000;
+        case SVG_LENGTH_UNIT_EX: fprintf( stderr, "TODO: legth type EX not implemented.\n" ); return 1000;
+        case SVG_LENGTH_UNIT_IN: return sal_Int32( length->value * 2540.0 );
+        case SVG_LENGTH_UNIT_MM: return sal_Int32( length->value * 100.0 );
+        case SVG_LENGTH_UNIT_PC: fprintf( stderr, "TODO: legth type PC not implemented.\n" ); return 1000;
+        case SVG_LENGTH_UNIT_PCT: fprintf( stderr, "TODO: legth type PCT not implemented.\n" ); return 1000;
+        case SVG_LENGTH_UNIT_PT: fprintf( stderr, "TODO: legth type PT not implemented.\n" ); return 1000;
+        case SVG_LENGTH_UNIT_PX: return sal_Int32( length->value * USER_UNIT );
+        default: fprintf( stderr, "Unknown length type\n" );
+    }
+
+    return 0;
+}
--- filter/source/svg/svgreader.hxx	1970-01-01 01:00:00.000000000 +0100
+++ filter/source/svg/svgreader.hxx	2007-06-14 13:41:09.000000000 +0200
@@ -0,0 +1,146 @@
+ /*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef SVGREADER_HXX
+#define SVGREADER_HXX
+
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/drawing/FillStyle.hpp>
+#include <com/sun/star/drawing/HomogenMatrix3.hpp>
+#include <com/sun/star/drawing/LineDash.hpp>
+#include <com/sun/star/drawing/LineJoint.hpp>
+#include <com/sun/star/drawing/LineStyle.hpp>
+#include <com/sun/star/drawing/XShapeGroup.hpp>
+#include <com/sun/star/drawing/XShapeGrouper.hpp>
+#include <com/sun/star/drawing/XShapes.hpp>
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#include <com/sun/star/uno/XInterface.hpp>
+#include <com/sun/star/util/Color.hpp>
+
+#include <basegfx/matrix/b2dhommatrix.hxx>
+
+#include <svg.h>
+
+#include <stack>
+#include <boost/optional.hpp>
+
+class SVGAttributes
+{
+    // TODO more attributes...
+    boost::optional< ::com::sun::star::drawing::LineStyle >      m_aLineStyle;
+    boost::optional< ::com::sun::star::util::Color >             m_aLineColor;
+    boost::optional< sal_Int32 >                                 m_aLineWidth;
+    boost::optional< ::com::sun::star::drawing::LineJoint >      m_aLineJoint;
+
+    boost::optional< ::com::sun::star::drawing::FillStyle >      m_aFillStyle;
+    boost::optional< ::com::sun::star::util::Color >             m_aFillColor;
+    
+    boost::optional< ::basegfx::B2DHomMatrix >                   m_aTransform;
+
+public:
+    SVGAttributes();
+
+    SVGAttributes&          operator=( const SVGAttributes &rAttr );
+
+    void                    ApplyProperties( ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet > &xPropertySet );
+    void                    ApplyTransformation( ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet > &xPropertySet,
+                                                 sal_Int32 nX, sal_Int32 nY,
+                                                 sal_Int32 nWidth, sal_Int32 nHeight,
+                                                 sal_Int32 nCenterX = 0, sal_Int32 nCenterY = 0 );
+
+    void                    SetStrokePaint( const svg_paint_t *paint );
+    void                    SetStrokeWidth( const svg_length_t *width );
+    void                    SetStrokeLineJoin( svg_stroke_line_join_t line_join );
+
+    void                    SetFillPaint( const svg_paint_t *paint );
+
+    void                    Transform( double a, double b, double c, double d, double e, double f );
+};
+
+class SVGGroup
+{
+    SVGAttributes           m_aAttr;
+
+    ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShapes > m_xShapes;
+
+public:
+    SVGGroup( const SVGAttributes &rAttr = SVGAttributes() );
+
+    SVGAttributes&          Attr() { return m_aAttr; }
+    ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShapeGroup > AsShapeGroup( const ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShapeGrouper >& xShapeGrouper );
+
+    void                    Add( const ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape >& xShape );
+};
+
+class SVGReader
+{
+    // service factory - for construction of the shapes
+    ::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory > m_xServiceFactory;
+    // xshapes - store the result here
+    ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShapes >           m_xShapes;
+    
+    // are we reading an element at the moment; or a group?
+    bool                    m_bReadingElement;
+
+    std::stack< SVGGroup >  m_aGroups;
+    SVGAttributes           m_aElementAttr;
+
+    ::com::sun::star::awt::Size m_aViewportSize;
+    
+    // TODO lines/curves/arcs list for paths
+public:
+    SVGReader( const ::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory >& xServiceFactory,
+               const ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShapes >& xShapes );
+
+    SVGAttributes&          CurrentAttr();
+
+    void                    BeginElement();
+    void                    BeginGroup();
+    bool                    EndGroup();
+
+    void                    SetViewportDimension( svg_length_t *width, svg_length_t *height );
+
+    bool                    Rect( svg_length_t *x, svg_length_t *y,
+                                  svg_length_t *width, svg_length_t *height,
+                                  svg_length_t *rx, svg_length_t *ry );
+    bool                    Ellipse( svg_length_t *cx, svg_length_t *cy,
+                                     svg_length_t *rx, svg_length_t *ry );
+
+protected:
+    void                    CreateShape( const ::rtl::OUString & rServiceName,
+                                         ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet > &xPropertySet );
+};
+
+#endif // SVGREADER_HXX
