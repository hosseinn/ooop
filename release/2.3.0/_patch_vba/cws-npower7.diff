Index: basic/inc/basic/basmgr.hxx
===================================================================
RCS file: /cvs/script/basic/inc/basic/basmgr.hxx,v
retrieving revision 1.2
retrieving revision 1.2.12.1
diff -u -p -u -p -r1.2 -r1.2.12.1
--- basic/inc/basic/basmgr.hxx	11 Apr 2007 12:50:02 -0000	1.2
+++ basic/inc/basic/basmgr.hxx	2 May 2007 09:44:21 -0000	1.2.12.1
@@ -167,6 +167,7 @@ private:
 	String				aName;
 	String				maStorageName;
 	BOOL				bBasMgrModified;
+	BOOL				mbDocMgr;
 
 	BasicManagerImpl*	mpImpl;
 
@@ -190,8 +191,8 @@ protected:
 
 public:
 					TYPEINFO();
-                    BasicManager( SotStorage& rStorage, const String& rBaseURL, StarBASIC* pParentFromStdLib = NULL, String* pLibPath = NULL );
-					BasicManager( StarBASIC* pStdLib, String* pLibPath = NULL );
+                    BasicManager( SotStorage& rStorage, const String& rBaseURL, StarBASIC* pParentFromStdLib = NULL, String* pLibPath = NULL, BOOL bDocMgr = FALSE );
+					BasicManager( StarBASIC* pStdLib, String* pLibPath = NULL, BOOL bDocMgr = FALSE );
 
     /** deletes the given BasicManager instance
 
Index: basic/inc/basic/sbstar.hxx
===================================================================
RCS file: /cvs/script/basic/inc/basic/sbstar.hxx,v
retrieving revision 1.2
retrieving revision 1.2.12.1
diff -u -p -u -p -r1.2 -r1.2.12.1
--- basic/inc/basic/sbstar.hxx	11 Apr 2007 12:52:47 -0000	1.2
+++ basic/inc/basic/sbstar.hxx	2 May 2007 09:44:21 -0000	1.2.12.1
@@ -81,6 +81,7 @@ class StarBASIC : public SbxObject
 	Link			aBreakHdl;			// Breakpoint-Handler
 	BOOL			bNoRtl;				// TRUE: RTL nicht durchsuchen
 	BOOL			bBreak;				// TRUE: Break, sonst Step
+	BOOL			bDocBasic;
 	BasicLibInfo*	pLibInfo;			// Infoblock fuer Basic-Manager
 	SbLanguageMode	eLanguageMode;		// LanguageMode des Basic-Objekts
 protected:
@@ -104,7 +105,7 @@ public:
 	SBX_DECL_PERSIST_NODATA(SBXCR_SBX,SBXID_BASIC,1);
 	TYPEINFO();
 
-	StarBASIC( StarBASIC* pParent = NULL );
+	StarBASIC( StarBASIC* pParent = NULL, BOOL bIsDocBasic = FALSE );
 
 	// #51727 SetModified ueberladen, damit der Modified-
 	// Zustand nicht an den Parent weitergegeben wird.
@@ -203,6 +204,7 @@ public:
 	static void StaticEnableReschedule( BOOL bReschedule );
 
 	SbxObjectRef getRTL( void ) { return pRtl; }
+	BOOL IsDocBasic() { return bDocBasic; }
 };
 
 #ifndef __SB_SBSTARBASICREF_HXX
Index: basic/inc/basic/sbx.hxx
===================================================================
RCS file: /cvs/script/basic/inc/basic/sbx.hxx,v
retrieving revision 1.2
retrieving revision 1.2.12.1
diff -u -p -u -p -r1.2 -r1.2.12.1
--- basic/inc/basic/sbx.hxx	11 Apr 2007 12:53:21 -0000	1.2
+++ basic/inc/basic/sbx.hxx	2 May 2007 09:44:42 -0000	1.2.12.1
@@ -263,6 +263,7 @@ class SbxDimArray : public SbxArray
 	SbxDim* pFirst, *pLast;         // Links fuer Dimension-Tabelle
 	short   nDim;                   // Anzahl Dimensionen
 	void   AddDimImpl32( INT32, INT32, BOOL bAllowSize0 );
+	bool mbHasFixedSize;
 protected:
 	USHORT  Offset( const short* );
 	UINT32  Offset32( const INT32* );
@@ -302,6 +303,8 @@ public:
 	void   AddDim32( INT32, INT32 );
 	void   unoAddDim32( INT32, INT32 );
 	BOOL   GetDim32( INT32, INT32&, INT32& ) const;
+        bool hasFixedSize() { return mbHasFixedSize; };
+        void setHasFixedSize( bool bHasFixedSize ) {mbHasFixedSize = bHasFixedSize; };
 };
 
 #endif
Index: basic/source/basmgr/basicmanagerrepository.cxx
===================================================================
RCS file: /cvs/script/basic/source/basmgr/basicmanagerrepository.cxx,v
retrieving revision 1.4
retrieving revision 1.4.14.1
diff -u -p -u -p -r1.4 -r1.4.14.1
--- basic/source/basmgr/basicmanagerrepository.cxx	15 Mar 2007 15:37:48 -0000	1.4
+++ basic/source/basmgr/basicmanagerrepository.cxx	2 May 2007 09:44:21 -0000	1.4.14.1
@@ -491,7 +491,7 @@ namespace basic
 		    SotStorageRef xDummyStor = new SotStorage( ::rtl::OUString() );
             pBasicManager = new BasicManager( *xDummyStor, String() /* TODO/LATER: xStorage */,
 															    pAppBasic,
-															    &aAppBasicDir );
+															    &aAppBasicDir, TRUE );
 		    if ( pBasicManager->HasErrors() )
 		    {
 			    // handle errors
@@ -517,7 +517,7 @@ namespace basic
 		    // create new BASIC-manager
 		    StarBASIC* pBasic = new StarBASIC( pAppBasic );
 		    pBasic->SetFlag( SBX_EXTSEARCH );
-		    pBasicManager = new BasicManager( pBasic );
+		    pBasicManager = new BasicManager( pBasic, NULL, TRUE );
 	    }
 
         // knit the containers with the BasicManager
Index: basic/source/basmgr/basmgr.cxx
===================================================================
RCS file: /cvs/script/basic/source/basmgr/basmgr.cxx,v
retrieving revision 1.39
retrieving revision 1.39.2.1
diff -u -p -u -p -r1.39 -r1.39.2.1
--- basic/source/basmgr/basmgr.cxx	26 Apr 2007 08:32:47 -0000	1.39
+++ basic/source/basmgr/basmgr.cxx	2 May 2007 09:44:21 -0000	1.39.2.1
@@ -685,7 +685,7 @@ void BasicLibInfo::CalcRelStorageName( c
 	else
 		SetRelStorageName( String() );
 }
-BasicManager::BasicManager( SotStorage& rStorage, const String& rBaseURL, StarBASIC* pParentFromStdLib, String* pLibPath )
+BasicManager::BasicManager( SotStorage& rStorage, const String& rBaseURL, StarBASIC* pParentFromStdLib, String* pLibPath, BOOL bDocMgr ) : mbDocMgr( bDocMgr )
 {
 	DBG_CTOR( BasicManager, 0 );
 
@@ -714,7 +714,7 @@ BasicManager::BasicManager( SotStorage& 
 		if ( !pStdLib )
 		{
 			// Sollte eigentlich nie passieren, aber dann wenigstens nicht abstuerzen...
-			pStdLib = new StarBASIC;
+			pStdLib = new StarBASIC( NULL, mbDocMgr );
 			BasicLibInfo* pStdLibInfo = pLibs->GetObject( 0 );
 			if ( !pStdLibInfo )
 				pStdLibInfo = CreateLibInfo();
@@ -895,7 +895,7 @@ void BasicManager::SetLibraryContainerIn
     InsertGlobalUNOConstant( "DialogLibraries", makeAny( mpImpl->maContainerInfo.mxDialogCont ) );
 }
 
-BasicManager::BasicManager( StarBASIC* pSLib, String* pLibPath )
+BasicManager::BasicManager( StarBASIC* pSLib, String* pLibPath, BOOL bDocMgr ) : mbDocMgr( bDocMgr )
 {
 	DBG_CTOR( BasicManager, 0 );
 	Init();
@@ -936,7 +936,7 @@ void BasicManager::ImpMgrNotLoaded( cons
 
 	// Eine STD-Lib erzeugen, sonst macht es Peng!
 	BasicLibInfo* pStdLibInfo = CreateLibInfo();
-	pStdLibInfo->SetLib( new StarBASIC );
+	pStdLibInfo->SetLib( new StarBASIC( NULL, mbDocMgr ) );
     StarBASICRef xStdLib = pStdLibInfo->GetLib();
 	xStdLib->SetName( String::CreateFromAscii(szStdLibName) );
 	pStdLibInfo->SetLibName( String::CreateFromAscii(szStdLibName) );
@@ -948,7 +948,7 @@ void BasicManager::ImpMgrNotLoaded( cons
 void BasicManager::ImpCreateStdLib( StarBASIC* pParentFromStdLib )
 {
 	BasicLibInfo* pStdLibInfo = CreateLibInfo();
-	StarBASIC* pStdLib = new StarBASIC( pParentFromStdLib );
+	StarBASIC* pStdLib = new StarBASIC( pParentFromStdLib, mbDocMgr );
 	pStdLibInfo->SetLib( pStdLib );
 	pStdLib->SetName( String::CreateFromAscii(szStdLibName) );
 	pStdLibInfo->SetLibName( String::CreateFromAscii(szStdLibName) );
@@ -1237,7 +1237,7 @@ BOOL BasicManager::ImpLoadLibary( BasicL
 				if ( !bInfosOnly )
 				{
 					if ( !pLibInfo->GetLib().Is() )
-						pLibInfo->SetLib( new StarBASIC( GetStdLib() ) );
+						pLibInfo->SetLib( new StarBASIC( GetStdLib(), mbDocMgr ) );
 					xBasicStream->SetBufferSize( 1024 );
 					xBasicStream->Seek( STREAM_SEEK_TO_BEGIN );
 					bLoaded = ImplLoadBasic( *xBasicStream, pLibInfo->GetLibRef() );
@@ -1660,7 +1660,7 @@ StarBASIC* BasicManager::CreateLib( cons
 		return 0;
 
 	BasicLibInfo* pLibInfo = CreateLibInfo();
-	StarBASIC* pNew = new StarBASIC( GetStdLib() );
+	StarBASIC* pNew = new StarBASIC( GetStdLib(), mbDocMgr );
 	GetStdLib()->Insert( pNew );
 	pNew->SetFlag( SBX_EXTSEARCH | SBX_DONTSTORE );
 	pLibInfo->SetLib( pNew );
@@ -1718,7 +1718,7 @@ StarBASIC* BasicManager::CreateLibForLib
 		return 0;
 
 	BasicLibInfo* pLibInfo = CreateLibInfo();
-	StarBASIC* pNew = new StarBASIC( GetStdLib() );
+	StarBASIC* pNew = new StarBASIC( GetStdLib(), mbDocMgr );
 	GetStdLib()->Insert( pNew );
 	pNew->SetFlag( SBX_EXTSEARCH | SBX_DONTSTORE );
 	pLibInfo->SetLib( pNew );
Index: basic/source/classes/sb.cxx
===================================================================
RCS file: /cvs/script/basic/source/classes/sb.cxx,v
retrieving revision 1.31
retrieving revision 1.31.2.1
diff -u -p -u -p -r1.31 -r1.31.2.1
--- basic/source/classes/sb.cxx	26 Apr 2007 08:33:02 -0000	1.31
+++ basic/source/classes/sb.cxx	2 May 2007 09:44:21 -0000	1.31.2.1
@@ -660,8 +660,8 @@ SbModule* SbClassFactory::FindClass( con
 
 ////////////////////////////////////////////////////////////////////////////
 
-StarBASIC::StarBASIC( StarBASIC* p )
-	: SbxObject( String( RTL_CONSTASCII_USTRINGPARAM("StarBASIC") ) )
+StarBASIC::StarBASIC( StarBASIC* p, BOOL bIsDocBasic  )
+	: SbxObject( String( RTL_CONSTASCII_USTRINGPARAM("StarBASIC") ) ), bDocBasic( bIsDocBasic )
 {
 	SetParent( p );
 	pLibInfo = NULL;
Index: basic/source/classes/sbunoobj.cxx
===================================================================
RCS file: /cvs/script/basic/source/classes/sbunoobj.cxx,v
retrieving revision 1.46
retrieving revision 1.46.6.4
diff -u -p -u -p -r1.46 -r1.46.6.4
--- basic/source/classes/sbunoobj.cxx	29 Jan 2007 15:05:07 -0000	1.46
+++ basic/source/classes/sbunoobj.cxx	30 Apr 2007 11:55:20 -0000	1.46.6.4
@@ -110,6 +110,9 @@ using namespace rtl;
 #include<runtime.hxx>
 
 #include<math.h>
+#include <hash_map>
+#include <com/sun/star/reflection/XTypeDescriptionEnumerationAccess.hpp>
+#include <com/sun/star/reflection/XConstantsTypeDescription.hpp>
 
 TYPEINIT1(SbUnoMethod,SbxMethod)
 TYPEINIT1(SbUnoProperty,SbxProperty)
@@ -130,6 +133,7 @@ static String ID_DBG_METHODS( RTL_CONSTA
 static String aIllegalArgumentExceptionName
     ( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.lang.IllegalArgumentException" ) );
 static OUString aSeqLevelStr( RTL_CONSTASCII_USTRINGPARAM("[]") );
+static OUString defaultNameSpace( RTL_CONSTASCII_USTRINGPARAM("org.openoffice") );
 
 // Gets the default property for an uno object. Note: There is some 
 // redirection built in. The property name specifies the name
@@ -1510,6 +1514,50 @@ String getBasicObjectTypeName( SbxObject
 	return aName;
 }
 
+bool checkUnoObjectType( SbUnoObject* pUnoObj, 
+	const String& aClass )
+{
+	bool result = false;
+	Any aToInspectObj = pUnoObj->getUnoAny();
+	TypeClass eType = aToInspectObj.getValueType().getTypeClass();
+	if( eType != TypeClass_INTERFACE )
+		return false;
+	const Reference< XInterface > x = *(Reference< XInterface >*)aToInspectObj.getValue();
+	Reference< XTypeProvider > xTypeProvider( x, UNO_QUERY );
+	if( xTypeProvider.is() )
+	{
+		Sequence< Type > aTypeSeq = xTypeProvider->getTypes();
+		const Type* pTypeArray = aTypeSeq.getConstArray();
+		UINT32 nIfaceCount = aTypeSeq.getLength();
+		for( UINT32 j = 0 ; j < nIfaceCount ; j++ )
+		{
+			const Type& rType = pTypeArray[j];
+
+			Reference<XIdlClass> xClass = TypeToIdlClass( rType );
+			if( xClass.is() )
+			{
+				OUString sClassName = xClass->getName();
+				OSL_TRACE("Checking if object implements %s",
+					OUStringToOString( defaultNameSpace + aClass, 
+						RTL_TEXTENCODING_UTF8 ).getStr() );
+				// although interfaces in the org.openoffice.vba namespace
+				// obey the idl rules and have a leading X, in basic we
+				// want to be able to do something like
+				// 'dim wrkbooks as WorkBooks'
+				// so test assumes the 'X' has been dropped
+				sal_Int32 indexLastDot = sClassName.lastIndexOf('.');
+				if ( indexLastDot > -1 && sClassName.copy( indexLastDot + 1).equalsIgnoreAsciiCase( OUString( RTL_CONSTASCII_USTRINGPARAM("X") ) + aClass ) )
+				{
+					result = true;
+					break;
+				}
+			}
+			else
+				break;
+		}
+	}		
+	return result;
+}
 
 // Dbg-Hilfsmethode zum Auslesen der in einem Object implementierten Interfaces
 String Impl_GetSupportedInterfaces( SbUnoObject* pUnoObj )
@@ -3066,6 +3114,83 @@ void RTL_Impl_EqualUnoObjects( StarBASIC
 		refVar->PutBool( TRUE );
 }
 
+typedef std::hash_map< OUString, std::vector< OUString >, OUStringHash, ::std::equal_to< OUString > > ModuleHash;
+
+
+// helper wrapper function to interact with TypeProvider and
+// XTypeDescriptionEnumerationAccess.
+// if it fails for whatever reason 
+// returned Reference<> be null e.g. .is() will be false
+
+Reference< XTypeDescriptionEnumeration > 
+getTypeDescriptorEnumeration( const OUString& sSearchRoot,
+	const Sequence< TypeClass >& types, TypeDescriptionSearchDepth depth )
+{
+	Reference< XTypeDescriptionEnumeration > xEnum;
+	Reference< XTypeDescriptionEnumerationAccess> xTypeEnumAccess( getTypeProvider_Impl(), UNO_QUERY );
+	if ( xTypeEnumAccess.is() )
+	{
+		try
+		{
+			xEnum = xTypeEnumAccess->createTypeDescriptionEnumeration(
+				sSearchRoot, types, depth );
+		}
+		catch( NoSuchTypeNameException& /*nstne*/ ) {}
+		catch( InvalidTypeNameException& /*nstne*/ ) {}
+	}
+	return xEnum;
+}
+
+typedef std::hash_map< OUString, Any, OUStringHash, ::std::equal_to< OUString > > VBAConstantsHash;
+
+SbxVariable* getVBAConstant( const String& rName )
+{
+	SbxVariable* pConst = NULL;
+	static VBAConstantsHash aConstCache;	
+	static bool isInited = false;
+	if ( !isInited )
+	{
+		Sequence< TypeClass > types(1);
+		types[ 0 ] = TypeClass_CONSTANTS;
+		Reference< XTypeDescriptionEnumeration > xEnum = getTypeDescriptorEnumeration( defaultNameSpace, types, TypeDescriptionSearchDepth_INFINITE  );
+
+		if ( !xEnum.is() )
+			return NULL;	
+
+		while ( xEnum->hasMoreElements() )
+		{
+			Reference< XConstantsTypeDescription > xConstants( xEnum->nextElement(), UNO_QUERY );
+			if ( xConstants.is() )
+			{
+				Sequence< Reference< XConstantTypeDescription > > aConsts = xConstants->getConstants();
+				Reference< XConstantTypeDescription >* pSrc = aConsts.getArray();
+				sal_Int32 nLen = aConsts.getLength();
+				for ( sal_Int32 index =0;  index<nLen; ++pSrc, ++index )
+				{
+					Reference< XConstantTypeDescription >& rXConst =
+						*pSrc;
+					OUString sFullName = rXConst->getName();
+					sal_Int32 indexLastDot = sFullName.lastIndexOf('.');
+					OUString sLeafName;
+					if ( indexLastDot > -1 )
+						sLeafName = sFullName.copy( indexLastDot + 1);
+					aConstCache[ sLeafName.toAsciiLowerCase() ] = rXConst->getConstantValue();	
+				}
+			}
+		}
+		isInited = true;
+	}
+	OUString sKey( rName );
+	VBAConstantsHash::const_iterator it = aConstCache.find( sKey.toAsciiLowerCase() );
+	if ( it != aConstCache.end() )
+	{
+		pConst = new SbxVariable( SbxVARIANT );
+		pConst->SetName( rName );
+		unoToSbxValue( pConst, it->second );
+	}
+	return pConst;	
+}
+
 // Funktion, um einen globalen Bezeichner im
 // UnoScope zu suchen und fuer Sbx zu wrappen
 SbxVariable* findUnoClass( const String& rName )
Index: basic/source/classes/sbxmod.cxx
===================================================================
RCS file: /cvs/script/basic/source/classes/sbxmod.cxx,v
retrieving revision 1.36
retrieving revision 1.36.42.3
diff -u -p -u -p -r1.36 -r1.36.42.3
--- basic/source/classes/sbxmod.cxx	3 Nov 2006 15:10:25 -0000	1.36
+++ basic/source/classes/sbxmod.cxx	2 May 2007 09:44:42 -0000	1.36.42.3
@@ -166,7 +166,8 @@ static const char* strListBasicKeyWords[
 	"integer",
 	"is",
 	"let",
-	"lib"
+	"lib",
+	"like",
 	"line",
 	"line input",
 	"local",
@@ -544,7 +545,8 @@ void SbModule::SetSource32( const ::rtl:
 				if( eCurTok == OPTION )
 				{
 					eCurTok = aTok.Next();
-					if( eCurTok == COMPATIBLE )
+					if( eCurTok == COMPATIBLE 
+					|| ( ( eCurTok == VBASUPPORT ) && ( aTok.Next() == NUMBER ) && ( aTok.GetDbl()== 1 ) ) )
 						aTok.SetCompatible( true );
 				}
 			}
@@ -756,7 +758,10 @@ USHORT SbModule::Run( SbMethod* pMeth )
 				pRt->pNext->block();
 			pINST->pRun = pRt;
 			if ( SbiRuntime ::isVBAEnabled() )
+                        {
 				pINST->EnableCompatibility( TRUE );
+				pRt->SetVBAEnabled( true );
+                        }
 			while( pRt->Step() ) {}
 			if( pRt->pNext )
 				pRt->pNext->unblock();
Index: basic/source/comp/codegen.cxx
===================================================================
RCS file: /cvs/script/basic/source/comp/codegen.cxx,v
retrieving revision 1.16
retrieving revision 1.16.42.1
diff -u -p -u -p -r1.16 -r1.16.42.1
--- basic/source/comp/codegen.cxx	3 Nov 2006 15:11:02 -0000	1.16
+++ basic/source/comp/codegen.cxx	2 May 2007 09:45:21 -0000	1.16.42.1
@@ -135,7 +135,7 @@ void SbiCodeGen::Save()
 	// OPTION EXPLICIT-Flag uebernehmen
 	if( pParser->bExplicit )
 		p->SetFlag( SBIMG_EXPLICIT );
-	if( pParser->bVBASupportOn )
+	if( pParser->IsVBASupportOn() )
 		p->SetFlag( SBIMG_VBASUPPORT );
 	
 	int nIfaceCount = 0;
Index: basic/source/comp/dim.cxx
===================================================================
RCS file: /cvs/script/basic/source/comp/dim.cxx,v
retrieving revision 1.26
retrieving revision 1.26.42.2
diff -u -p -u -p -r1.26 -r1.26.42.2
--- basic/source/comp/dim.cxx	1 Nov 2006 16:13:55 -0000	1.26
+++ basic/source/comp/dim.cxx	2 May 2007 09:44:56 -0000	1.26.42.2
@@ -203,6 +203,10 @@ void SbiParser::DefVar( SbiOpcode eOp, B
     	if( eCurTok == GLOBAL )
             bPersistantGlobal = TRUE;
     }
+	// behavior in VBA is that a module scope variable's lifetime is 
+	// tied to the document. e.g. a module scope variable is global
+   	if(  GetBasic()->IsDocBasic() && bVBASupportOn && !pProc ) 
+		bPersistantGlobal = TRUE;
 	// PRIVATE ist Synonym fuer DIM
 	// _CONST_?
 	BOOL bConst = FALSE;
@@ -334,7 +338,7 @@ void SbiParser::DefVar( SbiOpcode eOp, B
 			{
 				case SbGLOBAL:	eOp2 = bPersistantGlobal ? _GLOBAL_P : _GLOBAL; 
                                 goto global;
-				case SbPUBLIC:	eOp2 = _PUBLIC;
+				case SbPUBLIC:	eOp2 = bPersistantGlobal ? _PUBLIC_P : _PUBLIC;
 								// AB 9.7.97, #40689, kein eigener Opcode mehr
 								/*
 								if( bStatic )
@@ -439,7 +443,14 @@ void SbiParser::DefVar( SbiOpcode eOp, B
 				{
 					SbiExpression aExpr( this, *pDef, NULL );
 					aExpr.Gen();
-					aGen.Gen( _ERASE );
+					if ( bVBASupportOn )
+						// delete the array but
+						// clear the variable ( this
+						// allows the processing of
+						// the param to happen as normal without errors ( ordinary ERASE just clears the array )
+						aGen.Gen( _ERASE_CLEAR );
+					else
+						aGen.Gen( _ERASE );
 				}
 				else if( eOp == _REDIMP )
 				{
Index: basic/source/comp/exprnode.cxx
===================================================================
RCS file: /cvs/script/basic/source/comp/exprnode.cxx,v
retrieving revision 1.16
retrieving revision 1.16.48.1
diff -u -p -u -p -r1.16 -r1.16.48.1
--- basic/source/comp/exprnode.cxx	12 Oct 2006 14:34:58 -0000	1.16
+++ basic/source/comp/exprnode.cxx	16 Feb 2007 17:14:15 -0000	1.16.48.1
@@ -244,7 +244,7 @@ void SbiExprNode::CollectBits()
 
 void SbiExprNode::FoldConstants()
 {
-	if( IsOperand() ) return;
+	if( IsOperand() || eTok == LIKE ) return;
 	pLeft->FoldConstants();
 	if( pRight )
 	{
Index: basic/source/comp/parser.cxx
===================================================================
RCS file: /cvs/script/basic/source/comp/parser.cxx,v
retrieving revision 1.19
retrieving revision 1.19.42.2
diff -u -p -u -p -r1.19 -r1.19.42.2
--- basic/source/comp/parser.cxx	2 Nov 2006 16:32:13 -0000	1.19
+++ basic/source/comp/parser.cxx	2 May 2007 09:45:21 -0000	1.19.42.2
@@ -152,7 +152,6 @@ SbiParser::SbiParser( StarBASIC* pb, SbM
 	bSingleLineIf =
 	bExplicit = FALSE;
 	bClassModule = FALSE;
-	bVBASupportOn = FALSE;
 	pPool	 = &aPublics;
 	for( short i = 0; i < 26; i++ )
 		eDefTypes[ i ] = SbxVARIANT;    // Kein expliziter Defaulttyp
@@ -609,7 +608,12 @@ void SbiParser::Set()
 		// ( its necessary for vba objects where set is object
 		// specific and also doesn't involve processing default params )
 		if( pDef->GetTypeId() )
-			aGen.Gen( _SETCLASS, pDef->GetTypeId() );
+		{
+			if ( bVBASupportOn )
+				aGen.Gen( _VBASETCLASS, pDef->GetTypeId() );
+			else
+				aGen.Gen( _SETCLASS, pDef->GetTypeId() );
+		}
 		else
 		{
 			if ( bVBASupportOn )
Index: basic/source/comp/scanner.cxx
===================================================================
RCS file: /cvs/script/basic/source/comp/scanner.cxx,v
retrieving revision 1.23
retrieving revision 1.23.42.1
diff -u -p -u -p -r1.23 -r1.23.42.1
--- basic/source/comp/scanner.cxx	2 Nov 2006 11:02:47 -0000	1.23
+++ basic/source/comp/scanner.cxx	2 May 2007 09:45:21 -0000	1.23.42.1
@@ -53,6 +53,7 @@
 #include <unotools/charclass.hxx>
 #endif
 
+#include <runtime.hxx>
 
 SbiScanner::SbiScanner( const ::rtl::OUString& rBuf, StarBASIC* p ) : aBuf( rBuf )
 {
@@ -76,6 +77,7 @@ SbiScanner::SbiScanner( const ::rtl::OUS
 	bSymbol  =
 	bUsedForHilite =
 	bCompatible = 
+	bVBASupportOn = 
 	bPrevLineExtentsComment = FALSE;
 	bHash    =
 	bErrors  = TRUE;
@@ -424,7 +426,11 @@ BOOL SbiScanner::NextSym()
 				if( *pLine != cSep || cSep == ']' ) break;
 			} else aError = cSep, GenError( SbERR_EXPECTED );
 		}
-		aSym = aLine.copy( n, nCol - n - 1 );
+		// If VBA Interop then doen't eat the [] chars	
+		if ( cSep == ']' && bVBASupportOn )
+			aSym = aLine.copy( n - 1, nCol - n  + 1);
+		else
+			aSym = aLine.copy( n, nCol - n - 1 );
 		// Doppelte Stringbegrenzer raus
 		String s( cSep );
 		s += cSep;
Index: basic/source/comp/token.cxx
===================================================================
RCS file: /cvs/script/basic/source/comp/token.cxx,v
retrieving revision 1.21
retrieving revision 1.21.48.1
diff -u -p -u -p -r1.21 -r1.21.48.1
--- basic/source/comp/token.cxx	12 Oct 2006 14:28:11 -0000	1.21
+++ basic/source/comp/token.cxx	16 Feb 2007 17:14:15 -0000	1.21.48.1
@@ -130,6 +130,7 @@ static TokenTable aTokTable_Basic [] = {
 	{ IS,		"Is" },
 	{ LET,		"Let" },
 	{ LIB,		"Lib" },
+	{ LIKE,		"Like" },
 	{ LINE,		"Line" },
 	{ LINEINPUT,"Line Input" },
 	{ LOCAL,	"Local" },
Index: basic/source/inc/opcodes.hxx
===================================================================
RCS file: /cvs/script/basic/source/inc/opcodes.hxx,v
retrieving revision 1.11
retrieving revision 1.11.42.3
diff -u -p -u -p -r1.11 -r1.11.42.3
--- basic/source/inc/opcodes.hxx	2 Nov 2006 16:32:24 -0000	1.11
+++ basic/source/inc/opcodes.hxx	2 May 2007 09:45:22 -0000	1.11.42.3
@@ -99,6 +99,7 @@ enum SbiOpcode {
 	_REDIMP_ERASE,		// Copies array to be later used by REDIM PRESERVE before erasing it
 	_INITFOREACH,
 	_VBASET,            // VBA-like Set
+	_ERASE_CLEAR,       // Erase array and clear variable
 	SbOP0_END,
 
 	// Alle Opcodes mit einem Operanden
@@ -132,6 +133,7 @@ enum SbiOpcode {
 	_BASED,          	// TOS wird um BASE erhoeht, BASE davor gepusht (+base)
 	// Typanpassung im Argv
 	_ARGTYP,          	// Letzten Parameter in Argv konvertieren (+Typ)
+	_VBASETCLASS,       // VBA-like Set
 	SbOP1_END,
 
 	// Alle Opcodes mit zwei Operanden
@@ -164,6 +166,7 @@ enum SbiOpcode {
 	_FIND_G,        	// Sucht globale Variable mit Spezialbehandlung wegen _GLOBAL_P
     _DCREATE_REDIMP,	// Objekt-Array redimensionieren (+StringId+StringID)
 	_FIND_CM,        	// Search inside a class module (CM) to enable global search in time
+	_PUBLIC_P, 			//  Module global Variable (persisted between calls)(+StringID+Typ)
 	SbOP2_END
 
 };
Index: basic/source/inc/parser.hxx
===================================================================
RCS file: /cvs/script/basic/source/inc/parser.hxx,v
retrieving revision 1.10
retrieving revision 1.10.42.1
diff -u -p -u -p -r1.10 -r1.10.42.1
--- basic/source/inc/parser.hxx	1 Nov 2006 16:15:58 -0000	1.10
+++ basic/source/inc/parser.hxx	2 May 2007 09:45:22 -0000	1.10.42.1
@@ -94,7 +94,6 @@ public:
 	BOOL		  bText;			// OPTION COMPARE TEXT
 	BOOL          bExplicit; 		// TRUE: OPTION EXPLICIT
 	BOOL          bClassModule;		// TRUE: OPTION ClassModule
-	BOOL          bVBASupportOn;		// TRUE: OPTION VBASupport 1 otherwise default False
 	IfaceVector   aIfaceVector;		// Holds all interfaces implemented by a class module
 	SbxDataType   eDefTypes[26];	// DEFxxx-Datentypen
 
Index: basic/source/inc/runtime.hxx
===================================================================
RCS file: /cvs/script/basic/source/inc/runtime.hxx,v
retrieving revision 1.33
retrieving revision 1.33.42.4
diff -u -p -u -p -r1.33 -r1.33.42.4
--- basic/source/inc/runtime.hxx	2 Nov 2006 16:32:35 -0000	1.33
+++ basic/source/inc/runtime.hxx	2 May 2007 09:44:56 -0000	1.33.42.4
@@ -360,6 +360,7 @@ class SbiRuntime
 	BOOL          bError;           // TRUE: Fehler behandeln
 	BOOL          bInError;         // TRUE: in einem Fehler-Handler
 	BOOL          bBlocked;         // TRUE: blocked by next call level, #i48868
+	BOOL          bVBAEnabled;            
 	USHORT		  nFlags;			// Debugging-Flags
 	SbError		  nError;           // letzter Fehler
 	USHORT		  nOps;				// Opcode-Zaehler
@@ -429,6 +430,8 @@ class SbiRuntime
 	// #115829
 	bool implIsClass( SbxObject* pObj, const String& aClass );
 
+	void StepSETCLASS_impl( UINT32 nOp1, bool bHandleDflt = false );
+
 	// Die nachfolgenden Routinen werden vom Single Stepper
 	// gerufen und implementieren die einzelnen Opcodes
 	void StepNOP(),     StepEXP(),      StepMUL(),      StepDIV();
@@ -447,7 +450,7 @@ class SbiRuntime
 	void StepNOERROR(), StepCHANNEL(),  StepCHANNEL0(),	StepPRINT();
 	void StepPRINTF(),	StepWRITE(),    StepRENAME(),   StepPROMPT();
 	void StepRESTART(), StepEMPTY(),    StepLEAVE();
-	void StepLSET(),	StepRSET(),		StepREDIMP_ERASE();
+	void StepLSET(),	StepRSET(),		StepREDIMP_ERASE(), 	StepERASE_CLEAR();
 	// Alle Opcodes mit einem Operanden
 	void StepLOADNC( UINT32 ),  StepLOADSC( UINT32 ),   StepLOADI( UINT32 );
 	void StepARGN( UINT32 ),	StepBASED( UINT32 ),	StepPAD( UINT32 );
@@ -455,11 +458,11 @@ class SbiRuntime
 	void StepJUMPF( UINT32 ),   StepONJUMP( UINT32 );
 	void StepGOSUB( UINT32 ),   StepRETURN( UINT32 );
 	void StepTESTFOR( UINT32 ), StepCASETO( UINT32 ),   StepERRHDL( UINT32 );
-	void StepRESUME( UINT32 ),  StepSETCLASS( UINT32 ),	StepTESTCLASS( UINT32 ), StepLIB( UINT32 );
+	void StepRESUME( UINT32 ),  StepSETCLASS( UINT32 ),	StepVBASETCLASS( UINT32 ),	StepTESTCLASS( UINT32 ), StepLIB( UINT32 );
 	bool checkClass_Impl( const SbxVariableRef& refVal, const String& aClass, bool bRaiseErrors );
 	void StepCLOSE( UINT32 ),   StepPRCHAR( UINT32 ),   StepARGTYP( UINT32 );
 	// Alle Opcodes mit zwei Operanden
-	void StepRTL( UINT32, UINT32 ),		StepPUBLIC( UINT32, UINT32 );		
+	void StepRTL( UINT32, UINT32 ),		StepPUBLIC( UINT32, UINT32 ),	StepPUBLIC_P( UINT32, UINT32 );		
 	void StepPUBLIC_Impl( UINT32, UINT32, bool bUsedForClassModule );
 	void StepFIND( UINT32, UINT32 ),    StepELEM( UINT32, UINT32 );
 	void StepGLOBAL( UINT32, UINT32 ),  StepLOCAL( UINT32, UINT32 );
@@ -472,6 +475,7 @@ class SbiRuntime
 	void StepDCREATE_REDIMP(UINT32,UINT32), StepDCREATE_IMPL(UINT32,UINT32);
 	void StepFIND_CM( UINT32, UINT32 );
 public:
+	void          SetVBAEnabled( bool bEnabled ) { bVBAEnabled = bEnabled; };            
 	USHORT		GetImageFlag( USHORT n ) const;
 	USHORT		GetBase();
 	xub_StrLen  nLine,nCol1,nCol2;	// aktuelle Zeile, Spaltenbereich
Index: basic/source/inc/scanner.hxx
===================================================================
RCS file: /cvs/script/basic/source/inc/scanner.hxx,v
retrieving revision 1.10
retrieving revision 1.10.176.1
diff -u -p -u -p -r1.10 -r1.10.176.1
--- basic/source/inc/scanner.hxx	29 Sep 2005 18:41:38 -0000	1.10
+++ basic/source/inc/scanner.hxx	2 May 2007 09:45:22 -0000	1.10.176.1
@@ -79,7 +79,8 @@ protected:
 	BOOL   bHash;						// TRUE: # eingelesen
 	BOOL   bError;						// TRUE: Fehler generieren
 	BOOL   bUsedForHilite;				// TRUE: Nutzung fuer Highlighting
-	BOOL   bCompatible; 				// TRUE: OPTION Compatible
+	BOOL   bCompatible; 				// TRUE: OPTION Compatibl
+	BOOL   bVBASupportOn;				// TRUE: OPTION VBASupport 1 otherwise default False
 	BOOL   bPrevLineExtentsComment;		// TRUE: Previous line is comment and ends on "... _"
 
 	void   GenError( SbError );
@@ -91,6 +92,8 @@ public:
 	BOOL  IsHash()					{ return bHash;   }
 	BOOL  IsCompatible()			{ return bCompatible; }
 	void  SetCompatible( bool b )	{ bCompatible = b; }		// #118206
+	BOOL  IsVBASupportOn()			{ return bVBASupportOn; }
+	void  SetVBASupportOn( bool b )	{ bVBASupportOn = b; }
 	BOOL  WhiteSpace()				{ return bSpaces; }
 	short GetErrors()				{ return nErrors; }
 	short GetLine()					{ return nLine;   }
Index: basic/source/runtime/runtime.cxx
===================================================================
RCS file: /cvs/script/basic/source/runtime/runtime.cxx,v
retrieving revision 1.35
retrieving revision 1.35.6.4
diff -u -p -u -p -r1.35 -r1.35.6.4
--- basic/source/runtime/runtime.cxx	29 Jan 2007 15:05:41 -0000	1.35
+++ basic/source/runtime/runtime.cxx	2 May 2007 09:44:22 -0000	1.35.6.4
@@ -153,6 +153,7 @@ SbiRuntime::pStep0 SbiRuntime::aStep0[] 
 	&SbiRuntime::StepREDIMP_ERASE,// Copy array object for REDIMP
 	&SbiRuntime::StepINITFOREACH,// Init for each loop
 	&SbiRuntime::StepVBASET,// vba-like set statement
+	&SbiRuntime::StepERASE_CLEAR,// vba-like set statement
 };
 
 SbiRuntime::pStep1 SbiRuntime::aStep1[] = {	// Alle Opcodes mit einem Operanden
@@ -181,6 +182,7 @@ SbiRuntime::pStep1 SbiRuntime::aStep1[] 
 	&SbiRuntime::StepLIB,  		// Lib fuer Declare-Call (+StringId)
 	&SbiRuntime::StepBASED,	  	// TOS wird um BASE erhoeht, BASE davor gepusht
 	&SbiRuntime::StepARGTYP,	  	// Letzten Parameter in Argv konvertieren (+Typ)
+	&SbiRuntime::StepVBASETCLASS,// vba-like set statement
 };
 
 SbiRuntime::pStep2 SbiRuntime::aStep2[] = {// Alle Opcodes mit zwei Operanden
@@ -209,6 +211,7 @@ SbiRuntime::pStep2 SbiRuntime::aStep2[] 
 	&SbiRuntime::StepFIND_G,    	// Sucht globale Variable mit Spezialbehandlung wegen _GLOBAL_P
 	&SbiRuntime::StepDCREATE_REDIMP, // Objekt-Array redimensionieren (+StringID+StringID)
 	&SbiRuntime::StepFIND_CM,    // Search inside a class module (CM) to enable global search in time
+	&SbiRuntime::StepPUBLIC_P,    // Search inside a class module (CM) to enable global search in time
 };
 
 
@@ -538,6 +541,7 @@ SbiRuntime::SbiRuntime( SbModule* pm, Sb
 #endif
 	pRefSaveList = NULL;
 	pItemStoreList = NULL;
+	bVBAEnabled = isVBAEnabled();
 }
 
 SbiRuntime::~SbiRuntime()
Index: basic/source/runtime/step0.cxx
===================================================================
RCS file: /cvs/script/basic/source/runtime/step0.cxx,v
retrieving revision 1.28
retrieving revision 1.27.42.7
diff -u -p -u -p -r1.28 -r1.27.42.7
--- basic/source/runtime/step0.cxx	26 Apr 2007 08:33:37 -0000	1.28
+++ basic/source/runtime/step0.cxx	2 May 2007 09:45:35 -0000	1.27.42.7
@@ -49,7 +49,11 @@
 #include <sb.hrc>
 #include <basrid.hxx>
 #include "sbunoobj.hxx"
+#include "image.hxx"
 #include <com/sun/star/uno/Any.hxx>
+#include <com/sun/star/util/SearchOptions.hdl>
+#include <vcl/svapp.hxx>
+#include <unotools/textsearch.hxx>
 
 #include <algorithm>
 
@@ -64,7 +68,6 @@ void SbiRuntime::StepArith( SbxOperator 
 	TOSMakeTemp();
 	SbxVariable* p2 = GetTOS();
 
-	bool bVBAInterop =  SbiRuntime::isVBAEnabled(); 
 
 	// This could & should be moved to the MakeTempTOS() method in runtime.cxx
 	// In the code which this is cut'npaste from there is a check for a ref
@@ -74,7 +77,7 @@ void SbiRuntime::StepArith( SbxOperator 
 	// here we alway seem to have a refcount of 1. Also it seems that
 	// MakeTempTOS is called for other operation, so I hold off for now
 	// until I have a better idea
-	if ( bVBAInterop
+	if ( bVBAEnabled
 		&& ( p2->GetType() == SbxOBJECT || p2->GetType() == SbxVARIANT )
 	)
 	{
@@ -110,6 +113,40 @@ void SbiRuntime::StepCompare( SbxOperato
 {
 	SbxVariableRef p1 = PopVar();
 	SbxVariableRef p2 = PopVar();
+
+	// Make sure objects with default params have 
+	// values ( and type ) set as appropriate
+	SbxDataType p1Type = p1->GetType(); 
+	SbxDataType p2Type = p2->GetType(); 
+	if ( p1Type == p2Type )
+	{
+		if ( p1Type == SbxEMPTY )
+		{
+			p1->Broadcast( SBX_HINT_DATAWANTED );
+			p2->Broadcast( SBX_HINT_DATAWANTED );
+		}
+		// if both sides are an object and have default props
+		// then we need to use the default props
+		// we don't need to worry if only one side ( lhs, rhs ) is an 
+		// object ( object side will get coerced to correct type in 
+		// Compare )
+		else if ( p1Type ==  SbxOBJECT )
+		{
+			SbxVariable* pDflt = getDefaultProp( p1 );
+			if ( pDflt )
+			{
+				p1 = pDflt;
+				p1->Broadcast( SBX_HINT_DATAWANTED );
+			}
+			pDflt = getDefaultProp( p2 );
+			if ( pDflt )
+			{
+				p2 = pDflt;
+				p2->Broadcast( SBX_HINT_DATAWANTED );
+			}
+		}
+
+	}
 #ifndef WIN
 	static SbxVariable* pTRUE = NULL;
 	static SbxVariable* pFALSE = NULL;
@@ -166,9 +203,116 @@ void SbiRuntime::StepGT()		{ StepCompare
 void SbiRuntime::StepLE()		{ StepCompare( SbxLE );		}
 void SbiRuntime::StepGE()		{ StepCompare( SbxGE );		}
 
+namespace
+{
+	bool NeedEsc(sal_Unicode cCode)
+	{
+		String sEsc(RTL_CONSTASCII_USTRINGPARAM(".^$+\\|{}()"));
+		return (STRING_NOTFOUND != sEsc.Search(cCode));
+	}
+
+	String VBALikeToRegexp(const String &rIn)
+	{
+		String sResult;
+		const sal_Unicode *start = rIn.GetBuffer();
+		const sal_Unicode *end = start + rIn.Len();
+
+		int seenright = 0;
+
+		sResult.Append('^');
+
+		while (start < end) 
+		{
+			switch (*start)
+			{
+				case '?':
+					sResult.Append('.');
+					start++;
+					break;
+				case '*':
+					sResult.Append(String(RTL_CONSTASCII_USTRINGPARAM(".*")));
+					start++;
+					break;
+				case '#':
+					sResult.Append(String(RTL_CONSTASCII_USTRINGPARAM("[0-9]")));
+					start++;
+					break;
+				case ']':
+					sResult.Append('\\');
+					sResult.Append(*start++);
+					break;
+				case '[':
+					sResult.Append(*start++);
+					seenright = 0;
+					while (start < end && !seenright)
+					{
+						switch (*start)
+						{
+							case '[':
+							case '?':
+							case '*':
+							sResult.Append('\\');
+							sResult.Append(*start);
+								break;
+							case ']':
+							sResult.Append(*start);
+								seenright = 1;
+								break;
+							case '!':
+								sResult.Append('^');
+								break;
+							default:
+							if (NeedEsc(*start))
+									sResult.Append('\\');
+							sResult.Append(*start);
+								break;
+						}
+						start++;
+					}
+					break;
+				default:
+					if (NeedEsc(*start))
+						sResult.Append('\\');
+					sResult.Append(*start++);
+			}
+		}
+
+		sResult.Append('$');
+
+		return sResult;
+	}
+}
+
 void SbiRuntime::StepLIKE()
 {
-	StarBASIC::FatalError( SbERR_NOT_IMPLEMENTED );
+    SbxVariableRef refVar1 = PopVar();
+    SbxVariableRef refVar2 = PopVar();
+
+    String pattern = VBALikeToRegexp(refVar1->GetString());
+    String value = refVar2->GetString();
+
+    com::sun::star::util::SearchOptions aSearchOpt;
+
+    aSearchOpt.algorithmType = com::sun::star::util::SearchAlgorithms_REGEXP;
+
+    aSearchOpt.Locale = Application::GetSettings().GetLocale();
+    aSearchOpt.searchString = pattern;
+
+    int bTextMode(1);
+    bool bCompatibility = ( pINST && pINST->IsCompatibility() );
+    if( bCompatibility )
+        bTextMode = GetImageFlag( SBIMG_COMPARETEXT );
+
+    if( bTextMode )
+        aSearchOpt.transliterateFlags |= com::sun::star::i18n::TransliterationModules_IGNORE_CASE;
+
+    SbxVariable* pRes = new SbxVariable;
+    utl::TextSearch aSearch(aSearchOpt);
+    xub_StrLen nStart=0, nEnd=value.Len();
+    int bRes = aSearch.SearchFrwrd(value, &nStart, &nEnd);
+    pRes->PutBool( bRes != 0 );
+
+    PushVar( pRes );
 }
 
 // TOS und TOS-1 sind beides Objektvariable und enthalten den selben Pointer
@@ -244,14 +388,13 @@ void SbiRuntime::StepPUT()
 		n = refVar->GetFlags();
 		refVar->SetFlag( SBX_WRITE );
 	}
-	bool bVBAInterop =  SbiRuntime::isVBAEnabled(); 
 
 	// if left side arg is an object or variant and right handside isn't 
 	// either an object or a variant then try and see if a default 
 	// property exists.
 	// to use e.g. Range{"A1") = 34
 	// could equate to Range("A1").Value = 34 
-	if ( bVBAInterop )
+	if ( bVBAEnabled )
 	{
 		if ( refVar->GetType() == SbxOBJECT  ) 
 		{
@@ -269,7 +412,7 @@ void SbiRuntime::StepPUT()
 
 	*refVar = *refVal;
 	// lhs is a property who's value is currently null
-	if ( !bVBAInterop || ( bVBAInterop && refVar->GetType() != SbxEMPTY ) )
+	if ( !bVBAEnabled || ( bVBAEnabled && refVar->GetType() != SbxEMPTY ) )
 	// #67607 Uno-Structs kopieren
 		checkUnoStructCopy( refVal, refVar );
 	if( bFlagsChanged )
@@ -402,7 +545,7 @@ void SbiRuntime::StepSET()
 {
 	SbxVariableRef refVal = PopVar();
 	SbxVariableRef refVar = PopVar();
-	StepSET_Impl( refVal, refVar, SbiRuntime::isVBAEnabled() ); // this is really assigment
+	StepSET_Impl( refVal, refVar, bVBAEnabled ); // this is really assigment
 }
 
 void SbiRuntime::StepVBASET()
@@ -525,6 +668,8 @@ void SbiRuntime::DimImpl( SbxVariableRef
 				if( ub < lb )
 					Error( SbERR_OUT_OF_RANGE ), ub = lb;
 				pArray->AddDim32( lb, ub );
+				if ( lb != ub )
+					pArray->setHasFixedSize( true );
 			}
 		}
 		else
@@ -693,27 +838,51 @@ void SbiRuntime::StepREDIMP_ERASE()
 		refVar->SetType( SbxEMPTY );
 }
 
+void lcl_clearImpl( SbxVariableRef& refVar, SbxDataType& eType )
+{
+	USHORT nSavFlags = refVar->GetFlags();
+	refVar->ResetFlag( SBX_FIXED );
+	refVar->SetType( SbxDataType(eType & 0x0FFF) );
+	refVar->SetFlags( nSavFlags );
+	refVar->Clear();
+}
 
-// Variable loeschen
-// TOS = Variable
-
-void SbiRuntime::StepERASE()
+void lcl_eraseImpl( SbxVariableRef& refVar, bool bVBAEnabled )
 {
-	SbxVariableRef refVar = PopVar();
 	SbxDataType eType = refVar->GetType();
 	if( eType & SbxARRAY )
 	{
+		if ( bVBAEnabled )
+		{
+			SbxBase* pElemObj = refVar->GetObject();
+			SbxDimArray* pDimArray = PTR_CAST(SbxDimArray,pElemObj);
+			bool bClearValues = true;
+			if( pDimArray )
+			{
+				if ( pDimArray->hasFixedSize() )
+				{
+					// Clear all Value(s)
+					pDimArray->SbxArray::Clear();
+					bClearValues = false;
+				}
+				else
+					pDimArray->Clear(); // clear Dims
+			}
+			if ( bClearValues )
+			{
+				SbxArray* pArray = PTR_CAST(SbxArray,pElemObj);
+				if ( pArray )
+					pArray->Clear();
+			}				
+		}
+		else
 		// AB 2.4.1996
 		// Arrays haben bei Erase nach VB ein recht komplexes Verhalten. Hier
 		// werden zunaechst nur die Typ-Probleme bei REDIM (#26295) beseitigt:
 		// Typ hart auf den Array-Typ setzen, da eine Variable mit Array
 		// SbxOBJECT ist. Bei REDIM entsteht dann ein SbxOBJECT-Array und
 		// der ursruengliche Typ geht verloren -> Laufzeitfehler
-		USHORT nSavFlags = refVar->GetFlags();
-		refVar->ResetFlag( SBX_FIXED );
-		refVar->SetType( SbxDataType(eType & 0x0FFF) );
-		refVar->SetFlags( nSavFlags );
-		refVar->Clear();
+			lcl_clearImpl( refVar, eType );
 	}
 	else
 	if( refVar->IsFixed() )
@@ -722,6 +891,23 @@ void SbiRuntime::StepERASE()
 		refVar->SetType( SbxEMPTY );
 }
 
+// Variable loeschen
+// TOS = Variable
+
+void SbiRuntime::StepERASE()
+{
+	SbxVariableRef refVar = PopVar();
+	lcl_eraseImpl( refVar, bVBAEnabled );
+}
+
+void SbiRuntime::StepERASE_CLEAR()
+{
+	SbxVariableRef refVar = PopVar();
+	lcl_eraseImpl( refVar, bVBAEnabled );
+	SbxDataType eType = refVar->GetType();
+	lcl_clearImpl( refVar, eType );
+}
+
 // Einrichten eines Argvs
 // nOp1 bleibt so -> 1. Element ist Returnwert
 
Index: basic/source/runtime/step1.cxx
===================================================================
RCS file: /cvs/script/basic/source/runtime/step1.cxx,v
retrieving revision 1.16
retrieving revision 1.16.42.1
diff -u -p -u -p -r1.16 -r1.16.42.1
--- basic/source/runtime/step1.cxx	3 Nov 2006 15:10:48 -0000	1.16
+++ basic/source/runtime/step1.cxx	27 Feb 2007 18:29:10 -0000	1.16.42.1
@@ -44,6 +44,9 @@
 #include "image.hxx"
 #include "sbunoobj.hxx"
 
+bool checkUnoObjectType( SbUnoObject* refVal, 
+	const String& aClass );
+
 // Laden einer numerischen Konstanten (+ID)
 
 void SbiRuntime::StepLOADNC( UINT32 nOp1 )
@@ -476,9 +479,18 @@ bool SbiRuntime::checkClass_Impl( const 
 		{
 			if( !implIsClass( pObj, aClass ) )
 			{
-				if( bRaiseErrors )
-					Error( SbERR_INVALID_USAGE_OBJECT );
-				bOk = false;
+				if ( bVBAEnabled && pObj->IsA( TYPE(SbUnoObject) ) )
+				{
+					SbUnoObject* pUnoObj = PTR_CAST(SbUnoObject,pObj);
+					bOk = checkUnoObjectType( pUnoObj, aClass );
+				}
+				else
+					bOk = false;
+				if ( !bOk )
+				{
+					if( bRaiseErrors )
+						Error( SbERR_INVALID_USAGE_OBJECT );
+				}
 			}
 			else
 			{
@@ -490,14 +502,17 @@ bool SbiRuntime::checkClass_Impl( const 
 	}
 	else
 	{
-		if( bRaiseErrors )
-			Error( SbERR_NEEDS_OBJECT );
-		bOk = false;
+		if ( !bVBAEnabled )
+		{
+			if( bRaiseErrors )
+				Error( SbERR_NEEDS_OBJECT );
+			bOk = false;
+		}
 	}
 	return bOk;
 }
 
-void SbiRuntime::StepSETCLASS( UINT32 nOp1 )
+void SbiRuntime::StepSETCLASS_impl( UINT32 nOp1, bool bHandleDflt )
 {
 	SbxVariableRef refVal = PopVar();
 	SbxVariableRef refVar = PopVar();
@@ -505,7 +520,17 @@ void SbiRuntime::StepSETCLASS( UINT32 nO
 
 	bool bOk = checkClass_Impl( refVal, aClass, true );
 	if( bOk )
-		StepSET_Impl( refVal, refVar );
+		StepSET_Impl( refVal, refVar, bHandleDflt ); // don't do handle dflt prop for a "proper" set
+}
+
+void SbiRuntime::StepVBASETCLASS( UINT32 nOp1 )
+{
+	StepSETCLASS_impl( nOp1, false );
+}
+
+void SbiRuntime::StepSETCLASS( UINT32 nOp1 )
+{
+	StepSETCLASS_impl( nOp1, true );
 }
 
 void SbiRuntime::StepTESTCLASS( UINT32 nOp1 )
Index: basic/source/runtime/step2.cxx
===================================================================
RCS file: /cvs/script/basic/source/runtime/step2.cxx,v
retrieving revision 1.29
retrieving revision 1.27.42.5
diff -u -p -u -p -r1.29 -r1.27.42.5
--- basic/source/runtime/step2.cxx	27 Apr 2007 09:16:12 -0000	1.29
+++ basic/source/runtime/step2.cxx	2 May 2007 09:44:56 -0000	1.27.42.5
@@ -54,6 +54,8 @@
 using namespace com::sun::star::container;
 using namespace com::sun::star::lang;
 
+SbxVariable* getVBAConstant( const String& rName );
+
 const static String aThisComponent( RTL_CONSTASCII_USTRINGPARAM("ThisComponent") );
 const static String aVBAHook( RTL_CONSTASCII_USTRINGPARAM( "VBAGlobals" ) );
 //  i#i68894# 
@@ -117,14 +117,6 @@
 SbxVariable* SbiRuntime::FindElement
 	( SbxObject* pObj, UINT32 nOp1, UINT32 nOp2, SbError nNotFound, BOOL bLocal )
 {
-	bool bIsVBAInterOp = SbiRuntime::isVBAEnabled(); 
-	if( bIsVBAInterOp )
-	{
-		StarBASIC* pMSOMacroRuntimeLib = GetSbData()->pMSOMacroRuntimLib;
-		if( pMSOMacroRuntimeLib != NULL )
-			pMSOMacroRuntimeLib->ResetFlag( SBX_EXTSEARCH );
-	}
-
 	SbxVariable* pElem = NULL;
 	if( !pObj )
 	{
@@ -136,6 +128,30 @@
 		BOOL bFatalError = FALSE;
 		SbxDataType t = (SbxDataType) nOp2;
 		String aName( pImg->GetString( static_cast<short>( nOp1 & 0x7FFF ) ) );
+		bool bIsVBAInterOp = SbiRuntime::isVBAEnabled(); 
+		if( bIsVBAInterOp )
+		{
+			StarBASIC* pMSOMacroRuntimeLib = GetSbData()->pMSOMacroRuntimLib;
+			if( pMSOMacroRuntimeLib != NULL )
+				pMSOMacroRuntimeLib->ResetFlag( SBX_EXTSEARCH );
+		}
+		// Hacky capture of Evaluate [] syntax
+		// this should be tackled I feel at the pcode level
+		if ( bIsVBAInterOp && aName.Search('[') == 0 )
+		{
+			// emulate pcode here
+			StepARGC();
+			// psuedo StepLOADSC
+			String sArg = aName.Copy( 1, aName.Len() - 2 );
+			SbxVariable* p = new SbxVariable;
+			p->PutString( sArg );
+			PushVar( p );
+			//
+			StepARGV();
+			nOp1 = nOp1 | 0x8000; // indicate params are present
+			aName = String::CreateFromAscii("Evaluate");
+		}
+
 		if( bLocal )
 			pElem = refLocals->Find( aName, SbxCLASS_DONTCARE );
 		if( !pElem )
@@ -156,25 +174,24 @@ SbxVariable* SbiRuntime::FindElement
 
 				// i#i68894# if VBAInterOp favour searching vba globals 
 				// over searching for uno classess
-				if ( bIsVBAInterOp )
+				if ( bVBAEnabled )
 				{
 					// Try Find in VBA symbols space
 					pElem = VBAFind( aName, SbxCLASS_DONTCARE );
 					if ( pElem )
 						bSetName = false; // don't overwrite uno name
+					else
+						pElem = getVBAConstant( aName );
 				}
-				else
-				{				
-					// #72382 VORSICHT! Liefert jetzt wegen unbekannten
-					// Modulen IMMER ein Ergebnis!
-					SbxVariable* pUnoClass = findUnoClass( aName );
-					if( pUnoClass )
-					{
-						pElem = new SbxVariable( t );
-						SbxValues aRes( SbxOBJECT );
-						aRes.pObj = pUnoClass;
-						pElem->SbxVariable::Put( aRes );
-					}
+				// #72382 VORSICHT! Liefert jetzt wegen unbekannten
+				// Modulen IMMER ein Ergebnis!
+				SbxVariable* pUnoClass = findUnoClass( aName );
+				if( pUnoClass )
+				{
+					pElem = new SbxVariable( t );
+					SbxValues aRes( SbxOBJECT );
+					aRes.pObj = pUnoClass;
+					pElem->SbxVariable::Put( aRes );
 				}
 
 				// #62939 Wenn eine Uno-Klasse gefunden wurde, muss
@@ -523,7 +540,7 @@ SbxVariable* SbiRuntime::CheckArray( Sbx
                     {
                         Reference< XInterface > x = *(Reference< XInterface >*)aAny.getValue();
                         Reference< XIndexAccess > xIndexAccess( x, UNO_QUERY );
-                        if ( !SbiRuntime::isVBAEnabled() )
+                        if ( !bVBAEnabled )
                         {
                             // Haben wir Index-Access?
                             if( xIndexAccess.is() )
@@ -1121,6 +1138,14 @@ void SbiRuntime::StepPUBLIC( UINT32 nOp1
 	StepPUBLIC_Impl( nOp1, nOp2, false );
 }
 
+void SbiRuntime::StepPUBLIC_P( UINT32 nOp1, UINT32 nOp2 )
+{
+    // Creates module variable that isn't reinitialised when
+    // between invocations ( for VBASupport & document basic only )
+    if( pMod->pImage->bFirstInit )
+	StepPUBLIC( nOp1, nOp2 );
+}
+
 // Einrichten einer globalen Variablen (+StringID+Typ)
 
 void SbiRuntime::StepGLOBAL( UINT32 nOp1, UINT32 nOp2 )
Index: basic/source/sbx/sbxarray.cxx
===================================================================
RCS file: /cvs/script/basic/source/sbx/sbxarray.cxx,v
retrieving revision 1.6
retrieving revision 1.6.48.3
diff -u -p -u -p -r1.6 -r1.6.48.3
--- basic/source/sbx/sbxarray.cxx	12 Oct 2006 14:31:56 -0000	1.6
+++ basic/source/sbx/sbxarray.cxx	27 Apr 2007 14:32:16 -0000	1.6.48.3
@@ -40,6 +40,7 @@
 #include <tools/stream.hxx>
 #endif
 #include <basic/sbx.hxx>
+#include "runtime.hxx"
 #include <vector>
 using namespace std;
 
@@ -593,7 +594,7 @@ void SbxArray::PutDirect( SbxVariable* p
 //
 //////////////////////////////////////////////////////////////////////////
 
-SbxDimArray::SbxDimArray( SbxDataType t ) : SbxArray( t )
+SbxDimArray::SbxDimArray( SbxDataType t ) : SbxArray( t ), mbHasFixedSize( false )
 {
 	pFirst = pLast = NULL;
 	nDim = 0;
@@ -618,6 +619,7 @@ SbxDimArray& SbxDimArray::operator=( con
 			AddDim32( p->nLbound, p->nUbound );
 			p = p->pNext;
 		}
+		this->mbHasFixedSize = rArray.mbHasFixedSize;
 	}
 	return *this;
 }
@@ -793,7 +795,7 @@ void SbxDimArray::Put32( SbxVariable* p,
 
 UINT32 SbxDimArray::Offset32( SbxArray* pPar )
 {
-	if( nDim == 0 || !pPar )
+	if( nDim == 0 || !pPar || ( ( nDim != ( pPar->Count() - 1 ) ) && SbiRuntime::isVBAEnabled() ) )
 	{
 		SetError( SbxERR_BOUNDS ); return 0;
 	}
Index: basic/source/sbx/sbxvalue.cxx
===================================================================
RCS file: /cvs/script/basic/source/sbx/sbxvalue.cxx,v
retrieving revision 1.8
retrieving revision 1.8.48.1
diff -u -p -u -p -r1.8 -r1.8.48.1
--- basic/source/sbx/sbxvalue.cxx	12 Oct 2006 14:34:49 -0000	1.8
+++ basic/source/sbx/sbxvalue.cxx	16 Feb 2007 17:08:55 -0000	1.8.48.1
@@ -64,7 +64,7 @@
 #include "sbx.hxx"
 #include "sbxconv.hxx"
 #include <math.h>
-
+#include "runtime.hxx"
 // AB 29.10.99 Unicode
 #ifndef _USE_NO_NAMESPACE
 using namespace rtl;
@@ -1125,6 +1125,8 @@ BOOL SbxValue::Convert( SbxDataType eTo 
 
 BOOL SbxValue::Compute( SbxOperator eOp, const SbxValue& rOp )
 {
+	bool bVBAInterop =  SbiRuntime::isVBAEnabled(); 
+
 	SbxDataType eThisType = GetType();
 	SbxDataType eOpType = rOp.GetType();
 	SbxError eOld = GetError();
@@ -1138,14 +1140,16 @@ BOOL SbxValue::Compute( SbxOperator eOp,
 	else if( eThisType == SbxNULL || eOpType == SbxNULL )
 		SetType( SbxNULL );
 	// Sonderregel 2: Ist ein Operand Empty, ist das Ergebnis der 2. Operand
-	else if( eThisType == SbxEMPTY )
+	else if( eThisType == SbxEMPTY 
+	&& !bVBAInterop 
+	)
 		*this = rOp;
 	// 13.2.96: Nicht schon vor Get auf SbxEMPTY pruefen
 	else
 	{
 		SbxValues aL, aR;
 		bool bDecimal = false;
-		if( eThisType == SbxSTRING || eOp == SbxCAT )
+		if( eThisType == SbxSTRING || eOp == SbxCAT || ( bVBAInterop && ( eOpType == SbxSTRING ) && (  eOp == SbxPLUS ) ) )
 		{
 			if( eOp == SbxCAT || eOp == SbxPLUS )
 			{
@@ -1203,7 +1207,10 @@ BOOL SbxValue::Compute( SbxOperator eOp,
 			if( rOp.Get( aR ) )
 			{
 				if( rOp.GetType() == SbxEMPTY )
-					goto Lbl_OpIsEmpty;
+				{
+					if ( !bVBAInterop || ( bVBAInterop && ( eOp != SbxNOT  ) ) )
+						goto Lbl_OpIsEmpty;
+				}
 				if( Get( aL ) ) switch( eOp )
 				{
 					case SbxIDIV:
@@ -1392,7 +1399,10 @@ BOOL SbxValue::Compute( SbxOperator eOp,
 			if( rOp.Get( aR ) )
 			{
 				if( rOp.GetType() == SbxEMPTY )
-					goto Lbl_OpIsEmpty;
+				{
+					if ( !bVBAInterop || ( bVBAInterop && ( eOp != SbxNEG ) ) )
+						goto Lbl_OpIsEmpty;
+				}
 				if( Get( aL ) )
 				{
 					switch( eOp )
@@ -1442,6 +1452,8 @@ Lbl_OpIsEmpty:
 
 BOOL SbxValue::Compare( SbxOperator eOp, const SbxValue& rOp ) const
 {
+	bool bVBAInterop =  SbiRuntime::isVBAEnabled(); 
+
 	BOOL bRes = FALSE;
 	SbxError eOld = GetError();
 	if( eOld != SbxERR_OK )
@@ -1458,10 +1470,13 @@ BOOL SbxValue::Compare( SbxOperator eOp,
 	// Sonderregel 2: Wenn beide Variant sind und einer ist numerisch,
 	// und der andere ein String, ist num < str
 	else if( !IsFixed() && !rOp.IsFixed()
-	 && ( rOp.GetType() == SbxSTRING && GetType() != SbxSTRING && IsNumeric() ) )
+	 && ( rOp.GetType() == SbxSTRING && GetType() != SbxSTRING && IsNumeric() ) && !bVBAInterop 
+	)
 		bRes = BOOL( eOp == SbxLT || eOp == SbxLE || eOp == SbxNE );
 	else if( !IsFixed() && !rOp.IsFixed()
-	 && ( GetType() == SbxSTRING && rOp.GetType() != SbxSTRING && rOp.IsNumeric() ) )
+	 && ( GetType() == SbxSTRING && rOp.GetType() != SbxSTRING && rOp.IsNumeric() ) 
+&& !bVBAInterop 
+	)
 		bRes = BOOL( eOp == SbxGT || eOp == SbxGE || eOp == SbxNE );
 	else
 	{
Index: config_office/configure.in
===================================================================
RCS file: /cvs/tools/config_office/configure.in,v
retrieving revision 1.201
retrieving revision 1.201.2.1
diff -u -p -u -p -r1.201 -r1.201.2.1
--- config_office/configure.in	25 Apr 2007 15:53:53 -0000	1.201
+++ config_office/configure.in	3 May 2007 11:09:38 -0000	1.201.2.1
@@ -41,20 +41,21 @@ AC_ARG_ENABLE(lockdown,
 [  --enable-lockdown       Enables the gconf integration work in OOo
 ],,)
 AC_ARG_ENABLE(vba,
-[  --enable-vba           Enables the vba compatibility feature
+[  --disable-vba           disables the vba compatibility feature
 ],,)
 AC_ARG_WITH(vba-package-format,
 [  --with-vba-package-format   specify package format for vba compatibility api.
-                          Default "builtin" means the api component and 
+                          Specifying  "builtin" means the api component and 
                           associated type library are  part of the installation set.
-                          Specifying "extsn" creates an uno extension that is
+                          Specifying "extn" creates an uno extension that is
                           part of the installation set ( located in the program 
                           directory ) that MUST be optionly registered using
                           either the unopkg executeable or the extension manager
                           gui.
-                          
-                          Usage: --with-package-format="builtin" or
-                                 --with-package-format="extsn"
+                         
+                          Note: "extn" is the defualt. 
+                          Usage: --with-vba-package-format="builtin" or
+                                 --with-vba-package-format="extn"
 ],,)              
 AC_ARG_ENABLE(pch,
 [  --enable-pch            Enables the use of precompiledr C/C++ header files
@@ -1605,13 +1606,13 @@ fi
 dnl ===================================================================
 dnl Check if we are to enable vba macro interoperability feature
 dnl ===================================================================
-AC_MSG_CHECKING([whether to enable vba feature])
-if test -n "$enable_vba" && test "$enable_vba" = "yes"; then
+AC_MSG_CHECKING([whether to disable vba feature])
+if test -n "$enable_vba" && test "$enable_vba" = "no"; then
    AC_MSG_RESULT([yes])
-   ENABLE_VBA=YES
-else
    ENABLE_VBA=NO
+else
    AC_MSG_RESULT([no])
+   ENABLE_VBA=YES
 fi
 AC_SUBST(ENABLE_VBA)
 
@@ -1630,11 +1631,14 @@ if test "$ENABLE_VBA" = "YES"; then
       fi
  
    else
-      VBA_EXTENSION=NO
-      AC_MSG_RESULT([build into installset])
+      VBA_EXTENSION=YES
+      AC_MSG_RESULT([defaulting to build as uno extension])
    fi
-   AC_SUBST(VBA_EXTENSION)
+else
+      VBA_EXTENSION=NO
 fi
+AC_SUBST(VBA_EXTENSION)
+
 dnl ===================================================================
 dnl Check the whether vba need to be delivered as an uno package or part
 dnl of the install
Index: sc/util/makefile.mk
===================================================================
RCS file: /cvs/sc/sc/util/makefile.mk,v
retrieving revision 1.39
retrieving revision 1.39.2.1
diff -u -p -u -p -r1.39 -r1.39.2.1
--- sc/util/makefile.mk	25 Apr 2007 16:15:20 -0000	1.39
+++ sc/util/makefile.mk	3 May 2007 09:00:47 -0000	1.39.2.1
@@ -278,6 +278,7 @@ DEF9NAME=$(SHL9TARGET)
 
 SHL9STDLIBS= \
 		$(CPPUHELPERLIB) \
+		$(VCLLIB) \
 		$(CPPULIB) \
 		$(COMPHELPERLIB) \
 		$(SVLIB) \
@@ -294,6 +295,12 @@ SHL9STDLIBS= \
 SHL9DEPN=$(SHL1TARGETN) $(SHL8TARGETN)
 SHL9LIBS=$(SLB)$/$(TARGET_VBA).lib
 
+.IF "$(GUI)"=="UNX" || "$(GUI)"=="MAC"
+    LIBCOMPNAME=$(LOCAL_COMMON_OUT)$/lib/lib$(SHL9TARGET)$(DLLPOST)
+.ELSE
+    LIBCOMPNAME=$(COMMONBIN)$/$(SHL9TARGET)$(DLLPOST)
+.ENDIF
+
 .ENDIF
  
 
Index: svx/source/msfilter/svxmsbas.cxx
===================================================================
RCS file: /cvs/graphics/svx/source/msfilter/svxmsbas.cxx,v
retrieving revision 1.20
retrieving revision 1.20.4.1
diff -u -p -u -p -r1.20 -r1.20.4.1
--- svx/source/msfilter/svxmsbas.cxx	25 Apr 2007 16:18:00 -0000	1.20
+++ svx/source/msfilter/svxmsbas.cxx	2 May 2007 09:16:56 -0000	1.20.4.1
@@ -368,8 +368,14 @@ BOOL SvxImportMSVBasic::ImportCode_Impl(
                         break;
                 }
 				static ::rtl::OUString sVBAOption( RTL_CONSTASCII_USTRINGPARAM( "Option VBASupport 1\n" ) ); 
+				static ::rtl::OUString sClassOption( RTL_CONSTASCII_USTRINGPARAM( "Option ClassModule\n" ) ); 
 				if ( !bAsComment )
+				{
 					modeTypeComment = modeTypeComment + sVBAOption;
+					if ( mType == Class )
+						modeTypeComment = modeTypeComment + sClassOption;
+
+				}
 
 				String sModule(sBasicModule); //#i52606# no need to split Macros in 64KB blocks any more!
 				String sTemp;
Index: scp2/source/ooo/file_ooo.scp
===================================================================
RCS file: /cvs/installation/scp2/source/ooo/file_ooo.scp,v
retrieving revision 1.188
retrieving revision 1.188.2.1
diff -u -p -u -p -r1.188 -r1.188.2.1
--- scp2/source/ooo/file_ooo.scp	25 Apr 2007 16:18:52 -0000	1.188
+++ scp2/source/ooo/file_ooo.scp	3 May 2007 11:09:39 -0000	1.188.2.1
@@ -1830,6 +1830,13 @@ File gid_File_Rdb_TypesVba
     Styles = (PACKED, OVERWRITE, PATCH);
     Name = "oovbaapi.rdb";
 End
+#else
+File gid_File_ExtnVba
+    TXT_FILE_BODY;
+    Dir = gid_Dir_Program;
+    Styles = (PACKED, OVERWRITE, PATCH);
+    Name = "vbaapi.oxt";
+End
 #endif
 #endif
 
