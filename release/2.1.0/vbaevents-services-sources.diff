--- /dev/null	2005-06-05 14:44:09.000000000 +0100
+++ scripting/source/vbaevents/makefile.mk	2005-09-14 10:02:37.927118445 +0100
@@ -0,0 +1,50 @@
+PRJ=..$/..
+
+PRJNAME=
+TARGET=vbaevents
+.IF "$(ENABLE_VBA)"!="YES"
+dummy:
+        @echo "not building vbaevents..."
+.ENDIF
+
+NO_BSYMBOLIC=	TRUE
+ENABLE_EXCEPTIONS=TRUE
+COMP1TYPELIST=$(TARGET)
+COMPRDB=$(SOLARBINDIR)$/types.rdb
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :  settings.mk
+.INCLUDE :  sv.mk
+DLLPRE =
+
+# ------------------------------------------------------------------
+
+#.INCLUDE :  ..$/cppumaker.mk
+
+SLOFILES= \
+		$(SLO)$/service.obj \
+		$(SLO)$/eventhelper.obj
+
+SHL1TARGET= $(TARGET)$(UPD)$(DLLPOSTFIX).uno
+SHL1IMPLIB=     i$(TARGET)
+                                                                                
+SHL1VERSIONMAP=$(TARGET).map
+SHL1DEF=$(MISC)$/$(SHL1TARGET).def
+DEF1NAME=$(SHL1TARGET)
+                                                                                
+SHL1STDLIBS= \
+                $(CPPUHELPERLIB) \
+		$(BASICLIB) \
+		$(COMPHELPERLIB) \
+		$(SFXLIB) \
+                $(CPPULIB) \
+                $(TOOLSLIB) \
+                $(SALLIB)
+                                                                                
+SHL1DEPN=
+SHL1LIBS=$(SLB)$/$(TARGET).lib
+
+# --- Targets ------------------------------------------------------
+
+.INCLUDE :	target.mk
--- /dev/null	2005-06-05 14:44:09.000000000 +0100
+++ scripting/source/vbaevents/service.cxx	2005-09-14 10:02:01.344708779 +0100
@@ -0,0 +1,99 @@
+#include "cppuhelper/implementationentry.hxx"
+#include "com/sun/star/lang/XMultiServiceFactory.hpp"
+#include "com/sun/star/registry/XRegistryKey.hpp"
+
+// =============================================================================
+// component exports
+// =============================================================================
+using namespace ::com::sun::star;
+using namespace ::com::sun::star::uno;
+
+namespace evtlstner
+{
+    // =============================================================================
+    // component operations
+    // =============================================================================
+
+    uno::Reference< XInterface > SAL_CALL create(
+        Reference< XComponentContext > const & xContext )
+        SAL_THROW( () );
+
+    // -----------------------------------------------------------------------------
+
+    ::rtl::OUString SAL_CALL getImplementationName();
+
+    Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames();
+
+    Reference<XInterface> SAL_CALL create(
+        Sequence<Any> const &, Reference<XComponentContext> const & );
+} // end evtlstner
+
+namespace ooevtdescgen
+{
+    // =============================================================================
+    // component operations
+    // =============================================================================
+
+    uno::Reference< XInterface > SAL_CALL create(
+        Reference< XComponentContext > const & xContext )
+        SAL_THROW( () );
+
+    // -----------------------------------------------------------------------------
+
+    ::rtl::OUString SAL_CALL getImplementationName();
+
+    Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames();
+
+    Reference<XInterface> SAL_CALL create(
+        Sequence<Any> const &, Reference<XComponentContext> const & );
+} // end ooevtdescgen
+
+
+
+    // =============================================================================
+
+    const ::cppu::ImplementationEntry s_component_entries [] =
+    {
+        {
+            ::evtlstner::create, ::evtlstner::getImplementationName,
+            ::evtlstner::getSupportedServiceNames, 
+            ::cppu::createSingleComponentFactory,
+            0, 0
+        },
+        {
+            ::ooevtdescgen::create, ::ooevtdescgen::getImplementationName,
+            ::ooevtdescgen::getSupportedServiceNames, 
+            ::cppu::createSingleComponentFactory,
+            0, 0
+        },
+        { 0, 0, 0, 0, 0, 0 }
+    };
+
+extern "C"
+{
+    void SAL_CALL component_getImplementationEnvironment( 
+        const sal_Char ** ppEnvTypeName, uno_Environment ** ppEnv )
+    {
+        OSL_TRACE("In component_getImplementationEnv");
+        *ppEnvTypeName = CPPU_CURRENT_LANGUAGE_BINDING_NAME;
+    }
+
+    sal_Bool SAL_CALL component_writeInfo( 
+        lang::XMultiServiceFactory * pServiceManager, registry::XRegistryKey * pRegistryKey )
+    {
+        OSL_TRACE("In component_writeInfo");
+        if ( ::cppu::component_writeInfoHelper(
+            pServiceManager, pRegistryKey, s_component_entries ) )
+            return sal_True;
+        return sal_False;
+    }
+
+    void * SAL_CALL component_getFactory( 
+        const sal_Char * pImplName, lang::XMultiServiceFactory * pServiceManager,
+        registry::XRegistryKey * pRegistryKey )
+    {
+        OSL_TRACE("In component_getFactory");
+        return ::cppu::component_getFactoryHelper( 
+            pImplName, pServiceManager, pRegistryKey, s_component_entries );
+    }
+}
--- /dev/null	2005-06-05 14:44:09.000000000 +0100
+++ scripting/source/vbaevents/vbaevents.map	2005-09-14 10:02:01.346708419 +0100
@@ -0,0 +1,10 @@
+OOO_1.1 {
+	global:
+		component_getDescriptionFunc;
+		component_getImplementationEnvironment;
+		component_getFactory;
+		component_writeInfo;
+
+	local:
+		*;
+};
--- /dev/null	2005-06-05 14:44:09.000000000 +0100
+++ scripting/source/vbaevents/vbaevents.xml	2005-09-14 10:02:01.346708419 +0100
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE module-description PUBLIC "-//StarOffice//DTD ComponentDescription 1.0//EN" "module-description.dtd">
+<module-description xmlns:xlink="http://www.w3.org/1999/xlink">
+
+    <module-name>vbaevents</module-name>
+    
+    <component-description>
+        <author>Noel Power </author>
+        <name>org.openoffice.vba.EventListener</name>
+        <description>Event listener to handle ooo events and to translate them to calls to basic macros ala Button_Click etc.</description>
+        <loader-name>com.sun.star.loader.SharedLibrary</loader-name>
+        <language>c++</language>
+        <status value="drafts"/>
+        <supported-service>org.openoffice.vba.EventListener</supported-service>
+        <type>com.sun.star.uno.XComponentContext</type>        
+    </component-description>
+    
+    <project-build-dependency>cppuhelper</project-build-dependency>
+    <project-build-dependency>cppu</project-build-dependency>
+    <project-build-dependency>sal</project-build-dependency>
+
+    <runtime-module-dependency>cppuhelper3$(COM)</runtime-module-dependency>
+    <runtime-module-dependency>cppu3</runtime-module-dependency>
+    <runtime-module-dependency>sal3</runtime-module-dependency>
+    
+</module-description>
--- /dev/null	2006-03-10 11:01:46.108557750 +0000
+++ scripting/source/vbaevents/eventhelper.cxx	2006-03-09 19:32:08.000000000 +0000
@@ -0,0 +1,1005 @@
+#include <comphelper/processfactory.hxx>
+#include <comphelper/uno3.hxx>
+#include <comphelper/proparrhlp.hxx>
+#include <comphelper/propertycontainer.hxx>
+
+#include <org/openoffice/vba/XVBAToOOEventDescGen.hpp>
+
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/beans/XIntrospection.hpp>
+#include <com/sun/star/beans/PropertyAttribute.hpp>
+
+#include <com/sun/star/lang/XMultiComponentFactory.hpp>
+#include <com/sun/star/lang/XServiceName.hpp>
+#include <com/sun/star/lang/XServiceInfo.hpp>
+#include <com/sun/star/lang/XInitialization.hpp>
+
+#include <com/sun/star/frame/XModel.hpp>
+
+#include <com/sun/star/script/XLibraryContainer.hpp>
+#include <com/sun/star/script/ScriptEventDescriptor.hpp>
+
+#include <com/sun/star/drawing/XControlShape.hpp>
+
+#include <com/sun/star/awt/XControl.hpp>
+#include <com/sun/star/awt/KeyEvent.hpp>
+#include <com/sun/star/awt/MouseEvent.hpp>
+
+#include <MSForms/ReturnInteger.hpp>
+
+#include <sfx2/objsh.hxx>
+#include <basic/sbstar.hxx>
+#include <basic/basmgr.hxx>
+#include <basic/sbmeth.hxx>
+#include <basic/sbmod.hxx>
+#include <basic/sbx.hxx>
+
+
+
+
+// for debug
+#include <comphelper/anytostring.hxx>
+
+
+#include <com/sun/star/lang/XMultiComponentFactory.hpp>
+#include <com/sun/star/script/XScriptListener.hpp>
+#include <cppuhelper/implbase1.hxx>
+#include <cppuhelper/implbase2.hxx>
+
+#include <set>
+#include <list>
+#include <hash_map>
+
+using namespace ::com::sun::star;
+using namespace ::com::sun::star::script;
+using namespace ::com::sun::star::uno;
+using namespace ::org::openoffice::vba;
+
+
+// Some constants 
+const static rtl::OUString DELIM = rtl::OUString::createFromAscii( "::" );
+const static sal_Int32 DELIMLEN = DELIM.getLength();
+
+// Helper Methods
+
+// TODO this method now appears/is-defined in at least three places
+// svx/source/forms/fmtools.cxx extensions/source/propctrlr/formcontroller.cxx
+// and here. We must do better than that
+Sequence< ::rtl::OUString> getEventMethods(const Type& type)
+{
+    typelib_InterfaceTypeDescription *pType=0;
+    type.getDescription( (typelib_TypeDescription**)&pType);
+
+    if(!pType)
+        return Sequence< ::rtl::OUString>();
+    
+    Sequence< ::rtl::OUString> aNames(pType->nMembers);
+    ::rtl::OUString* pNames = aNames.getArray();
+    for(sal_Int32 i=0;i<pType->nMembers;i++,++pNames)
+    {
+        // the decription reference
+        typelib_TypeDescriptionReference* pMemberDescriptionReference = pType->ppMembers[i];
+        // the description for the reference
+        typelib_TypeDescription* pMemberDescription = NULL;
+        typelib_typedescriptionreference_getDescription(&pMemberDescription, pMemberDescriptionReference);
+        if (pMemberDescription)
+        {
+            typelib_InterfaceMemberTypeDescription* pRealMemberDescription =
+            reinterpret_cast<typelib_InterfaceMemberTypeDescription*>(pMemberDescription);
+            *pNames = pRealMemberDescription->pMemberName;
+        }
+    }
+    typelib_typedescription_release( (typelib_TypeDescription *)pType );
+    return aNames;
+}
+
+// for debug only ( conditionalize out? ) 
+void dumpListeners( const Reference< beans::XIntrospection >& xIntrospection, const Reference<XInterface>& xIfc)
+{
+    Reference< beans::XIntrospectionAccess > xIntrospectionAccess;
+    if ( xIntrospection.is() )
+    {
+        xIntrospectionAccess = xIntrospection->inspect( 
+            makeAny( xIfc ) );
+        Sequence< Type > aControlListeners = 
+            xIntrospectionAccess->getSupportedListeners();
+        sal_Int32 nLength = aControlListeners.getLength();
+             
+        for ( sal_Int32 i = 0; i< nLength; ++i )
+        {
+            Type& listType = aControlListeners[ i ];
+            rtl::OUString sFullTypeName = listType.getTypeName();
+            rtl::OUString sTypeName = listType.getTypeName();
+            sal_Int32 lastDotIndex = -1;
+            if ( ( lastDotIndex = sFullTypeName.lastIndexOf( '.' ) ) > -1 )
+            {
+                sTypeName = sFullTypeName.copy( lastDotIndex + 1 );    
+            } 
+            Sequence< ::rtl::OUString > sMeths = getEventMethods( listType );    
+            sal_Int32 sMethLen = sMeths.getLength();
+            for ( sal_Int32 j=0 ; j < sMethLen; ++j )
+            {
+                OSL_TRACE("**Listener [%d] Type[%s] Method[%s]",j,
+                    rtl::OUStringToOString( sTypeName, 
+                        RTL_TEXTENCODING_UTF8 ).getStr(),
+                    rtl::OUStringToOString( sMeths[ j ], 
+                        RTL_TEXTENCODING_UTF8 ).getStr() );
+            }
+        }
+       
+    }
+}
+
+void dumpEvent( const ScriptEvent& evt )
+{
+    OSL_TRACE("dumpEvent: Source %s",
+        rtl::OUStringToOString( comphelper::anyToString( makeAny(evt.Source)), 
+            RTL_TEXTENCODING_UTF8 ).getStr() );
+
+    OSL_TRACE("dumpEvent: ScriptType %s",
+        rtl::OUStringToOString( evt.ScriptType, 
+            RTL_TEXTENCODING_UTF8 ).getStr() );
+    
+    OSL_TRACE("dumpEvent: ScriptCode %s",
+        rtl::OUStringToOString( evt.ScriptCode, 
+            RTL_TEXTENCODING_UTF8 ).getStr() );
+
+    OSL_TRACE("dumpEvent: ListenerType %s",
+        rtl::OUStringToOString( evt.ListenerType.getTypeName(), 
+            RTL_TEXTENCODING_UTF8 ).getStr() );
+    
+    OSL_TRACE("dumpEvent: Listener methodname %s",
+        rtl::OUStringToOString( evt.MethodName, 
+            RTL_TEXTENCODING_UTF8 ).getStr() );
+
+    OSL_TRACE("dumpEvent: arguments;");
+    sal_Int32 nLen = evt.Arguments.getLength();
+    for ( sal_Int32 index=0; index < nLen; ++index )
+    {
+        OSL_TRACE("\t [%d] %s", index, 
+        rtl::OUStringToOString( comphelper::anyToString( evt.Arguments[ index ] ), 
+            RTL_TEXTENCODING_UTF8 ).getStr() );
+
+    }
+}
+
+
+bool isKeyEventOk( awt::KeyEvent& evt, const Sequence< Any >& params )
+{
+    if ( !( params.getLength() > 0 ) ||
+        !( params[ 0 ] >>= evt ) )
+        return false;
+    return true;
+}
+
+bool isMouseEventOk( awt::MouseEvent& evt, const Sequence< Any >& params )
+{
+    if ( !( params.getLength() > 0 ) ||
+        !( params[ 0 ] >>= evt ) )
+        return false;
+    return true;
+}
+
+Sequence< Any > ooMouseEvtToVBADblClick( const Sequence< Any >& params )
+{
+    Sequence< Any > translatedParams;
+    awt::MouseEvent evt;
+
+    if ( !( isMouseEventOk(evt, params)) || 
+        (evt.ClickCount != 2) )
+        return Sequence< Any >(); 
+    // give back orig params, this will signal that the event is good
+    return params;
+}
+
+Sequence< Any > ooMouseEvtToVBAMouseEvt( const Sequence< Any >& params )
+{
+    Sequence< Any > translatedParams;
+    awt::MouseEvent evt;
+
+    if ( !isMouseEventOk(evt, params) )
+        return Sequence< Any >(); 
+
+    translatedParams.realloc(4);
+
+    // Buttons
+    translatedParams[ 0 ] <<= evt.Buttons;
+    // Shift
+    translatedParams[ 1 ] <<= evt.Modifiers;
+    // X
+    translatedParams[ 2 ] <<= evt.X;
+    // Y
+    translatedParams[ 3 ] <<= evt.Y;
+    return translatedParams;
+}
+
+Sequence< Any > ooKeyPressedToVBAKeyPressed( const Sequence< Any >& params )
+{
+    Sequence< Any > translatedParams;
+    awt::KeyEvent evt;
+
+    if ( !isKeyEventOk( evt, params ) )
+        return Sequence< Any >(); 
+
+    translatedParams.realloc(1);
+
+    MSForms::ReturnInteger keyCode;
+    keyCode.Value = evt.KeyCode; 
+    translatedParams[0] <<= keyCode;
+    return  translatedParams;
+}
+
+Sequence< Any > ooKeyPressedToVBAKeyUpDown( const Sequence< Any >& params )
+{
+    Sequence< Any > translatedParams;
+    awt::KeyEvent evt;
+
+    if ( !isKeyEventOk( evt, params ) )
+        return Sequence< Any >(); 
+
+    translatedParams.realloc(2);
+
+    MSForms::ReturnInteger keyCode;
+    sal_Int8 shift = evt.Modifiers;
+
+    // #TODO check whether values from OOO conform to values generated from vba
+    keyCode.Value = evt.KeyCode; 
+    translatedParams[0] <<= keyCode;
+    translatedParams[1] <<= shift;
+    return  translatedParams;
+}
+
+typedef Sequence< Any > (*Translator)(const Sequence< Any >&);
+
+struct TranslateInfo
+{
+    rtl::OUString sVBAName;
+    Translator toVBA;
+};
+
+
+typedef std::hash_map< rtl::OUString, 
+std::list< TranslateInfo >, 
+::rtl::OUStringHash,
+::std::equal_to< ::rtl::OUString > > EventInfoHash;
+
+
+EventInfoHash& getEventTransInfo()
+{
+    static bool initialised = false;
+    static EventInfoHash eventTransInfo;
+    if ( !initialised )
+    {
+        TranslateInfo  info;
+        // actionPerformed ooo event
+        std::list< TranslateInfo > actionInfos;
+        info.sVBAName = rtl::OUString::createFromAscii("_Click");
+        info.toVBA = NULL;
+        actionInfos.push_back( info );
+        eventTransInfo[ rtl::OUString::createFromAscii("actionPerformed") ] = actionInfos;
+        // changed ooo event
+        std::list< TranslateInfo > changeInfos;
+        info.sVBAName = rtl::OUString::createFromAscii("_Change");
+        info.toVBA = NULL;
+        changeInfos.push_back( info );
+        eventTransInfo[ rtl::OUString::createFromAscii("changed") ] = changeInfos;
+        // focusGained ooo event
+        std::list< TranslateInfo > focusGainedInfos;
+        info.sVBAName = rtl::OUString::createFromAscii("_GotFocus");
+        info.toVBA = NULL;
+        focusGainedInfos.push_back( info );
+        eventTransInfo[ rtl::OUString::createFromAscii("focusGained") ] = focusGainedInfos;
+        // focusLost ooo event
+        std::list< TranslateInfo > focusLostInfos;
+        info.sVBAName = rtl::OUString::createFromAscii("_LostFocus");
+        info.toVBA = NULL;
+        focusLostInfos.push_back( info );
+        eventTransInfo[ rtl::OUString::createFromAscii("focusGained") ] = focusLostInfos;
+        // adjustmentValueChanged ooo event
+        std::list< TranslateInfo > adjustInfos;
+        info.sVBAName = rtl::OUString::createFromAscii("_Scroll");
+        info.toVBA = NULL;
+        adjustInfos.push_back( info );
+        info.sVBAName = rtl::OUString::createFromAscii("_Change");
+        info.toVBA = NULL;
+        adjustInfos.push_back( info );
+        eventTransInfo[ rtl::OUString::createFromAscii("adjustmentValueChanged") ] = adjustInfos;
+        // textChanged ooo event
+        std::list< TranslateInfo > txtChangedInfos;
+        info.sVBAName = rtl::OUString::createFromAscii("_Change");
+        info.toVBA = NULL;
+        txtChangedInfos.push_back( info );
+        eventTransInfo[ rtl::OUString::createFromAscii("textChanged") ] = txtChangedInfos;
+
+        // keyReleased ooo event
+        std::list< TranslateInfo > keyReleasedInfos;
+        info.sVBAName = rtl::OUString::createFromAscii("_KeyUp");
+        info.toVBA = ooKeyPressedToVBAKeyUpDown;
+        keyReleasedInfos.push_back( info );
+        eventTransInfo[ rtl::OUString::createFromAscii("keyReleased") ] = keyReleasedInfos;
+        // mouseReleased ooo event
+        std::list< TranslateInfo > mouseReleasedInfos;
+        info.sVBAName = rtl::OUString::createFromAscii("_MouseUp");
+        info.toVBA = ooMouseEvtToVBAMouseEvt;
+        mouseReleasedInfos.push_back( info );
+        eventTransInfo[ rtl::OUString::createFromAscii("mouseReleased") ] = mouseReleasedInfos;
+        // mousePressed ooo event
+        std::list< TranslateInfo > mousePressedInfos;
+        info.sVBAName = rtl::OUString::createFromAscii("_MouseDown");
+        info.toVBA = ooMouseEvtToVBAMouseEvt;
+        mousePressedInfos.push_back( info );
+        info.sVBAName = rtl::OUString::createFromAscii("_DblClick");
+        // emulate double click event
+        info.toVBA = ooMouseEvtToVBADblClick;
+        mousePressedInfos.push_back( info );
+        eventTransInfo[ rtl::OUString::createFromAscii("mousePressed") ] = mousePressedInfos;
+        // mouseMoved ooo event
+        std::list< TranslateInfo > mouseMovedInfos;
+        info.sVBAName = rtl::OUString::createFromAscii("_MouseMoved");
+        info.toVBA = ooMouseEvtToVBAMouseEvt;
+        mouseMovedInfos.push_back( info );
+        eventTransInfo[ rtl::OUString::createFromAscii("mouseMoved") ] = mouseMovedInfos;
+        // keyPressed ooo event
+        std::list< TranslateInfo > keyPressedInfos;
+        info.sVBAName = rtl::OUString::createFromAscii("_KeyDown");
+        info.toVBA = ooKeyPressedToVBAKeyUpDown;
+        keyPressedInfos.push_back( info );
+        info.sVBAName = rtl::OUString::createFromAscii("_KeyPress");
+        info.toVBA = ooKeyPressedToVBAKeyPressed;
+        keyPressedInfos.push_back( info );
+        eventTransInfo[ rtl::OUString::createFromAscii("keyPressed") ] = keyPressedInfos;
+        initialised = true;
+    }
+    return eventTransInfo;
+}
+
+// Helper class
+
+class ScriptEventFactory
+{
+public:
+    static Sequence< ScriptEventDescriptor > createEvents( const Reference< XInterface >& xControl, const rtl::OUString& sLibModName, const Sequence< rtl::OUString >& sMethods );   
+    static ScriptEventFactory& instance() { static ScriptEventFactory inst; return inst; }
+    static rtl::OUString getControlName( const Reference< XInterface >& xControl );
+    static Sequence< rtl::OUString > getEventListeners( const Reference< XInterface >& xControl );
+private:
+    ScriptEventFactory();
+    Reference< XComponentContext > m_xCtx;
+};
+
+// Helper function
+bool
+eventMethodToDescriptors( const ::rtl::OUString& rEventMethod,  const Reference< XInterface >& xControl, const rtl::OUString& sLibModName, const Sequence< rtl::OUString >& sHandlerExts, Sequence< ScriptEventDescriptor >& evtDescs )
+{
+    // format of ControlListener is TypeName::methodname e.g.
+    // "com.sun.star.awt.XActionListener::actionPerformed" or
+    // "XActionListener::actionPerformed
+
+    ::rtl::OUString sMethodName;
+    ::rtl::OUString sTypeName;
+    sal_Int32 nDelimPos = rEventMethod.indexOf( DELIM );
+    if ( nDelimPos == -1 )
+    {
+        return false;
+    }
+    sMethodName = rEventMethod.copy( nDelimPos + DELIMLEN );
+    sTypeName = rEventMethod.copy( 0, nDelimPos );
+            
+    EventInfoHash& infos = getEventTransInfo();
+
+    // Only create an ScriptEventDescriptor for an event we can translate
+    // or emulate
+    EventInfoHash::const_iterator eventInfo_it = infos.find( sMethodName );
+    EventInfoHash::const_iterator it_end = infos.end();
+
+    // sLibModName ( could ) include the uri bits :-) from calc
+    rtl::OUString sPartialMacroName = sLibModName + rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(".") ) + rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("$macro"));
+
+    if ( sMethodName.getLength() 
+         && sTypeName.getLength()
+         && ( infos.find( sMethodName ) != infos.end() ) )
+    {
+        std::list< TranslateInfo >::const_iterator txInfo =
+            eventInfo_it->second.begin();
+        std::list< TranslateInfo >::const_iterator txInfo_end = 
+            eventInfo_it->second.end();
+        for ( ; txInfo != txInfo_end; ++txInfo )
+        {
+            // Check if extension is support for this method, if
+            // so create an eventdescription for that
+            const rtl::OUString* pExt = sHandlerExts.getConstArray();
+            sal_Int32  nCount = sHandlerExts.getLength();
+            for ( sal_Int32 counter=0;  counter<nCount; ++counter, ++pExt )
+            {
+                if ( (*txInfo).sVBAName.equals( *pExt ) ) // handler for event
+                {
+                    sal_Int32 nIndex = evtDescs.getLength();
+	            evtDescs.realloc( evtDescs.getLength() + 1 );
+                    evtDescs[ nIndex ].ScriptCode =  sPartialMacroName + *pExt;
+                    evtDescs[ nIndex ].ListenerType = sTypeName;
+                    evtDescs[ nIndex ].EventMethod = sMethodName;
+
+                    // set this it VBAInterop, ensures that it doesn't
+                    // get persisted or shown in property editors
+                    evtDescs[ nIndex ].ScriptType = rtl::OUString::createFromAscii( "VBAInterop" );	
+                 }
+            }    
+        }
+        return true;
+    }
+    return false;
+
+}
+
+bool
+eventMethodToDescriptor( const ::rtl::OUString& rEventMethod, const Reference< XInterface >& xControl, ScriptEventDescriptor& evtDesc )
+{
+    // format of ControlListener is TypeName::methodname e.g.
+    // "com.sun.star.awt.XActionListener::actionPerformed" or
+    // "XActionListener::actionPerformed
+
+    ::rtl::OUString sMethodName;
+    ::rtl::OUString sTypeName;
+    sal_Int32 nDelimPos = rEventMethod.indexOf( DELIM );
+    if ( nDelimPos == -1 )
+    {
+        return false;
+    }
+    sMethodName = rEventMethod.copy( nDelimPos + DELIMLEN );
+    sTypeName = rEventMethod.copy( 0, nDelimPos );
+            
+    EventInfoHash& infos = getEventTransInfo();
+
+    // Only create an ScriptEventDescriptor for an event we can translate
+    // or emulate
+    if ( sMethodName.getLength() 
+         && sTypeName.getLength()
+         && ( infos.find( sMethodName ) != infos.end() ) )
+    {
+        // just fill in control name, event handler will
+        // do the rest e.g. search for this routine in the doc basic
+        // and run it.
+        evtDesc.ScriptCode =  ScriptEventFactory::instance().getControlName(xControl);
+        evtDesc.ListenerType = sTypeName;
+        evtDesc.EventMethod = sMethodName;
+
+        // set this it VBAInterop, ensures that it doesn't
+        // get persisted or shown in property editors
+        evtDesc.ScriptType = rtl::OUString::createFromAscii(
+            "VBAInterop" );	
+        return true;
+    }
+    return false;
+
+}
+
+ScriptEventFactory::ScriptEventFactory()
+{
+    Reference < beans::XPropertySet > xProps(
+        ::comphelper::getProcessServiceFactory(), UNO_QUERY_THROW );
+    m_xCtx.set( xProps->getPropertyValue( rtl::OUString(
+        RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))), 
+        uno::UNO_QUERY_THROW );
+}
+rtl::OUString
+ScriptEventFactory::getControlName( const Reference< XInterface >& rXControl )
+{
+    Reference< XInterface > xIfModel;
+    Reference< awt::XControl > xControl( rXControl, UNO_QUERY );
+    if ( xControl.is() )
+        xIfModel = xControl->getModel();
+    else
+        xIfModel = rXControl;
+
+    Reference< beans::XPropertySet > xProps( xIfModel, UNO_QUERY );
+    ::rtl::OUString sName;
+    if ( xProps.is() )
+    {
+        try
+        {
+            xProps->getPropertyValue(
+                ::rtl::OUString::createFromAscii("Name") ) >>= sName;
+        }
+        catch(Exception& e)
+        {
+            OSL_TRACE("PropertyStuff mucked up no name got exception: %s",
+               (const sal_Char *) rtl::OUStringToOString( e.Message, RTL_TEXTENCODING_UTF8 ));	
+        }
+    }
+    return sName;
+}
+
+Sequence< rtl::OUString > 
+ScriptEventFactory::getEventListeners( const Reference< XInterface >& xControl )
+{
+    Reference< lang::XMultiComponentFactory > xMFac( 
+        instance().m_xCtx->getServiceManager(), UNO_QUERY );
+    std::list< rtl::OUString > eventMethods;
+
+    if ( xMFac.is() )
+    {
+        Reference< beans::XIntrospection > xIntrospection( 
+            xMFac->createInstanceWithContext( rtl::OUString( 
+                RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.beans.Introspection"  ) ), instance().m_xCtx ), UNO_QUERY );
+        //dumpListeners( xIntrospection, xControl );
+        //dumpListeners( xIntrospection, xControl->getModel() );
+        Reference< beans::XIntrospectionAccess > xIntrospectionAccess;
+	if  ( xIntrospection.is() )
+	{
+            xIntrospectionAccess = xIntrospection->inspect( 
+                makeAny( xControl ) );
+            Sequence< Type > aControlListeners = 
+                xIntrospectionAccess->getSupportedListeners();
+            sal_Int32 nLength = aControlListeners.getLength();             
+            for ( sal_Int32 i = 0; i< nLength; ++i )
+            {
+                Type& listType = aControlListeners[ i ];
+                rtl::OUString sFullTypeName = listType.getTypeName();
+                Sequence< ::rtl::OUString > sMeths = 
+                    getEventMethods( listType );    
+                sal_Int32 sMethLen = sMeths.getLength();
+                for ( sal_Int32 j=0 ; j < sMethLen; ++j )
+                {
+                    rtl::OUString sEventMethod = sFullTypeName;
+                    sEventMethod += DELIM;
+                    sEventMethod += sMeths[ j ];
+                    eventMethods.push_back( sEventMethod );
+                }
+            }
+            
+        }
+    }
+
+    Sequence< rtl::OUString > sEventMethodNames( eventMethods.size() );
+    std::list< rtl::OUString >::const_iterator it = eventMethods.begin();
+    rtl::OUString* pDest = sEventMethodNames.getArray();
+
+    for ( ; it != eventMethods.end(); ++it, ++pDest )
+        *pDest = *it;         
+
+    return sEventMethodNames;
+}
+
+Sequence< ScriptEventDescriptor > 
+ScriptEventFactory::createEvents( const Reference< XInterface >& xControl, const rtl::OUString& sLibModName, const Sequence< rtl::OUString >& sHandlerExts )
+{
+    Sequence< rtl::OUString > aControlListeners = ScriptEventFactory::instance().getEventListeners( xControl );
+    rtl::OUString* pSrc = aControlListeners.getArray();
+    sal_Int32 nLength = aControlListeners.getLength();             
+
+    Sequence< ScriptEventDescriptor > aDest( nLength * 2 );// sensible default
+    ScriptEventDescriptor* pDest = aDest.getArray();
+    sal_Int32 nEvts = 0;
+
+  
+    for ( sal_Int32 i = 0; i< nLength; ++i, ++pSrc )
+    {
+        // from getListeners eventName is of form
+        // "com.sun.star.awt.XActionListener::actionPerformed"
+        // we need to strip "com.sun.star.awt." from that for form
+        // controls
+        sal_Int32 lastDotIndex = -1;
+        ::rtl::OUString sNoNameSpaceMethod = *pSrc;
+        if ( ( lastDotIndex = pSrc->lastIndexOf( '.' ) ) > -1 )
+            sNoNameSpaceMethod = sNoNameSpaceMethod.copy( lastDotIndex + 1 );
+	Sequence< ScriptEventDescriptor> evtDescs;
+        if ( eventMethodToDescriptors( sNoNameSpaceMethod, xControl, sLibModName, sHandlerExts, evtDescs ) )
+        {
+            sal_Int32 dIndex = nEvts;
+            nEvts += evtDescs.getLength();
+            ScriptEventDescriptor* pDesc = evtDescs.getArray();
+            if ( nEvts > aDest.getLength() )
+                aDest.realloc( nEvts );// should never happen
+            for ( ; dIndex < nEvts; ++dIndex, ++pDesc )
+                aDest[ dIndex ] = *pDesc; 
+        }
+    }
+    aDest.realloc( nEvts );
+
+    return aDest;
+}
+
+
+typedef ::cppu::WeakImplHelper1< container::XNameContainer > NameContainer_BASE;
+
+class ReadOnlyEventsNameContainer : public NameContainer_BASE
+{
+public:
+    ReadOnlyEventsNameContainer( const Sequence< rtl::OUString >& eventMethods, const Reference< XInterface >& xControl );
+    // XNameContainer
+
+    virtual void SAL_CALL insertByName( const ::rtl::OUString& aName, const Any& aElement ) throw (lang::IllegalArgumentException, container::ElementExistException, lang::WrappedTargetException, RuntimeException)
+    {
+        throw RuntimeException( rtl::OUString::createFromAscii( "ReadOnly container" ), Reference< XInterface >() );
+ 
+    }
+    virtual void SAL_CALL removeByName( const ::rtl::OUString& Name ) throw (::com::sun::star::container::NoSuchElementException, lang::WrappedTargetException, RuntimeException)
+    {
+        throw RuntimeException( rtl::OUString::createFromAscii( "ReadOnly container" ), Reference< XInterface >() );
+    }
+
+    // XNameReplace
+    virtual void SAL_CALL replaceByName( const ::rtl::OUString& aName, const Any& aElement ) throw (lang::IllegalArgumentException, container::NoSuchElementException, lang::WrappedTargetException, RuntimeException)
+    {
+        throw RuntimeException( rtl::OUString::createFromAscii( "ReadOnly container" ), Reference< XInterface >() );
+ 
+    }
+                                                                                
+    // XNameAccess
+    virtual Any SAL_CALL getByName( const ::rtl::OUString& aName ) throw (container::NoSuchElementException, lang::WrappedTargetException, RuntimeException);
+    virtual Sequence< ::rtl::OUString > SAL_CALL getElementNames(  ) throw (RuntimeException);
+    virtual ::sal_Bool SAL_CALL hasByName( const ::rtl::OUString& aName ) throw (RuntimeException);
+
+    // XElementAccess
+    virtual Type SAL_CALL getElementType(  ) throw (RuntimeException)
+    { return getCppuType(static_cast< const rtl::OUString * >(0) ); }
+    virtual ::sal_Bool SAL_CALL hasElements(  ) throw (RuntimeException)
+    { return ( ( m_hEvents.size() > 0 ? sal_True : sal_False ) ); }
+private:
+
+typedef std::hash_map< rtl::OUString, Any, ::rtl::OUStringHash,
+::std::equal_to< ::rtl::OUString > > EventSupplierHash;
+
+    EventSupplierHash m_hEvents;
+};
+
+ReadOnlyEventsNameContainer::ReadOnlyEventsNameContainer( const Sequence< rtl::OUString >& eventMethods, const Reference< XInterface >& xControl ) 
+{
+    const rtl::OUString* pSrc = eventMethods.getConstArray();
+    sal_Int32 nLen = eventMethods.getLength();
+    for ( sal_Int32 index = 0; index < nLen; ++index, ++pSrc )
+    {
+        Any aDesc;
+        ScriptEventDescriptor evtDesc;
+        if (  eventMethodToDescriptor( *pSrc, xControl, evtDesc ) )
+        {
+            aDesc <<= evtDesc; 
+            m_hEvents[ *pSrc ] = aDesc;
+        }
+    }
+}
+
+Any SAL_CALL 
+ReadOnlyEventsNameContainer::getByName( const ::rtl::OUString& aName ) throw (container::NoSuchElementException, lang::WrappedTargetException, RuntimeException){
+    EventSupplierHash::const_iterator it = m_hEvents.find( aName );
+    if ( it == m_hEvents.end() )
+        throw container::NoSuchElementException();
+    return it->second;
+}
+
+Sequence< ::rtl::OUString > SAL_CALL 
+ReadOnlyEventsNameContainer::getElementNames(  ) throw (RuntimeException)
+{
+    Sequence< ::rtl::OUString > names(m_hEvents.size());
+    rtl::OUString* pDest = names.getArray();
+    EventSupplierHash::const_iterator it = m_hEvents.begin();
+    EventSupplierHash::const_iterator it_end = m_hEvents.end();
+    for ( sal_Int32 index = 0; it != it_end; ++index, ++pDest, ++it )
+        *pDest = it->first;
+    return names;
+}
+
+sal_Bool SAL_CALL 
+ReadOnlyEventsNameContainer::hasByName( const ::rtl::OUString& aName ) throw (RuntimeException)
+{
+    EventSupplierHash::const_iterator it = m_hEvents.find( aName );
+    if ( it == m_hEvents.end() )
+        return sal_False;
+    return sal_True;
+}
+
+typedef ::cppu::WeakImplHelper1< XScriptEventsSupplier > EventsSupplier_BASE;
+
+class ReadOnlyEventsSupplier : public EventsSupplier_BASE
+{
+public:
+    ReadOnlyEventsSupplier( const Sequence< ::rtl::OUString >& eventMethods, const Reference< XInterface >& xControl )
+    { m_xNameContainer = new ReadOnlyEventsNameContainer( eventMethods, xControl ); }
+    
+    // XScriptEventSupplier
+    virtual Reference< container::XNameContainer > SAL_CALL getEvents(  ) throw (RuntimeException){ return m_xNameContainer; }
+private:
+    Reference< container::XNameContainer > m_xNameContainer;
+};
+
+typedef ::cppu::WeakImplHelper2< XScriptListener, lang::XInitialization > EventListener_BASE;
+
+#define EVENTLSTNR_PROPERTY_ID_MODEL         1
+#define EVENTLSTNR_PROPERTY_MODEL            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Model" ) )
+
+class EventListener : public EventListener_BASE
+    ,public ::comphelper::OMutexAndBroadcastHelper
+    ,public ::comphelper::OPropertyContainer
+    ,public ::comphelper::OPropertyArrayUsageHelper< EventListener >
+
+{
+public:
+    EventListener( const Reference< XComponentContext >& rxContext );
+    // XEventListener
+    virtual void SAL_CALL disposing(const lang::EventObject& Source) throw( RuntimeException );
+
+    // XScriptListener
+    virtual void SAL_CALL firing(const ScriptEvent& evt) throw(RuntimeException);
+    virtual Any SAL_CALL approveFiring(const ScriptEvent& evt) throw(reflection::InvocationTargetException, RuntimeException);
+    // XPropertySet
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySetInfo > SAL_CALL getPropertySetInfo(  ) throw (::com::sun::star::uno::RuntimeException);    
+    // XInitialization
+    virtual void SAL_CALL initialize( const Sequence< Any >& aArguments ) throw (Exception, RuntimeException);
+    // XInterface
+    DECLARE_XINTERFACE()
+
+    // XTypeProvider
+    DECLARE_XTYPEPROVIDER()
+
+protected:
+    // OPropertySetHelper
+    virtual ::cppu::IPropertyArrayHelper& SAL_CALL getInfoHelper(  );
+
+    // OPropertyArrayUsageHelper
+    virtual ::cppu::IPropertyArrayHelper* createArrayHelper(  ) const;
+
+private:
+    SfxObjectShellRef findObjShell();
+    void firing_Impl( const  ScriptEvent& evt, Any *pSyncRet=NULL ) throw( RuntimeException );
+
+    Reference< XComponentContext > m_xContext;
+    Reference< frame::XModel > m_xModel;
+    
+};
+
+EventListener::EventListener( const Reference< XComponentContext >& rxContext ) :
+OPropertyContainer(GetBroadcastHelper()), m_xContext( rxContext )
+{
+    registerProperty( EVENTLSTNR_PROPERTY_MODEL, EVENTLSTNR_PROPERTY_ID_MODEL,
+        beans::PropertyAttribute::TRANSIENT, &m_xModel, ::getCppuType( &m_xModel ) );
+
+}
+
+//XEventListener
+void
+EventListener::disposing(const lang::EventObject& Source)  throw( RuntimeException )
+{
+}
+
+//XScriptListener
+
+void SAL_CALL 
+EventListener::firing(const ScriptEvent& evt) throw(RuntimeException)
+{
+    firing_Impl( evt );
+}
+
+Any SAL_CALL 
+EventListener::approveFiring(const ScriptEvent& evt) throw(reflection::InvocationTargetException, RuntimeException)
+{
+    Any ret;
+    firing_Impl( evt, &ret );
+    return ret;
+}
+
+// XInitialization
+void SAL_CALL 
+EventListener::initialize( const Sequence< Any >& aArguments ) throw (Exception, RuntimeException)
+{
+    if ( aArguments.getLength() == 1 )
+        aArguments[0] >>= m_xModel;
+}
+
+// XInterface
+
+IMPLEMENT_FORWARD_XINTERFACE2( EventListener, EventListener_BASE, OPropertyContainer )
+
+// XTypeProvider
+
+IMPLEMENT_FORWARD_XTYPEPROVIDER2( EventListener, EventListener_BASE, OPropertyContainer )
+
+// OPropertySetHelper
+
+::cppu::IPropertyArrayHelper& 
+EventListener::getInfoHelper(  )
+{
+    return *getArrayHelper();
+}
+
+// OPropertyArrayUsageHelper
+
+::cppu::IPropertyArrayHelper* 
+EventListener::createArrayHelper(  ) const
+{
+    Sequence< beans::Property > aProps;
+    describeProperties( aProps );
+    return new ::cppu::OPropertyArrayHelper( aProps );
+}
+
+// XPropertySet
+Reference< beans::XPropertySetInfo > 
+EventListener::getPropertySetInfo(  ) throw (RuntimeException)
+{
+    Reference< beans::XPropertySetInfo > xInfo( createPropertySetInfo( getInfoHelper() ) );
+    return xInfo;
+}
+
+
+// EventListener
+
+SfxObjectShellRef 
+EventListener::findObjShell()
+{
+    SfxObjectShellRef result = SfxObjectShell::GetFirst();
+    while ( result.Is() )
+    {
+       if ( m_xModel == result->GetModel() )
+           break;
+        result = SfxObjectShell::GetNext( *result );
+    }
+    return  result;
+}
+
+void
+EventListener::firing_Impl(const ScriptEvent& evt, Any* pRet ) throw(RuntimeException)
+{
+    static const ::rtl::OUString vbaInterOp =
+        ::rtl::OUString::createFromAscii("VBAInterop");
+
+    // let default handlers deal with non vba stuff
+    if ( !evt.ScriptType.equals( vbaInterOp ) )
+        return;
+    SfxObjectShellRef xObjSh = findObjShell(); 
+    //dumpEvent( evt );
+    EventInfoHash& infos = getEventTransInfo();
+    EventInfoHash::const_iterator eventInfo_it = infos.find( evt.MethodName );
+    EventInfoHash::const_iterator it_end = infos.end();
+    if ( eventInfo_it == it_end )
+    {
+        OSL_TRACE("Bogus event for %s",
+            rtl::OUStringToOString( evt.ScriptType, RTL_TEXTENCODING_UTF8 ).getStr() );
+        return;
+    }
+
+    if ( xObjSh.Is() )
+    {
+        std::list< TranslateInfo > matchingMethods;
+        std::list< TranslateInfo >::const_iterator txInfo =
+            eventInfo_it->second.begin();
+        std::list< TranslateInfo >::const_iterator txInfo_end = eventInfo_it->second.end();
+        for ( ; txInfo != txInfo_end; ++txInfo )
+        {
+            // see if we have a match for the handlerextension
+            // where ScriptCode is methodname_handlerextension 
+            rtl::OUString sTemp = evt.ScriptCode; 
+            sal_Int32 lastIndexOf_ = sTemp.lastIndexOf( '_' );
+            if ( lastIndexOf_ != -1 )
+                sTemp = sTemp.copy( lastIndexOf_ ); 
+            OSL_TRACE("*** trying to match %s with %s",
+                rtl::OUStringToOString( sTemp, RTL_TEXTENCODING_UTF8 ).getStr(),
+                rtl::OUStringToOString( (*txInfo).sVBAName, RTL_TEXTENCODING_UTF8 ).getStr() );
+            if ( sTemp.equals( (*txInfo).sVBAName ) )
+            {
+                // !! translate arguments & emulate events where necessary 
+                Sequence< Any > aArguments;
+                if  ( (*txInfo).toVBA )
+                    aArguments = (*txInfo).toVBA( evt.Arguments );
+                else
+                    aArguments = evt.Arguments;
+                if ( aArguments.getLength() )
+                {
+                    // call basic event handlers for event
+
+                    static rtl::OUString part1 = rtl::OUString::createFromAscii( "vnd.sun.star.script:");
+                    static rtl::OUString part2 = rtl::OUString::createFromAscii("?language=Basic&location=document"); 
+
+                    // create script url
+                    rtl::OUString url = part1 + evt.ScriptCode + part2;
+                 
+                    OSL_TRACE("script url = %s",
+                        rtl::OUStringToOString( url, 
+                            RTL_TEXTENCODING_UTF8 ).getStr() );
+                    Any aRet; // temp
+                    if ( pRet == NULL )
+                        pRet = &aRet;
+                    Sequence< sal_Int16 > aOutArgsIndex;
+                    Sequence< Any > aOutArgs;
+                    xObjSh->CallXScript( url,  aArguments, *pRet,
+                        aOutArgsIndex, aOutArgs);
+               } 
+           }
+       }
+    }
+}
+
+typedef ::cppu::WeakImplHelper1< XVBAToOOEventDescGen > VBAToOOEventDescGen_BASE;
+
+
+class VBAToOOEventDescGen : public VBAToOOEventDescGen_BASE
+{
+public:
+    VBAToOOEventDescGen( const Reference< XComponentContext >& rxContext );
+
+    // XVBAToOOEventDescGen
+    virtual Sequence< ScriptEventDescriptor > SAL_CALL getEventDescriptions( const Reference< XInterface >& control, const rtl::OUString& sLibModName, const Sequence< rtl::OUString >& sHandlerExts ) throw (RuntimeException);
+    virtual Reference< XScriptEventsSupplier > SAL_CALL getEventSupplier( const Reference< XInterface >& xControl ) throw (::com::sun::star::uno::RuntimeException);
+private:
+    Reference< XComponentContext > m_xContext;
+  
+};
+
+VBAToOOEventDescGen::VBAToOOEventDescGen( const Reference< XComponentContext >& rxContext ):m_xContext( rxContext ) {}
+
+Sequence< ScriptEventDescriptor > SAL_CALL 
+VBAToOOEventDescGen::getEventDescriptions( const Reference< XInterface >& xControl, const rtl::OUString& sLibModName, const Sequence< rtl::OUString >& sHandlerExts ) throw (RuntimeException)
+{
+    return ScriptEventFactory::instance().createEvents( xControl, sLibModName, sHandlerExts ); 
+}
+
+Reference< XScriptEventsSupplier > SAL_CALL 
+VBAToOOEventDescGen::getEventSupplier( const Reference< XInterface >& xControl ) throw (::com::sun::star::uno::RuntimeException)
+{
+    Reference< XScriptEventsSupplier > xSupplier = 
+        new ReadOnlyEventsSupplier( 
+            ScriptEventFactory::instance().getEventListeners( xControl ),
+            xControl ) ;
+    return xSupplier;
+}
+
+// Component related 
+
+namespace evtlstner
+{
+    ::rtl::OUString SAL_CALL getImplementationName()
+    {
+        static ::rtl::OUString* pImplName = 0;
+        if ( !pImplName )
+        {
+            ::osl::MutexGuard aGuard( ::osl::Mutex::getGlobalMutex() );
+            if ( !pImplName )
+            {
+                static ::rtl::OUString aImplName( RTL_CONSTASCII_USTRINGPARAM( "org.openoffice.vba.EventListener" ) );
+                pImplName = &aImplName;
+            }
+        }
+        return *pImplName;
+    }
+
+    uno::Reference< XInterface > SAL_CALL create(
+    Reference< XComponentContext > const & xContext )
+    SAL_THROW( () )
+    {
+        return static_cast< lang::XTypeProvider * >( new EventListener( xContext ) );
+    }
+
+    Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames()
+    {
+        const ::rtl::OUString strName( ::evtlstner::getImplementationName() );
+        return Sequence< ::rtl::OUString >( &strName, 1 );
+    }	
+}
+namespace ooevtdescgen 
+{
+    ::rtl::OUString SAL_CALL getImplementationName()
+    {
+        static ::rtl::OUString* pImplName = 0;
+        if ( !pImplName )
+        {
+            ::osl::MutexGuard aGuard( ::osl::Mutex::getGlobalMutex() );
+            if ( !pImplName )
+            {
+                static ::rtl::OUString aImplName( RTL_CONSTASCII_USTRINGPARAM( "org.openoffice.vba.VBAToOOEventDesc" ) );
+                pImplName = &aImplName;
+            }
+        }
+        return *pImplName;
+    }
+
+    uno::Reference< XInterface > SAL_CALL create(
+        Reference< XComponentContext > const & xContext )
+        SAL_THROW( () )
+    {
+        return static_cast< lang::XTypeProvider * >( new VBAToOOEventDescGen( xContext ) );
+    }
+
+    Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames()
+    {
+    	const ::rtl::OUString strName( ::ooevtdescgen::getImplementationName() );
+        return Sequence< ::rtl::OUString >( &strName, 1 );
+    }	
+}
--- /data4/sles/ooo-build-HEAD/ooo-build/build/src680-m175/sc/source/filter/inc/xlocx.hxx	2006-07-31 17:59:05.000000000 +0100
+++ sc/source/filter/inc/xlocx.hxx	2006-07-11 00:06:45.000000000 +0100
@@ -46,6 +46,11 @@
 #ifndef SC_XEROOT_HXX
 #include "xeroot.hxx"
 #endif
+#ifdef ENABLE_VBA
+#ifndef _COM_SUN_STAR_SCRIPT_SCRIPTEVENTDESCRIPTOR_HPP_
+#include <com/sun/star/script/ScriptEventDescriptor.hpp>
+#endif
+#endif //ENABLE_VBA
 
 // 0 = Export TBX form controls, 1 = Export OCX form controls.
 #define EXC_EXP_OCX_CTRL 0
@@ -118,6 +123,12 @@ private:
                             const XclImpCtrlLinkHelper& rControl ) const;
     /** Tries to register a Basic macro for the control. */
     void                RegisterTbxMacro( const XclImpTbxControlObj& rTbxCtrlObj );
+#ifdef ENABLE_VBA
+    void                RegisterOleMacros( const ::com::sun::star::uno::Reference< 
+                                               ::com::sun::star::awt::XControlModel >& rxModel,
+                                           const XclImpOleObj& rOcxCtrlObj );
+    void                AttachMacro( const ::com::sun::star::script::ScriptEventDescriptor& rEvent );
+#endif //ENABLE_VBA
 
 private:
     ::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory >
--- /data4/sles/ooo-build-HEAD/ooo-build/build/src680-m175/sc/source/filter/excel/xlocx.cxx	2006-07-31 17:59:05.000000000 +0100
+++ sc/source/filter/excel/xlocx.cxx	2006-07-31 18:15:02.000000000 +0100
@@ -76,13 +76,48 @@
 #ifndef _COM_SUN_STAR_FORM_BINDING_XLISTENTRYSOURCE_HPP_
 #include <com/sun/star/form/binding/XListEntrySource.hpp>
 #endif
-#ifndef _COM_SUN_STAR_SCRIPT_SCRIPTEVENTDESCRIPTOR_HPP_
-#include <com/sun/star/script/ScriptEventDescriptor.hpp>
-#endif
 #ifndef _COM_SUN_STAR_SCRIPT_XEVENTATTACHERMANAGER_HPP_
 #include <com/sun/star/script/XEventAttacherManager.hpp>
 #endif
 
+#ifdef ENABLE_VBA
+#ifndef _SB_SBSTAR_HXX
+#include <basic/sbstar.hxx>
+#endif
+#ifndef _SB_SBMOD_HXX
+#include <basic/sbmod.hxx>
+#endif
+#ifndef _SB_SBMETH_HXX
+#include <basic/sbmeth.hxx>
+#endif
+#ifndef _SBXCLASS_HXX
+#include <basic/sbx.hxx>
+#endif
+#ifndef SC_SCEXTOPT_HXX
+#include <scextopt.hxx>
+#endif
+#ifndef _COM_SUN_STAR_AWT_XCONTROL_HPP_
+#include <com/sun/star/awt/XControl.hpp>
+#endif
+#ifndef _ORG_OPENOFFICE_VBA_XVBATOOOEVENTDESCGEN_HPP_
+#include <org/openoffice/vba/XVBAToOOEventDescGen.hpp>
+#endif
+#ifndef _CPPUHELPER_BOOTSTRAP_HXX_
+#include <cppuhelper/bootstrap.hxx>
+#endif
+
+using org::openoffice::vba::XVBAToOOEventDescGen;
+using com::sun::star::uno::XComponentContext;
+using com::sun::star::awt::XControl;
+using com::sun::star::uno::UNO_QUERY_THROW;
+#else
+#ifndef _COM_SUN_STAR_SCRIPT_SCRIPTEVENTDESCRIPTOR_HPP_
+#include <com/sun/star/script/ScriptEventDescriptor.hpp>
+#endif
+
+#endif //ENABLE_VBA
+
+
 #ifndef _SFX_OBJSH_HXX
 #include <sfx2/objsh.hxx>
 #endif
@@ -249,6 +284,9 @@ SdrObject* XclImpOcxConverter::CreateSdr
                         ScfPropertySet aPropSet( xModel );
                         if( aPropSet.Is() )
                             rOcxCtrlObj.WriteToPropertySet( aPropSet );
+#ifdef ENABLE_VBA
+                        RegisterOleMacros( xModel, rOcxCtrlObj );
+#endif //ENABLE_VBA
                     }
                 }
                 return pSdrObj;
@@ -275,7 +313,6 @@ SdrObject* XclImpOcxConverter::CreateSdr
             Reference< XShape > xShape;
             // dummy size
             ::com::sun::star::awt::Size aSize;
-
             // try to insert the control into the form
             if( InsertControl( xFormComp, aSize, &xShape, TRUE ) )
             {
@@ -435,23 +472,119 @@ void XclImpOcxConverter::ConvertSheetLin
 void XclImpOcxConverter::RegisterTbxMacro( const XclImpTbxControlObj& rTbxCtrlObj )
 {
     ScriptEventDescriptor aEvent;
+#ifdef ENABLE_VBA
+    if ( rTbxCtrlObj.FillMacroDescriptor( aEvent ) )
+        AttachMacro( aEvent );
+#else
     if( (mnLastIndex >= 0) && rTbxCtrlObj.FillMacroDescriptor( aEvent ) )
     {
+         Reference< XEventAttacherManager > xEventMgr( GetFormComps(), UNO_QUERY );
+         if( xEventMgr.is() )
+         {
+             try
+             {
+                xEventMgr->registerScriptEvent( mnLastIndex, aEvent );
+             }
+             catch( Exception& )
+             {
+                DBG_ERRORFILE( "XclImpOcxConverter::RegisterTbxMacro - cannot register macro" );
+             }
+         }
+    }
+#endif
+}
+#ifdef ENABLE_VBA
+void XclImpOcxConverter::AttachMacro( const ScriptEventDescriptor& rEvent )
+{
+    if( mnLastIndex >= 0 ) 
+    {
         Reference< XEventAttacherManager > xEventMgr( GetFormComps(), UNO_QUERY );
         if( xEventMgr.is() )
         {
             try
             {
-                xEventMgr->registerScriptEvent( mnLastIndex, aEvent );
+                xEventMgr->registerScriptEvent( mnLastIndex, rEvent );
             }
             catch( Exception& )
             {
-                DBG_ERRORFILE( "XclImpOcxConverter::RegisterTbxMacro - cannot register macro" );
+                DBG_ERRORFILE( "XclImpOcxConverter::AttachMacro - cannot attach macro" );
             }
         }
     }
 }
 
+void XclImpOcxConverter::RegisterOleMacros( const Reference< XControlModel > & rxModel, const XclImpOleObj& rOcxCtrlObj )
+{
+    // Need to search basic for macro's named e.g. ControlButton1_Click
+    OUString sSearchString = rOcxCtrlObj.GetControlName();
+    sSearchString += OUString::createFromAscii("_");
+    ScfPropertySet aPropSet( rxModel );
+ 
+    if( SfxObjectShell* pDocShell = GetDocShell() )
+        if( StarBASIC* pBasic = pDocShell->GetBasic() )
+            // Seach in the CodeName ( Module ) associated with this sheet
+            if( SbModule* pModule = dynamic_cast< SbModule* >( pBasic->Find( GetExtDocOptions().GetCodeName(rOcxCtrlObj.GetScTab() ), SbxCLASS_OBJECT ) ) )
+            {
+                Reference<XComponentContext > xContext( ::cppu::defaultBootstrap_InitialComponentContext(), UNO_QUERY_THROW ); // Fatal error anyway
+                if ( SbxArray* pMethods = pModule->GetMethods() )
+                {
+                    sal_Int32 nNumMethods = pMethods->Count();
+                    String sLibModName = pModule->GetName();
+                    sLibModName.Insert('.',0).Insert( pModule->GetParent()->GetName(), 0 );
+                    // Use service to create bindings for this control.
+                    // Bindings are created based on the handlers found. 
+                    // Note: service just needs the extensions for the handlers 
+                    // that we found e.g.  "_Click, _Change, _GotFocus" etc.
+                    // Hopefully this service can be re-used to do the same foo
+                    // for UserForms
+                    Reference< XVBAToOOEventDescGen > xEvtDescGen( xContext->getServiceManager()->createInstanceWithContext( CREATE_OUSTRING( "org.openoffice.vba.VBAToOOEventDesc" ), xContext ), UNO_QUERY );
+
+                    Reference< XControl > xCntrl;
+                    String sServiceName;
+                    // VBAToOOEventDesc expects an XControl to introspect on
+                    // so create one ( is discarded ) 
+                    if ( aPropSet.GetStringProperty(  sServiceName, CREATE_OUSTRING( "DefaultControl" ) ) && sServiceName.Len() )
+                    {
+                        xCntrl.set( xContext->getServiceManager()->createInstanceWithContext( sServiceName , xContext), UNO_QUERY );
+                        if ( xCntrl.is() )
+                        {
+                            // also need the model ( contains the control name
+                            // as well )
+                            xCntrl->setModel( rxModel );
+                        }
+                    }
+                    for ( sal_Int32 nIndex=0; nIndex<nNumMethods; ++nIndex )
+                    {
+                        SbMethod* pMethod = dynamic_cast< SbMethod* >( pMethods->Get( static_cast< USHORT >( nIndex ) ) );
+                        OUString sMeth( pMethod->GetName() );
+			// The name of the method and the name of the
+			// control may match in a case insensitive way
+                        sal_Int32 nSearchIndex = sMeth.toAsciiUpperCase().indexOf( sSearchString.toAsciiUpperCase() );
+                        if ( nSearchIndex == 0  )
+                        {
+                            Sequence< OUString > sHandlerExtns(1);
+                            sHandlerExtns[ 0 ] = sMeth.copy( rOcxCtrlObj.GetControlName().Len() );
+                            OUString sMacroName = sMeth.copy( 0, rOcxCtrlObj.GetControlName().Len() );
+                            Sequence< ScriptEventDescriptor > aDescs( xEvtDescGen->getEventDescriptions( xCntrl, sLibModName, sHandlerExtns ) );
+                            if ( aDescs.getLength() )
+                            {
+                                ScriptEventDescriptor* pEvent = aDescs.getArray();
+                                ScriptEventDescriptor* pEnd = pEvent + aDescs.getLength();
+                                sal_Int32 counter = 0;
+                                for ( ; pEvent < pEnd; ++pEvent )
+                                {
+                                    const static OUString sMacro( RTL_CONSTASCII_USTRINGPARAM("$macro"));
+                                    pEvent->ScriptCode = pEvent->ScriptCode.replaceAt( pEvent->ScriptCode.indexOf( sMacro ), sMacro.getLength(), sMacroName );
+                                    AttachMacro( *pEvent );
+                                }
+                            }
+                        }
+                    }    
+                }
+            }
+}
+#endif //ENABLE_VBA
+
 // ----------------------------------------------------------------------------
 
 XclExpOcxConverter::XclExpOcxConverter( const XclExpRoot& rRoot ) :
Index: sc/source/filter/excel/makefile.mk
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/makefile.mk,v
retrieving revision 1.34
diff -u -p -r1.34 makefile.mk
--- sc/source/filter/excel/makefile.mk	8 Sep 2005 18:58:26 -0000	1.34
+++ sc/source/filter/excel/makefile.mk	10 Mar 2006 17:55:38 -0000
@@ -50,6 +50,10 @@ PROJECTPCHSOURCE=..\pch\filt_pch
 .INCLUDE :  sc.mk
 .INCLUDE :  $(PRJ)$/util$/makefile.pmk
 
+.IF "$(ENABLE_VBA)"=="YES"
+        CDEFS+=-DENABLE_VBA
+.ENDIF
+
 # --- Files --------------------------------------------------------
 
 SLOFILES =	\
