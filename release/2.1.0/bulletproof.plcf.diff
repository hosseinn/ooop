Index: source/filter/ww8/ww8scan.cxx
===================================================================
RCS file: /cvs/sw/sw/source/filter/ww8/ww8scan.cxx,v
retrieving revision 1.129
diff -u -r1.129 ww8scan.cxx
--- openoffice.org.orig/sw/source/filter/ww8/ww8scan.cxx	27 Sep 2006 10:52:20 -0000	1.129
+++ openoffice.org/sw/source/filter/ww8/ww8scan.cxx	17 Dec 2006 15:14:05 -0000
@@ -815,7 +815,7 @@
 SprmInfo wwSprmParser::GetSprmInfo(sal_uInt16 nId) const
 {
     // Find sprm
-    SprmInfo aSrch={0};
+    SprmInfo aSrch={0,0,0};
     aSrch.nId = nId;
     const SprmInfo* pFound = mpKnownSprms->search(aSrch);
     if (pFound == 0)
@@ -2234,8 +2234,8 @@
 
 // Ctor fuer *andere* als Fkps
 // Bei nStartPos < 0 wird das erste Element des PLCFs genommen
-WW8PLCF::WW8PLCF( SvStream* pSt, long nFilePos, long nPLCF, long nStruct,
-    long nStartPos ) :nIdx( 0 ), nStru( nStruct )
+WW8PLCF::WW8PLCF( SvStream* pSt, WW8_FC nFilePos, INT32 nPLCF, int nStruct,
+    WW8_CP nStartPos ) : pPLCF_PosArray(0), nIdx(0), nStru(nStruct)
 {
     ASSERT( nPLCF, "WW8PLCF: nPLCF ist Null!" );
 
@@ -2252,12 +2252,13 @@
 // != 0, dann wird ein unvollstaendiger PLCF vervollstaendigt.  Das ist bei
 // WW6 bei Resourcenmangel und bei WordPad (W95) immer noetig.  Bei nStartPos
 // < 0 wird das erste Element des PLCFs genommen
-WW8PLCF::WW8PLCF( SvStream* pSt, long nFilePos, long nPLCF, long nStruct,
-    long nStartPos, long nPN, long ncpN ) :nIdx( 0 ), nStru( nStruct )
+WW8PLCF::WW8PLCF( SvStream* pSt, WW8_FC nFilePos, INT32 nPLCF, int nStruct,
+    WW8_CP nStartPos, INT32 nPN, INT32 ncpN ) : pPLCF_PosArray(0), nIdx(0), 
+    nStru(nStruct)
 {
     nIMax = ( nPLCF - 4 ) / ( 4 + nStruct );
 
-    if( nIMax >= (long) ncpN )
+    if( nIMax >= ncpN )
         ReadPLCF( pSt, nFilePos, nPLCF );
     else
         GeneratePLCF( pSt, nPN, ncpN );
@@ -2266,12 +2267,12 @@
         SeekPos( nStartPos );
 }
 
-void WW8PLCF::ReadPLCF( SvStream* pSt, long nFilePos, long nPLCF )
+void WW8PLCF::ReadPLCF( SvStream* pSt, WW8_FC nFilePos, INT32 nPLCF )
 {
     // Pointer auf Pos-Array
-    pPLCF_PosArray = new INT32[ ( nPLCF + 3 ) / 4 ];
+    pPLCF_PosArray = new WW8_CP[ ( nPLCF + 3 ) / 4 ];
 
-    long nOldPos = pSt->Tell();
+    sal_Size nOldPos = pSt->Tell();
 
     pSt->Seek( nFilePos );
     pSt->Read( pPLCF_PosArray, nPLCF );
@@ -2286,47 +2287,78 @@
     pSt->Seek( nOldPos );
 }
 
-void WW8PLCF::GeneratePLCF( SvStream* pSt, long nPN, long ncpN )
+void WW8PLCF::GeneratePLCF( SvStream* pSt, INT32 nPN, INT32 ncpN )
 {
-    ASSERT(!this, "Not a bug, but I (cmc) want to see this .doc as an example");
-    ASSERT( nIMax < (long)ncpN, "Pcl.Fkp: Warum ist PLCF zu gross ?" );
+    ASSERT( nIMax < ncpN, "Pcl.Fkp: Warum ist PLCF zu gross ?" );
+
+    bool failure = false;
     nIMax = ncpN;
-    long nSiz = 6 * nIMax + 4;
-    pPLCF_PosArray = new INT32[ ( nSiz + 3 ) / 4 ]; // Pointer auf Pos-Array
-    memset( pPLCF_PosArray, 0, (size_t)nSiz );
 
-    INT32 nFc;
-    USHORT i;
+    if ((nIMax < 1) || (nIMax > (WW8_CP_MAX - 4)/6) || ((nPN + ncpN) > USHRT_MAX))
+        failure = true;
+
+    if (!failure)
+    {
+        size_t nSiz = 6 * nIMax + 4;
+        size_t nElems = ( nSiz + 3 ) / 4;
+        pPLCF_PosArray = new INT32[ nElems ]; // Pointer auf Pos-Array
+
+        for (INT32 i = 0; i < ncpN && !pSt->GetError(); ++i)
+        {
+            // Baue FC-Eintraege
+            pSt->Seek( ( nPN + i ) << 9 );  // erster FC-Eintrag jedes Fkp
+            WW8_CP nFc;
+            *pSt >> nFc;
+            pPLCF_PosArray[i] = nFc;
+        }
+
+        failure = pSt->GetError();
+    }
 
-    for (i = 0; i < ncpN; ++i)
+    if (!failure)
     {
-        // Baue FC-Eintraege
-        pSt->Seek( ( nPN + i ) << 9 );  // erster FC-Eintrag jedes Fkp
+        sal_Size nLastFkpPos = ( ( nPN + nIMax - 1 ) << 9 );
+        pSt->Seek( nLastFkpPos + 511 );     // Anz. Fkp-Eintraege des letzten Fkp
+
+        BYTE nb;
+        *pSt >> nb;
+        pSt->Seek( nLastFkpPos + nb * 4 );  // letzer FC-Eintrag des letzten Fkp
+
+        WW8_CP nFc;
         *pSt >> nFc;
-        pPLCF_PosArray[i] = nFc;
+        pPLCF_PosArray[nIMax] = nFc;        // Ende des letzten Fkp
+
+        failure = pSt->GetError();
     }
-    ULONG nLastFkpPos = ( ( nPN + nIMax - 1 ) << 9 );
-    pSt->Seek( nLastFkpPos + 511 );     // Anz. Fkp-Eintraege des letzten Fkp
-    BYTE nb;
-    *pSt >> nb;
-    pSt->Seek( nLastFkpPos + nb * 4 );  // letzer FC-Eintrag des letzten Fkp
-    *pSt >> nFc;
-    pPLCF_PosArray[nIMax] = nFc;        // Ende des letzten Fkp
 
-    // Pointer auf Inhalts-Array
-    pPLCF_Contents = (BYTE*)&pPLCF_PosArray[nIMax + 1];
-    BYTE* p = pPLCF_Contents;
+    if (!failure)
+    {
+        // Pointer auf Inhalts-Array
+        pPLCF_Contents = (BYTE*)&pPLCF_PosArray[nIMax + 1];
+        BYTE* p = pPLCF_Contents;
+
+        for (INT32 i = 0; i < ncpN; ++i)         // Baue PNs
+        {
+            ShortToSVBT16(static_cast<sal_uInt16>(nPN + i), p);
+            p+=2;
+        }
+    }
 
-    for (i = 0; i < ncpN; ++i)         // Baue PNs
+    ASSERT( !failure, "Document has corrupt PLCF, ignoring it" );
+
+    if (failure)
     {
-        ShortToSVBT16(static_cast<sal_uInt16>(nPN + i), p);
-        p+=2;
+        nIMax = 0;
+        delete[] pPLCF_PosArray;
+        pPLCF_PosArray = new INT32[2];
+        pPLCF_PosArray[0] = pPLCF_PosArray[1] = WW8_CP_MAX;
+        pPLCF_Contents = (BYTE*)&pPLCF_PosArray[nIMax + 1];
     }
 }
 
-bool WW8PLCF::SeekPos(long nPos)
+bool WW8PLCF::SeekPos(WW8_CP nPos)
 {
-    long nP = nPos;
+    WW8_CP nP = nPos;
 
     if( nP < pPLCF_PosArray[0] )
     {
@@ -2339,8 +2371,8 @@
     if( (1 > nIdx) || (nP < pPLCF_PosArray[ nIdx-1 ]) )
         nIdx = 1;
 
-    long nI   = nIdx ? nIdx : 1;
-    long nEnd = nIMax;
+    INT32 nI   = nIdx ? nIdx : 1;
+    INT32 nEnd = nIMax;
 
     for(int n = (1==nIdx ? 1 : 2); n; --n )
     {
@@ -2373,10 +2405,10 @@
     return true;
 }
 
-INT32 WW8PLCF::Where() const
+WW8_CP WW8PLCF::Where() const
 {
     if ( nIdx >= nIMax )
-        return SAL_MAX_INT32;
+        return WW8_CP_MAX;
 
     return pPLCF_PosArray[nIdx];
 }
@@ -3842,13 +3874,12 @@
                 {
                     ww::bytes extraData;
                     sal_uInt8 iTmp;
-                    for(int i =0;i < nExtraLen;i++) 
+                    for(int j = 0; j < nExtraLen; ++j) 
                     {
                         rStrm >> iTmp;
                         extraData.push_back(iTmp);
                     }
                     pExtraArray->push_back(extraData);
-                    int kSize = extraData.size();
                 }
                 else
                     rStrm.SeekRel( nExtraLen );
Index: source/filter/ww8/ww8scan.hxx
===================================================================
RCS file: /cvs/sw/sw/source/filter/ww8/ww8scan.hxx,v
retrieving revision 1.77
diff -u -r1.77 ww8scan.hxx
--- openoffice.org.orig/sw/source/filter/ww8/ww8scan.hxx	16 Mar 2006 12:42:35 -0000	1.77
+++ openoffice.org/sw/source/filter/ww8/ww8scan.hxx	17 Dec 2006 15:14:06 -0000
@@ -295,39 +295,39 @@
 class WW8PLCF                       // Iterator fuer PLCFs
 {
 private:
-    INT32* pPLCF_PosArray;  // Pointer auf Pos-Array und auf ganze Struktur
-    BYTE* pPLCF_Contents;       // Pointer auf Inhalts-Array-Teil des Pos-Array
-    long nIMax;                         // Anzahl der Elemente
-    long nIdx;
-    long nStru;
+    WW8_CP* pPLCF_PosArray; // Pointer auf Pos-Array und auf ganze Struktur
+    BYTE* pPLCF_Contents;   // Pointer auf Inhalts-Array-Teil des Pos-Array
+    INT32 nIMax;            // Anzahl der Elemente
+    INT32 nIdx;
+    int nStru;
 
-    void ReadPLCF( SvStream* pSt, long nFilePos, long nPLCF );
+    void ReadPLCF( SvStream* pSt, WW8_FC nFilePos, INT32 nPLCF );
 
     /*
         Falls im Dok ein PLC fehlt und die FKPs solo dastehen,
         machen wir uns hiermit einen PLC:
     */
-    void GeneratePLCF( SvStream* pSt, long nPN, long ncpN );
+    void GeneratePLCF( SvStream* pSt, INT32 nPN, INT32 ncpN );
 public:
-    WW8PLCF( SvStream* pSt, long nFilePos, long nPLCF, long nStruct, 
-        long nStartPos = -1 );
+    WW8PLCF( SvStream* pSt, WW8_FC nFilePos, INT32 nPLCF, int nStruct, 
+        WW8_CP nStartPos = -1 );
 
     /*
         folgender Ctor generiert ggfs. einen PLC aus nPN und ncpN
     */
-    WW8PLCF( SvStream* pSt, long nFilePos, long nPLCF, long nStruct, 
-        long nStartPos, long nPN, long ncpN );
+    WW8PLCF( SvStream* pSt, WW8_FC nFilePos, INT32 nPLCF, int nStruct, 
+        WW8_CP nStartPos, INT32 nPN, INT32 ncpN );
 
     ~WW8PLCF(){ delete[] pPLCF_PosArray; }
-    long GetIdx() const { return nIdx; }
-    void SetIdx( long nI ) { nIdx = nI; }
-    long GetIMax() const { return nIMax; }
-    bool SeekPos(long nPos);
-    INT32 Where() const;
+    INT32 GetIdx() const { return nIdx; }
+    void SetIdx( INT32 nI ) { nIdx = nI; }
+    INT32 GetIMax() const { return nIMax; }
+    bool SeekPos(WW8_CP nPos);
+    WW8_CP Where() const;
     bool Get(WW8_CP& rStart, WW8_CP& rEnd, void*& rpValue) const;
     WW8PLCF& operator ++( int ) { if( nIdx < nIMax ) nIdx++; return *this; }
 
-    const void* GetData( long nInIdx ) const 
+    const void* GetData( INT32 nInIdx ) const 
     {
         return ( nInIdx >= nIMax ) ? 0 : 
             (const void*)&pPLCF_Contents[nInIdx * nStru]; 
