Index: basic/source/runtime/step2.cxx
===================================================================
RCS file: /cvs/script/basic/source/runtime/step2.cxx,v
retrieving revision 1.27
retrieving revision 1.27.46.2
diff -u -p -u -p -r1.27 -r1.27.46.2
--- basic/source/runtime/step2.cxx	3 Nov 2006 15:10:41 -0000	1.27
+++ basic/source/runtime/step2.cxx	21 Feb 2007 11:03:53 -0000	1.27.46.2
@@ -47,7 +47,9 @@
 
 #include <com/sun/star/container/XIndexAccess.hpp>
 #include <com/sun/star/script/XDefaultMethod.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
 #include <com/sun/star/uno/Any.hxx>
+#include <comphelper/processfactory.hxx>
 
 using namespace com::sun::star::container;
 using namespace com::sun::star::lang;
@@ -57,22 +59,25 @@ const static String aVBAHook( RTL_CONSTA
 //  i#i68894# 
 SbxArray* getVBAGlobals( StarBASIC* pSBasic )
 {
-	SbxVariableRef pThisComp = pSBasic->Find( aThisComponent, SbxCLASS_OBJECT );
 	static SbxArrayRef pArray;
 	static bool isInitialised = false;
 	if ( isInitialised )
 		return pArray;
-	
-	if (pThisComp && pThisComp->IsObject())
+	Reference < XComponentContext > xCtx;
+	Reference < XPropertySet > xProps(
+	::comphelper::getProcessServiceFactory(), UNO_QUERY_THROW );
+	xCtx.set( xProps->getPropertyValue( rtl::OUString( 
+		RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))), 
+			UNO_QUERY_THROW );
+	SbUnoObject dGlobs( String( RTL_CONSTASCII_USTRINGPARAM("ExcelGlobals") ), xCtx->getValueByName( ::rtl::OUString::createFromAscii( "/singletons/org.openoffice.vba.theGlobals") ) );
+
+	SbxVariable *vba = dGlobs.Find( String( RTL_CONSTASCII_USTRINGPARAM("getGlobals") ) , SbxCLASS_DONTCARE );
+
+	if ( vba )
 	{
-		SbxObject *pObj = static_cast<SbxObject *>(pThisComp->GetObject());
-		SbxVariable *vba = pObj->Find( aVBAHook, SbxCLASS_DONTCARE/* SbxCLASS_PROPERTY */ );
-		if ( vba && (vba->GetType() & SbxARRAY) )
-		{
-			pArray = static_cast<SbxArray *>(vba->GetObject());
-			isInitialised = true;
-			return pArray;
-		}
+		pArray = static_cast<SbxArray *>(vba->GetObject());
+		isInitialised = true;
+		return pArray;
 	}
 	return NULL;
 }
Index: config_office/configure.in
===================================================================
RCS file: /cvs/tools/config_office/configure.in,v
retrieving revision 1.196
retrieving revision 1.196.4.1
diff -u -p -u -p -r1.196 -r1.196.4.1
--- config_office/configure.in	23 Jan 2007 06:35:17 -0000	1.196
+++ config_office/configure.in	7 Feb 2007 16:34:17 -0000	1.196.4.1
@@ -40,6 +40,22 @@ AC_ARG_WITH(openldap,
 AC_ARG_ENABLE(lockdown,
 [  --enable-lockdown       Enables the gconf integration work in OOo
 ],,)
+AC_ARG_ENABLE(vba,
+[  --enable-vba           Enables the vba compatibility feature
+],,)
+AC_ARG_WITH(vba-package-format,
+[  --with-vba-package-format   specify package format for vba compatibility api.
+                          Default "builtin" means the api component and 
+                          associated type library are  part of the installation set.
+                          Specifying "extsn" creates an uno extension that is
+                          part of the installation set ( located in the program 
+                          directory ) that MUST be optionly registered using
+                          either the unopkg executeable or the extension manager
+                          gui.
+                          
+                          Usage: --with-package-format="builtin" or
+                                 --with-package-format="extsn"
+],,)              
 AC_ARG_ENABLE(pch,
 [  --enable-pch            Enables the use of precompiledr C/C++ header files
 ],,)
@@ -1579,6 +1595,45 @@ dnl ====================================
 if test "$_os" != "WINNT" -o "$WITH_MINGWIN" = "yes"; then
    AC_HEADER_STDC
 fi
+
+dnl ===================================================================
+dnl Check if we are to enable vba macro interoperability feature
+dnl ===================================================================
+AC_MSG_CHECKING([whether to enable vba feature])
+if test -n "$enable_vba" && test "$enable_vba" = "yes"; then
+   AC_MSG_RESULT([yes])
+   ENABLE_VBA=YES
+else
+   ENABLE_VBA=NO
+   AC_MSG_RESULT([no])
+fi
+AC_SUBST(ENABLE_VBA)
+
+if test "$ENABLE_VBA" = "YES"; then
+   AC_MSG_CHECKING([how to package the vba compatibility api])
+   if test -n "$with_vba_package_format"; then
+      if test "$with_vba_package_format" = "extn"; then
+         VBA_EXTENSION=YES
+         AC_MSG_RESULT([uno extension])
+      else if test "$with_vba_package_format" = "builtin"; then
+            VBA_EXTENSION=NO
+            AC_MSG_RESULT([build into installset])
+         else
+            AC_MSG_ERROR([unknown packaging method])
+         fi
+      fi
+ 
+   else
+      VBA_EXTENSION=NO
+      AC_MSG_RESULT([build into installset])
+   fi
+   AC_SUBST(VBA_EXTENSION)
+fi
+dnl ===================================================================
+dnl Check the whether vba need to be delivered as an uno package or part
+dnl of the install
+dnl ===================================================================
+
 
 dnl ===================================================================
 dnl Check if cups/cups.h is available 
Index: config_office/set_soenv.in
===================================================================
RCS file: /cvs/tools/config_office/set_soenv.in,v
retrieving revision 1.135
retrieving revision 1.135.4.1
diff -u -p -u -p -r1.135 -r1.135.4.1
--- config_office/set_soenv.in	25 Jan 2007 13:07:59 -0000	1.135
+++ config_office/set_soenv.in	7 Feb 2007 16:34:17 -0000	1.135.4.1
@@ -1483,6 +1483,8 @@ ToFile( "PREBUILD_MOZAB",    $PREBUILD_M
 ToFile( "MOZILLA_VERSION",   $MOZILLA_VERSION,   "e" );
 ToFile( "DEFAULT_MOZILLA_TOOLKIT", $MOZILLA_TOOLKIT, "e" );
 ToFile( "BUILD_VER_STRING",  "@BUILD_VER_STRING@", "e" );
+ToFile( "ENABLE_VBA",  "@ENABLE_VBA@", "e" );
+ToFile( "VBA_EXTENSION",  "@VBA_EXTENSION@", "e" );
 if ($platform =~ m/linux-gnu/ && $platform =~ m/powerpc/) {
 ToFile( "JITC_PROCESSOR_TYPE","6",                 "e" );
 }
Index: sc/inc/attrib.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/attrib.hxx,v
retrieving revision 1.7
retrieving revision 1.7.378.1
diff -u -p -u -p -r1.7 -r1.7.378.1
--- sc/inc/attrib.hxx	8 Sep 2005 17:23:08 -0000	1.7
+++ sc/inc/attrib.hxx	7 Feb 2007 21:25:31 -0000	1.7.378.1
@@ -113,7 +113,7 @@ public:
 
 //------------------------------------------------------------------------
 
-class ScMergeFlagAttr: public SfxInt16Item
+class SC_DLLPUBLIC ScMergeFlagAttr: public SfxInt16Item
 {
 public:
 			ScMergeFlagAttr();
Index: sc/inc/cellsuno.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/cellsuno.hxx,v
retrieving revision 1.26
retrieving revision 1.26.106.1
diff -u -p -u -p -r1.26 -r1.26.106.1
--- sc/inc/cellsuno.hxx	18 Oct 2006 12:15:54 -0000	1.26
+++ sc/inc/cellsuno.hxx	7 Feb 2007 21:29:10 -0000	1.26.106.1
@@ -260,7 +260,7 @@ public:
 						const SvxBoxItem& rOuter, const SvxBoxInfoItem& rInner );
 };
 
-class ScCellRangesBase : public com::sun::star::beans::XPropertySet,
+class SC_DLLPUBLIC ScCellRangesBase : public com::sun::star::beans::XPropertySet,
 						 public com::sun::star::beans::XMultiPropertySet,
 						 public com::sun::star::beans::XPropertyState,
 						 public com::sun::star::sheet::XSheetOperation,
@@ -583,7 +583,7 @@ public:
 };
 
 
-class ScCellRangesObj : public ScCellRangesBase,
+class SC_DLLPUBLIC ScCellRangesObj : public ScCellRangesBase,
 						public com::sun::star::sheet::XSheetCellRangeContainer,
 						public com::sun::star::container::XNameContainer,
 						public com::sun::star::container::XEnumerationAccess
@@ -691,7 +691,7 @@ public:
 };
 
 
-class ScCellRangeObj : public ScCellRangesBase,
+class SC_DLLPUBLIC ScCellRangeObj : public ScCellRangesBase,
 					   public com::sun::star::sheet::XCellRangeAddressable,
 					   public com::sun::star::sheet::XSheetCellRange,
 					   public com::sun::star::sheet::XArrayFormulaRange,
Index: sc/inc/compiler.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/compiler.hxx,v
retrieving revision 1.28
retrieving revision 1.28.14.1
diff -u -p -u -p -r1.28 -r1.28.14.1
--- sc/inc/compiler.hxx	22 Jan 2007 11:57:34 -0000	1.28
+++ sc/inc/compiler.hxx	7 Feb 2007 21:29:10 -0000	1.28.14.1
@@ -179,7 +179,7 @@ public:
 	void		IncRef()				{ nRefCnt++;	   }
 	void		DecRef()				{ if( !--nRefCnt ) Delete(); }
 	USHORT		GetRef() const			{ return nRefCnt; }
-	void		Delete();
+	SC_DLLPUBLIC void		Delete();
 
     // Use these methods only on tokens that are not part of a token array,
     // since the reference count is cleared!
@@ -224,7 +224,7 @@ struct ScStringHashCode
 typedef ::std::hash_map< String, OpCode, ScStringHashCode, ::std::equal_to< String > > ScOpCodeHashMap;
 
 using namespace ::com::sun::star::i18n;
-class ScCompiler
+class SC_DLLPUBLIC ScCompiler
 {
 public:
 	struct Convention
Index: sc/inc/dbcolect.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/dbcolect.hxx,v
retrieving revision 1.10
retrieving revision 1.10.370.1
diff -u -p -u -p -r1.10 -r1.10.370.1
--- sc/inc/dbcolect.hxx	28 Sep 2005 11:25:19 -0000	1.10
+++ sc/inc/dbcolect.hxx	7 Feb 2007 21:29:10 -0000	1.10.370.1
@@ -164,7 +164,7 @@ public:
 			void		GetName(String& rName) const	{ rName = aName; }
 			void		SetName(const String& rName)	{ aName = rName; }
 			void		GetArea(SCTAB& rTab, SCCOL& rCol1, SCROW& rRow1, SCCOL& rCol2, SCROW& rRow2) const;
-			void		GetArea(ScRange& rRange) const;
+			SC_DLLPUBLIC void		GetArea(ScRange& rRange) const;
 			void		SetArea(SCTAB nTab, SCCOL nCol1, SCROW nRow1, SCCOL nCol2, SCROW nRow2);
 			void		MoveTo(SCTAB nTab, SCCOL nCol1, SCROW nRow1, SCCOL nCol2, SCROW nRow2);
 			BOOL		IsByRow() const 				{ return bByRow; }
@@ -188,7 +188,7 @@ public:
 			void		GetSortParam(ScSortParam& rSortParam) const;
 			void		SetSortParam(const ScSortParam& rSortParam);
 
-			void		GetQueryParam(ScQueryParam& rQueryParam) const;
+			SC_DLLPUBLIC void		GetQueryParam(ScQueryParam& rQueryParam) const;
 			void		SetQueryParam(const ScQueryParam& rQueryParam);
 			BOOL		GetAdvancedQuerySource(ScRange& rSource) const;
 			void		SetAdvancedQuerySource(const ScRange* pSource);
Index: sc/inc/document.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/document.hxx,v
retrieving revision 1.97
retrieving revision 1.97.10.1
diff -u -p -u -p -r1.97 -r1.97.10.1
--- sc/inc/document.hxx	25 Jan 2007 11:03:02 -0000	1.97
+++ sc/inc/document.hxx	7 Feb 2007 21:29:10 -0000	1.97.10.1
@@ -553,7 +553,7 @@ SC_DLLPUBLIC	ScDBCollection*	GetDBCollec
 	void			SnapVisArea( Rectangle& rRect ) const;			// 1/100 mm
 
 	SC_DLLPUBLIC BOOL			ValidTabName( const String& rName ) const;
-    static void      ConvertToValidTabName( String& rName, sal_Unicode cReplaceChar );
+    static SC_DLLPUBLIC void      ConvertToValidTabName( String& rName, sal_Unicode cReplaceChar );
 	SC_DLLPUBLIC BOOL			ValidNewTabName( const String& rName ) const;
 	SC_DLLPUBLIC void			CreateValidTabName(String& rName) const;
 	BOOL			InsertTab( SCTAB nPos, const String& rName,
@@ -584,7 +584,7 @@ SC_DLLPUBLIC	ScDBCollection*	GetDBCollec
 	void			GetScenarioFlags( SCTAB nTab, USHORT& rFlags ) const;
 	BOOL			IsActiveScenario( SCTAB nTab ) const;
 	void			SetActiveScenario( SCTAB nTab, BOOL bActive );		// nur fuer Undo etc.
-	ScAddress::Convention GetAddressConvention() const;
+	SC_DLLPUBLIC ScAddress::Convention GetAddressConvention() const;
 	void	 	    SetAddressConvention( ScAddress::Convention eConv );
 	BYTE			GetLinkMode( SCTAB nTab ) const;
 	BOOL			IsLinked( SCTAB nTab ) const;
@@ -1012,7 +1012,7 @@ SC_DLLPUBLIC	ScDBCollection*	GetDBCollec
 											const ScAddress& rCursor, const ScMarkData& rMark,
 											double& rResult );
 
-	const SfxPoolItem* 		GetAttr( SCCOL nCol, SCROW nRow, SCTAB nTab, USHORT nWhich ) const;
+	SC_DLLPUBLIC const SfxPoolItem* 		GetAttr( SCCOL nCol, SCROW nRow, SCTAB nTab, USHORT nWhich ) const;
 	const ScPatternAttr*	GetPattern( SCCOL nCol, SCROW nRow, SCTAB nTab ) const;
     const ScPatternAttr*    GetMostUsedPattern( SCCOL nCol, SCROW nStartRow, SCROW nEndRow, SCTAB nTab ) const;
 	const ScPatternAttr*	GetSelectionPattern( const ScMarkData& rMark, BOOL bDeep = TRUE );
@@ -1067,7 +1067,7 @@ SC_DLLPUBLIC	ScDBCollection*	GetDBCollec
 	ScValidationDataList* GetValidationList() const
 					{ return pValidationList; }
 
-	void			ApplyAttr( SCCOL nCol, SCROW nRow, SCTAB nTab,
+	SC_DLLPUBLIC void			ApplyAttr( SCCOL nCol, SCROW nRow, SCTAB nTab,
 								const SfxPoolItem& rAttr );
 	void			ApplyPattern( SCCOL nCol, SCROW nRow, SCTAB nTab,
 									const ScPatternAttr& rAttr );
@@ -1160,8 +1160,8 @@ SC_DLLPUBLIC	ScDBCollection*	GetDBCollec
 	ULONG			GetColOffset( SCCOL nCol, SCTAB nTab ) const;
 	ULONG			GetRowOffset( SCROW nRow, SCTAB nTab ) const;
 
-	USHORT			GetOriginalWidth( SCCOL nCol, SCTAB nTab ) const;
-	USHORT			GetOriginalHeight( SCROW nRow, SCTAB nTab ) const;
+	SC_DLLPUBLIC USHORT			GetOriginalWidth( SCCOL nCol, SCTAB nTab ) const;
+	SC_DLLPUBLIC USHORT			GetOriginalHeight( SCROW nRow, SCTAB nTab ) const;
 
 	USHORT			GetCommonWidth( SCCOL nEndCol, SCTAB nTab ) const;
 
@@ -1207,8 +1207,8 @@ SC_DLLPUBLIC	ScDBCollection*	GetDBCollec
 	void			SetRowFlags( SCROW nRow, SCTAB nTab, BYTE nNewFlags );
 	void			SetRowFlags( SCROW nStartRow, SCROW nEndRow, SCTAB nTab, BYTE nNewFlags );
 
-	BYTE			GetColFlags( SCCOL nCol, SCTAB nTab ) const;
-	BYTE			GetRowFlags( SCROW nRow, SCTAB nTab ) const;
+	SC_DLLPUBLIC BYTE			GetColFlags( SCCOL nCol, SCTAB nTab ) const;
+	SC_DLLPUBLIC BYTE			GetRowFlags( SCROW nRow, SCTAB nTab ) const;
 
     const ScBitMaskCompressedArray< SCROW, BYTE> & GetRowFlagsArray( SCTAB nTab ) const;
           ScBitMaskCompressedArray< SCROW, BYTE> & GetRowFlagsArrayModifiable( SCTAB nTab );
@@ -1343,9 +1343,9 @@ SC_DLLPUBLIC	SvNumberFormatter*	GetForma
 
 	BOOL			HasAutoFilter( SCCOL nCol, SCROW nRow, SCTAB nTab );
 
-	BOOL			HasColHeader( SCCOL nStartCol, SCROW nStartRow, SCCOL nEndCol, SCROW nEndRow,
+	SC_DLLPUBLIC BOOL			HasColHeader( SCCOL nStartCol, SCROW nStartRow, SCCOL nEndCol, SCROW nEndRow,
 									SCTAB nTab );
-	BOOL			HasRowHeader( SCCOL nStartCol, SCROW nStartRow, SCCOL nEndCol, SCROW nEndRow,
+	SC_DLLPUBLIC BOOL			HasRowHeader( SCCOL nStartCol, SCROW nStartRow, SCCOL nEndCol, SCROW nEndRow,
 									SCTAB nTab );
 
 	SfxPrinter*		GetPrinter( BOOL bCreateIfNotExist = TRUE );
Index: sc/inc/docuno.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/docuno.hxx,v
retrieving revision 1.22
retrieving revision 1.22.338.1
diff -u -p -u -p -r1.22 -r1.22.338.1
--- sc/inc/docuno.hxx	10 Nov 2005 16:36:27 -0000	1.22
+++ sc/inc/docuno.hxx	7 Feb 2007 21:29:10 -0000	1.22.338.1
@@ -141,7 +141,7 @@ class ScTableSheetObj;
 class SvxFmDrawPage;
 class SvxDrawPage;
 
-class ScModelObj : public SfxBaseModel,
+class SC_DLLPUBLIC ScModelObj : public SfxBaseModel,
 					public com::sun::star::sheet::XSpreadsheetDocument,
 					public com::sun::star::document::XActionLockable,
 					public com::sun::star::sheet::XCalculatable,
Index: sc/inc/global.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/global.hxx,v
retrieving revision 1.47
retrieving revision 1.47.52.1
diff -u -p -u -p -r1.47 -r1.47.52.1
--- sc/inc/global.hxx	19 Dec 2006 18:00:23 -0000	1.47
+++ sc/inc/global.hxx	7 Feb 2007 21:29:10 -0000	1.47.52.1
@@ -579,8 +579,8 @@ SC_DLLPUBLIC	static ::utl::Transliterati
 
 	static const String&	 	GetClipDocName();
 	static void 			 	SetClipDocName( const String& rNew );
-	static const SvxSearchItem&	GetSearchItem();
-	static void					SetSearchItem( const SvxSearchItem& rNew );
+	static SC_DLLPUBLIC const SvxSearchItem&	GetSearchItem();
+	static SC_DLLPUBLIC void					SetSearchItem( const SvxSearchItem& rNew );
 SC_DLLPUBLIC	static ScAutoFormat*		GetAutoFormat();
 	static void					ClearAutoFormat(); //BugId 54209
 	static FuncCollection*		GetFuncCollection();
Index: sc/inc/rangelst.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/rangelst.hxx,v
retrieving revision 1.6
retrieving revision 1.6.108.2
diff -u -p -u -p -r1.6 -r1.6.108.2
--- sc/inc/rangelst.hxx	18 Oct 2006 12:17:40 -0000	1.6
+++ sc/inc/rangelst.hxx	8 Feb 2007 09:24:14 -0000	1.6.108.2
@@ -51,7 +51,7 @@ class ScDocument;
 
 typedef ScRange* ScRangePtr;
 DECLARE_LIST( ScRangeListBase, ScRangePtr );
-class ScRangeList : public ScRangeListBase, public SvRefBase
+class SC_DLLPUBLIC ScRangeList : public ScRangeListBase, public SvRefBase
 {
 public:
 					ScRangeList() {}
Index: sc/inc/scmod.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/scmod.hxx,v
retrieving revision 1.20
retrieving revision 1.20.150.1
diff -u -p -u -p -r1.20 -r1.20.150.1
--- sc/inc/scmod.hxx	4 Aug 2006 12:11:26 -0000	1.20
+++ sc/inc/scmod.hxx	7 Feb 2007 21:29:11 -0000	1.20.150.1
@@ -252,7 +252,7 @@ SC_DLLPUBLIC	void					SetAppOptions	( co
 	BOOL                IsInputMode();	// auch bei SC_INPUT_TYPE
 	void                SetInputMode( ScInputMode eMode );
 	BOOL                InputKeyEvent( const KeyEvent& rKEvt, BOOL bStartEdit = FALSE );
-	void                InputEnterHandler( BYTE nBlockMode = 0 );
+	SC_DLLPUBLIC void                InputEnterHandler( BYTE nBlockMode = 0 );
 	void                InputCancelHandler();
 	void                InputSelection( EditView* pView );
 	void                InputChanged( EditView* pView );
Index: sc/prj/build.lst
===================================================================
RCS file: /cvs/sc/sc/prj/build.lst,v
retrieving revision 1.13
retrieving revision 1.13.88.2
diff -u -p -u -p -r1.13 -r1.13.88.2
--- sc/prj/build.lst	30 Oct 2006 09:21:09 -0000	1.13
+++ sc/prj/build.lst	28 Feb 2007 14:29:58 -0000	1.13.88.2
@@ -1,4 +1,4 @@
-sc	sc	:	svx stoc uui BOOST:boost sch NULL
+sc	sc	:	oovbaapi svx stoc uui BOOST:boost sch NULL
 sc	sc										usr1	-	all	sc_mkout NULL
 sc	sc\inc									nmake	-	all	sc_inc NULL
 sc	sc\prj									get		-	all	sc_prj NULL
@@ -29,6 +29,7 @@ sc	sc\source\ui\src						nmake	-	all	sc_
 sc	sc\source\ui\styleui					nmake	-	all	sc_style sc_sdi sc_inc NULL
 sc	sc\source\ui\undo						nmake	-	all	sc_undo sc_sdi sc_inc NULL
 sc	sc\source\ui\unoobj						nmake	-	all	sc_unobj sc_sdi sc_inc NULL
+sc      sc\source\ui\vba                                                nmake -       all     sc_vba sc_sdi sc_view sc_inc NULL
 sc	sc\source\core\data						nmake	-	all	sc_data sc_sdi sc_inc NULL
 sc	sc\source\core\src						nmake	-	all	sc_cosrc sc_sdi sc_inc NULL
 sc	sc\source\core\tool						nmake	-	all	sc_tool sc_sdi sc_inc NULL
@@ -45,4 +46,4 @@ sc	sc\source\filter\xcl97					nmake	-	al
 sc	sc\addin\datefunc						nmake	-	all	sc_addfu sc_sdi sc_inc NULL
 sc	sc\addin\rot13							nmake	-	all	sc_adrot sc_sdi sc_inc NULL
 sc	sc\addin\util							nmake	-	all	sc_adutil sc_addfu sc_adrot sc_sdi sc_inc NULL
-sc      sc\util                                                                 nmake   -       all     sc_util sc_addfu sc_adrot sc_adutil sc_app sc_attr sc_cctrl sc_cosrc sc_data sc_dbgui sc_dif sc_docsh sc_drfnc sc_excel sc_form sc_html sc_lotus sc_qpro sc_misc sc_name sc_nvipi sc_opt sc_page sc_rtf sc_scalc sc_style sc_tool sc_uisrc sc_undo sc_unobj sc_view sc_xcl97 sc_xml sc_acc sc_ftools sc_inc NULL
+sc      sc\util                                                                 nmake   -       all     sc_util sc_addfu sc_adrot sc_adutil sc_app sc_attr sc_cctrl sc_cosrc sc_data sc_dbgui sc_dif sc_docsh sc_drfnc sc_excel sc_form sc_html sc_lotus sc_qpro sc_misc sc_name sc_nvipi sc_opt sc_page sc_rtf sc_scalc sc_style sc_tool sc_uisrc sc_undo sc_unobj sc_view sc_xcl97 sc_xml sc_acc sc_ftools sc_inc sc_vba NULL
Index: sc/prj/d.lst
===================================================================
RCS file: /cvs/sc/sc/prj/d.lst,v
retrieving revision 1.23
retrieving revision 1.23.104.2
diff -u -p -u -p -r1.23 -r1.23.104.2
--- sc/prj/d.lst	24 Oct 2006 13:38:02 -0000	1.23
+++ sc/prj/d.lst	8 Feb 2007 14:35:42 -0000	1.23.104.2
@@ -23,10 +23,12 @@ mkdir: %_DEST%\xml%_EXT%\uiconfig\module
 ..\%__SRC%\bin\scui?????.dll %_DEST%\bin%_EXT%\scui?????.dll
 ..\%__SRC%\bin\dfa?????.dll %_DEST%\bin%_EXT%\dfa?????.dll
 ..\%__SRC%\bin\rot?????.dll %_DEST%\bin%_EXT%\rot?????.dll
+..\%__SRC%\bin\vba*.* %_DEST%\bin%_EXT%\vba*.*
 ..\%__SRC%\bin\addin.zip %_DEST%\bin%_EXT%\addin.zip
 ..\%__SRC%\misc\*.map %_DEST%\bin%_EXT%\*.map
 ..\%__SRC%\misc\sc.csv %_DEST%\inc%_EXT%\sc.csv
 ..\%__SRC%\lib\sci.lib %_DEST%\lib%_EXT%\sci.lib
+..\%__SRC%\lib\vba*.* %_DEST%\lib%_EXT%\vba*.*
 ..\%__SRC%\slb\lib*.* %_DEST%\lib%_EXT%\lib*.*
 ..\%__SRC%\lib\lib*.* %_DEST%\lib%_EXT%\lib*.*
 ..\xml\*.xml %_DEST%\xml%_EXT%\*.xml
Index: sc/source/ui/inc/dbdocfun.hxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/inc/dbdocfun.hxx,v
retrieving revision 1.8
retrieving revision 1.8.380.1
diff -u -p -u -p -r1.8 -r1.8.380.1
--- sc/source/ui/inc/dbdocfun.hxx	8 Sep 2005 21:19:34 -0000	1.8
+++ sc/source/ui/inc/dbdocfun.hxx	7 Feb 2007 21:29:11 -0000	1.8.380.1
@@ -117,7 +117,7 @@ public:
 	BOOL			Sort( SCTAB nTab, const ScSortParam& rSortParam,
 							BOOL bRecord, BOOL bPaint, BOOL bApi );
 
-	BOOL			Query( SCTAB nTab, const ScQueryParam& rQueryParam,
+	SC_DLLPUBLIC BOOL			Query( SCTAB nTab, const ScQueryParam& rQueryParam,
 							const ScRange* pAdvSource, BOOL bRecord, BOOL bApi );
 
 	BOOL			DoSubTotals( SCTAB nTab, const ScSubTotalParam& rParam,
Index: sc/source/ui/inc/docfunc.hxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/inc/docfunc.hxx,v
retrieving revision 1.14
retrieving revision 1.14.108.1
diff -u -p -u -p -r1.14 -r1.14.108.1
--- sc/source/ui/inc/docfunc.hxx	18 Oct 2006 12:27:37 -0000	1.14
+++ sc/source/ui/inc/docfunc.hxx	7 Feb 2007 21:29:11 -0000	1.14.108.1
@@ -129,7 +129,7 @@ public:
 
 	BOOL	 	    SetAddressConvention( ScAddress::Convention eConv );
 
-	BOOL			SetWidthOrHeight( BOOL bWidth, SCCOLROW nRangeCnt, SCCOLROW* pRanges,
+	SC_DLLPUBLIC BOOL			SetWidthOrHeight( BOOL bWidth, SCCOLROW nRangeCnt, SCCOLROW* pRanges,
 									SCTAB nTab, ScSizeMode eMode, USHORT nSizeTwips,
 									BOOL bRecord, BOOL bApi );
 
Index: sc/source/ui/inc/docsh.hxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/inc/docsh.hxx,v
retrieving revision 1.39
retrieving revision 1.39.10.1
diff -u -p -u -p -r1.39 -r1.39.10.1
--- sc/source/ui/inc/docsh.hxx	25 Jan 2007 11:41:21 -0000	1.39
+++ sc/source/ui/inc/docsh.hxx	7 Feb 2007 21:29:11 -0000	1.39.10.1
@@ -425,7 +425,7 @@ SO2_IMPL_REF(ScDocShell)
 // SetDocumentModified hierdran aufrufen statt an der ScDocShell.
 // Im Dtor wird wenn ScDocShell bDocumentModifiedPending gesetzt ist und
 // bAutoCalcShellDisabled nicht gesetzt ist ein SetDocumentModified gerufen.
-class ScDocShellModificator
+class SC_DLLPUBLIC ScDocShellModificator
 {
 			ScDocShell&		rDocShell;
 	ScRefreshTimerProtector	aProtector;
Index: sc/source/ui/inc/tabview.hxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/inc/tabview.hxx,v
retrieving revision 1.22
retrieving revision 1.22.50.1
diff -u -p -u -p -r1.22 -r1.22.50.1
--- sc/source/ui/inc/tabview.hxx	19 Dec 2006 14:06:43 -0000	1.22
+++ sc/source/ui/inc/tabview.hxx	7 Feb 2007 21:29:11 -0000	1.22.50.1
@@ -339,9 +339,9 @@ public:
 
 	void			ClickCursor( SCCOL nPosX, SCROW nPosY, BOOL bControl );
 
-	void			SetCursor( SCCOL nPosX, SCROW nPosY, BOOL bNew = FALSE );
+	SC_DLLPUBLIC void			SetCursor( SCCOL nPosX, SCROW nPosY, BOOL bNew = FALSE );
 
-	void			CellContentChanged();
+	SC_DLLPUBLIC void			CellContentChanged();
 	void			SelectionChanged();
 	void			CursorPosChanged();
 	void			UpdateInputContext();
@@ -378,7 +378,7 @@ public:
 					//	MoveCursorArea		- Datenblock
 					//	MoveCursorEnd		- links oben / benutzter Bereich
 
-	void			MoveCursorAbs( SCsCOL nCurX, SCsROW nCurY, ScFollowMode eMode,
+	SC_DLLPUBLIC void			MoveCursorAbs( SCsCOL nCurX, SCsROW nCurY, ScFollowMode eMode,
 									BOOL bShift, BOOL bControl,
 									BOOL bKeepOld = FALSE, BOOL bKeepSel = FALSE );
 	void			MoveCursorRel( SCsCOL nMovX, SCsROW nMovY, ScFollowMode eMode,
@@ -411,7 +411,7 @@ public:
 
 	void 			ScrollX( long nDeltaX, ScHSplitPos eWhich, BOOL bUpdBars = TRUE );
 	void 			ScrollY( long nDeltaY, ScVSplitPos eWhich, BOOL bUpdBars = TRUE );
-	void			ScrollLines( long nDeltaX, long nDeltaY );				// aktives
+	SC_DLLPUBLIC void			ScrollLines( long nDeltaX, long nDeltaY );				// aktives
 
 	BOOL			ScrollCommand( const CommandEvent& rCEvt, ScSplitPos ePos );
 
Index: sc/source/ui/inc/transobj.hxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/inc/transobj.hxx,v
retrieving revision 1.14
retrieving revision 1.14.380.1
diff -u -p -u -p -r1.14 -r1.14.380.1
--- sc/source/ui/inc/transobj.hxx	8 Sep 2005 22:01:04 -0000	1.14
+++ sc/source/ui/inc/transobj.hxx	7 Feb 2007 21:29:12 -0000	1.14.380.1
@@ -122,7 +122,7 @@ public:
 	void				SetDragSourceFlags( USHORT nFlags );
 	void				SetDragWasInternal();
 
-	static ScTransferObj* GetOwnClipboard( Window* pUIWin );
+	static SC_DLLPUBLIC ScTransferObj* GetOwnClipboard( Window* pUIWin );
 
 	static SfxObjectShell*	SetDrawClipDoc( BOOL bAnyOle );		// update ScGlobal::pDrawClipDocShellRef
 };
Index: sc/source/ui/inc/viewfunc.hxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/inc/viewfunc.hxx,v
retrieving revision 1.29
retrieving revision 1.29.110.1
diff -u -p -u -p -r1.29 -r1.29.110.1
--- sc/source/ui/inc/viewfunc.hxx	13 Oct 2006 11:36:33 -0000	1.29
+++ sc/source/ui/inc/viewfunc.hxx	7 Feb 2007 21:29:12 -0000	1.29.110.1
@@ -117,10 +117,10 @@ public:
 
 	void			EnterDataAtCursor( const String& rString );			//! nicht benutzt ?
 
-	void			CutToClip( ScDocument* pClipDoc = NULL, BOOL bIncludeObjects = FALSE );
-	BOOL			CopyToClip( ScDocument* pClipDoc = NULL, BOOL bCut = FALSE, BOOL bApi = FALSE,
+	SC_DLLPUBLIC void			CutToClip( ScDocument* pClipDoc = NULL, BOOL bIncludeObjects = FALSE );
+	SC_DLLPUBLIC BOOL			CopyToClip( ScDocument* pClipDoc = NULL, BOOL bCut = FALSE, BOOL bApi = FALSE,
 								BOOL bIncludeObjects = FALSE, BOOL bStopEdit = TRUE );
-	BOOL			PasteFromClip( USHORT nFlags, ScDocument* pClipDoc,
+	SC_DLLPUBLIC BOOL			PasteFromClip( USHORT nFlags, ScDocument* pClipDoc,
 									USHORT nFunction = PASTE_NOFUNC, BOOL bSkipEmpty = FALSE,
 									BOOL bTranspose = FALSE, BOOL bAsLink = FALSE,
 									InsCellCmd eMoveMode = INS_NONE,
@@ -129,8 +129,8 @@ public:
 
 	void			FillTab( USHORT nFlags, USHORT nFunction, BOOL bSkipEmpty, BOOL bAsLink );
 
-	void			PasteFromSystem();
-	BOOL			PasteFromSystem( ULONG nFormatId, BOOL bApi = FALSE );
+	SC_DLLPUBLIC void			PasteFromSystem();
+	SC_DLLPUBLIC BOOL			PasteFromSystem( ULONG nFormatId, BOOL bApi = FALSE );
 
 	void			PasteDraw();
 	void			PasteDraw( const Point& rLogicPos, SdrModel* pModel,
@@ -228,10 +228,10 @@ public:
 
 	void			ModifyCellSize( ScDirection eDir, BOOL bOptimal );
 
-	void			InsertPageBreak( BOOL bColumn, BOOL bRecord = TRUE,
+	SC_DLLPUBLIC void			InsertPageBreak( BOOL bColumn, BOOL bRecord = TRUE,
 										const ScAddress* pPos = NULL,
 										BOOL bSetModified = TRUE );
-	void			DeletePageBreak( BOOL bColumn, BOOL bRecord = TRUE,
+	SC_DLLPUBLIC void			DeletePageBreak( BOOL bColumn, BOOL bRecord = TRUE,
 										const ScAddress* pPos = NULL,
 										BOOL bSetModified = TRUE );
 
Index: sc/source/ui/vba/makefile.mk
===================================================================
RCS file: sc/source/ui/vba/makefile.mk
diff -N sc/source/ui/vba/makefile.mk
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/makefile.mk	7 Feb 2007 21:17:46 -0000	1.1.2.1
@@ -0,0 +1,67 @@
+PRJ=../..$/..
+
+PRJNAME=
+TARGET=vbaobj
+.IF "$(ENABLE_VBA)"!="YES"
+dummy:
+        @echo "not building vba..."
+.ENDIF
+
+
+NO_BSYMBOLIC=   TRUE
+ENABLE_EXCEPTIONS=TRUE
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :  settings.mk
+.INCLUDE :  sv.mk
+DLLPRE =
+
+ALLTAR : \
+        $(MISC)$/$(TARGET).don \
+        $(SLOTARGET)
+
+$(MISC)$/$(TARGET).don : $(SOLARBINDIR)$/oovbaapi.rdb
+        +$(CPPUMAKER) -O$(OUT)$/inc -BUCR $(SOLARBINDIR)$/oovbaapi.rdb -X$(SOLARBINDIR)$/types.rdb && echo > $@
+        echo $@
+
+# ------------------------------------------------------------------
+
+SLOFILES= \
+		$(SLO)$/vbaglobals.obj \
+		$(SLO)$/vbaworkbook.obj \
+		$(SLO)$/vbaworksheets.obj \
+		$(SLO)$/vbaapplication.obj \
+		$(SLO)$/vbarange.obj \
+		$(SLO)$/vbacomment.obj \
+		$(SLO)$/vbacomments.obj \
+		$(SLO)$/vbaworkbooks.obj \
+		$(SLO)$/vbaworksheet.obj \
+		$(SLO)$/vbaoutline.obj \
+		$(SLO)$/vbafont.obj\
+		$(SLO)$/vbahelper.obj\
+		$(SLO)$/vbainterior.obj\
+		$(SLO)$/vbawsfunction.obj\
+		$(SLO)$/vbawindow.obj\
+		$(SLO)$/vbachart.obj\
+		$(SLO)$/vbachartobject.obj\
+		$(SLO)$/vbachartobjects.obj\
+		$(SLO)$/vbaseriescollection.obj\
+		$(SLO)$/vbacollectionimpl.obj\
+		$(SLO)$/vbadialogs.obj \
+		$(SLO)$/vbadialog.obj	\
+		$(SLO)$/vbapivottable.obj \
+		$(SLO)$/vbapivotcache.obj \
+		$(SLO)$/vbapivottables.obj \
+		$(SLO)$/vbawindows.obj \
+		$(SLO)$/vbapalette.obj \
+		$(SLO)$/vbaborders.obj \
+		$(SLO)$/vbacharacters.obj \
+		$(SLO)$/vbacombobox.obj \
+		$(SLO)$/vbavalidation.obj \
+		$(SLO)$/service.obj
+ 
+
+# --- Targets ------------------------------------------------------
+
+.INCLUDE :	target.mk
Index: sc/source/ui/vba/service.cxx
===================================================================
RCS file: sc/source/ui/vba/service.cxx
diff -N sc/source/ui/vba/service.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/service.cxx	27 Feb 2007 23:29:39 -0000	1.1.2.4
@@ -0,0 +1,122 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "cppuhelper/implementationentry.hxx"
+#include "com/sun/star/lang/XMultiServiceFactory.hpp"
+#include "com/sun/star/registry/XRegistryKey.hpp"
+
+// =============================================================================
+// component exports
+// =============================================================================
+using namespace ::com::sun::star;
+using namespace ::com::sun::star::uno;
+
+namespace vbaobj
+{
+    // =============================================================================
+    // component operations
+    // =============================================================================
+
+    uno::Reference< XInterface > SAL_CALL create(
+        Reference< XComponentContext > const & xContext )
+        SAL_THROW( () );
+
+    // -----------------------------------------------------------------------------
+
+    ::rtl::OUString SAL_CALL getImplementationName();
+
+	Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames();
+
+//	Reference<XInterface> SAL_CALL create(
+//		Sequence<Any> const &, Reference<XComponentContext> const & );
+} // end namespace vbaobj
+
+
+    // =============================================================================
+
+    const ::cppu::ImplementationEntry s_component_entries [] =
+    {
+        {
+            ::vbaobj::create, ::vbaobj::getImplementationName,
+            ::vbaobj::getSupportedServiceNames, 
+		::cppu::createSingleComponentFactory,
+            0, 0
+        },
+        { 0, 0, 0, 0, 0, 0 }
+    };
+
+extern "C"
+{
+    void SAL_CALL component_getImplementationEnvironment( 
+        const sal_Char ** ppEnvTypeName, uno_Environment ** /*ppEnv*/ )
+    {
+		OSL_TRACE("In component_getImplementationEnv");
+        *ppEnvTypeName = CPPU_CURRENT_LANGUAGE_BINDING_NAME;
+    }
+
+    sal_Bool SAL_CALL component_writeInfo( 
+        lang::XMultiServiceFactory * pServiceManager, registry::XRegistryKey * pRegistryKey )
+    {
+		OSL_TRACE("In component_writeInfo");
+        if ( ::cppu::component_writeInfoHelper(
+            pServiceManager, pRegistryKey, s_component_entries ) )
+		{
+			try
+			{
+				registry::XRegistryKey * pKey =
+					reinterpret_cast< registry::XRegistryKey * >(pRegistryKey);
+
+				Reference< registry::XRegistryKey >xKey = pKey->createKey(
+					rtl::OUString::createFromAscii( ("org.openoffice.vba.Globals/UNO/SINGLETONS/org.openoffice.vba.theGlobals") ) );
+				xKey->setStringValue( ::rtl::OUString::createFromAscii( 
+					("org.openoffice.vba.Globals") ) );
+				return sal_True;
+			}
+			catch( uno::Exception& /*e*/ )
+			{
+				//recomp & friends will detect false returned and fail
+			}
+		}
+		return sal_False;
+    }
+
+    void * SAL_CALL component_getFactory( 
+        const sal_Char * pImplName, lang::XMultiServiceFactory * pServiceManager,
+        registry::XRegistryKey * pRegistryKey )
+    {
+		OSL_TRACE("In component_getFactory");
+        return ::cppu::component_getFactoryHelper( 
+            pImplName, pServiceManager, pRegistryKey, s_component_entries );
+    }
+}
Index: sc/source/ui/vba/vbaapplication.cxx
===================================================================
RCS file: sc/source/ui/vba/vbaapplication.cxx
diff -N sc/source/ui/vba/vbaapplication.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbaapplication.cxx	21 Feb 2007 17:29:15 -0000	1.1.2.2
@@ -0,0 +1,582 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include <stdio.h>
+
+
+#include<com/sun/star/sheet/XSpreadsheetView.hpp>
+#include <com/sun/star/sheet/XSpreadsheets.hpp>
+#include<com/sun/star/view/XSelectionSupplier.hpp>
+#include<org/openoffice/excel/XlCalculation.hpp>
+#include <com/sun/star/sheet/XCellRangeReferrer.hpp>
+#include <com/sun/star/frame/XLayoutManager.hpp>
+#include <com/sun/star/task/XStatusIndicatorSupplier.hpp>
+#include <com/sun/star/task/XStatusIndicator.hpp>
+#include <org/openoffice/excel/XlMousePointer.hpp>
+
+#include "vbaapplication.hxx"
+#include "vbaworkbooks.hxx"
+#include "vbaworkbook.hxx"
+#include "vbaworksheets.hxx"
+#include "vbarange.hxx"
+#include "vbawsfunction.hxx"
+#include "vbadialogs.hxx"
+#include "vbawindow.hxx"
+#include "vbawindows.hxx"
+#include "vbaglobals.hxx"
+#include "tabvwsh.hxx"
+#include "gridwin.hxx"
+
+//start test includes
+#include <sfx2/objsh.hxx>
+#include <sfx2/viewfrm.hxx>
+#include <sfx2/app.hxx>
+
+#include <toolkit/awt/vclxwindow.hxx>
+#include <toolkit/helper/vclunohelper.hxx>
+
+#include <docuno.hxx>
+
+#include <basic/sbx.hxx>
+#include <basic/sbstar.hxx>
+#include <basic/sbuno.hxx>
+#include <basic/sbmeth.hxx>
+//end test includes
+
+using namespace ::org::openoffice;
+using namespace ::com::sun::star;
+
+#define EXCELVERSION "11.0"
+
+class ActiveWorkbook : public ScVbaWorkbook
+{
+protected:
+	virtual uno::Reference< frame::XModel > getModel()
+	{ 	
+		return getCurrentDocument(); 
+	}
+public:
+	ActiveWorkbook( uno::Reference< uno::XComponentContext >& xContext) : ScVbaWorkbook(  xContext ){}
+};
+
+ScVbaApplication::ScVbaApplication( uno::Reference<uno::XComponentContext >& xContext ): m_xContext( xContext ), m_xCalculation( excel::XlCalculation::xlCalculationAutomatic )
+{
+}
+
+ScVbaApplication::~ScVbaApplication()
+{
+}
+
+
+uno::Reference< excel::XWorkbook >
+ScVbaApplication::getActiveWorkbook() throw (uno::RuntimeException)
+{
+	return new ActiveWorkbook( m_xContext ); 
+}
+uno::Reference< excel::XWorkbook > SAL_CALL 
+ScVbaApplication::getThisWorkbook() throw (uno::RuntimeException)
+{
+	return getActiveWorkbook();
+}
+
+uno::Reference< excel::XRange >
+ScVbaApplication::getSelection() throw (uno::RuntimeException)
+{
+	uno::Reference< table::XCellRange > xRange( getCurrentDocument()->getCurrentSelection(), ::uno::UNO_QUERY);
+	if ( !xRange.is() )
+	{
+		uno::Reference< sheet::XSheetCellRangeContainer > xRanges( getCurrentDocument()->getCurrentSelection(), ::uno::UNO_QUERY);
+		if ( xRanges.is() )
+			return uno::Reference< excel::XRange >( new ScVbaRange( m_xContext, xRanges ) );
+
+	}
+	return uno::Reference< excel::XRange >( new ScVbaRange( m_xContext, xRange ) );
+}
+
+uno::Reference< excel::XRange >
+ScVbaApplication::getActiveCell() throw (uno::RuntimeException )
+{
+	uno::Reference< sheet::XSpreadsheetView > xView( getCurrentDocument()->getCurrentController(), uno::UNO_QUERY_THROW );
+	uno::Reference< table::XCellRange > xRange( xView->getActiveSheet(), ::uno::UNO_QUERY_THROW);
+	ScTabViewShell* pViewShell = getCurrentBestViewShell();
+	if ( !pViewShell )
+		throw uno::RuntimeException( rtl::OUString::createFromAscii("No ViewShell available"), uno::Reference< uno::XInterface >() );
+	ScViewData* pTabView = pViewShell->GetViewData();
+	if ( !pTabView )
+		throw uno::RuntimeException( rtl::OUString::createFromAscii("No ViewData available"), uno::Reference< uno::XInterface >() );
+
+	sal_Int32 nCursorX = pTabView->GetCurX();
+	sal_Int32 nCursorY = pTabView->GetCurY();
+
+	return uno::Reference< excel::XRange >( new ScVbaRange( m_xContext, xRange->getCellRangeByPosition( nCursorX, nCursorY, 
+										nCursorX, nCursorY ) ) ); 
+}
+
+sal_Bool
+ScVbaApplication::getScreenUpdating() throw (uno::RuntimeException)
+{
+	uno::Reference< frame::XModel > xModel( getCurrentDocument(), uno::UNO_QUERY_THROW );
+	return !xModel->hasControllersLocked();
+}
+
+void
+ScVbaApplication::setScreenUpdating(sal_Bool bUpdate) throw (uno::RuntimeException)
+{
+	uno::Reference< frame::XModel > xModel( getCurrentDocument(), uno::UNO_QUERY_THROW );
+	if (bUpdate)
+		xModel->unlockControllers();
+	else
+		xModel->lockControllers();
+}
+
+sal_Bool
+ScVbaApplication::getDisplayStatusBar() throw (uno::RuntimeException)
+{
+	uno::Reference< frame::XModel > xModel( getCurrentDocument(), uno::UNO_QUERY_THROW );
+    uno::Reference< frame::XFrame > xFrame( xModel->getCurrentController()->getFrame(), uno::UNO_QUERY_THROW );
+    uno::Reference< beans::XPropertySet > xProps( xFrame, uno::UNO_QUERY_THROW );
+
+    if( xProps.is() ){
+        uno::Reference< frame::XLayoutManager > xLayoutManager( xProps->getPropertyValue( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("LayoutManager")) ), uno::UNO_QUERY_THROW );
+        rtl::OUString url(RTL_CONSTASCII_USTRINGPARAM( "private:resource/statusbar/statusbar" ));
+        if( xLayoutManager.is() && xLayoutManager->isElementVisible( url ) ){
+            return sal_True;
+        }
+    }
+    return sal_False;
+}
+
+void
+ScVbaApplication::setDisplayStatusBar(sal_Bool bDisplayStatusBar) throw (uno::RuntimeException)
+{
+	uno::Reference< frame::XModel > xModel( getCurrentDocument(), uno::UNO_QUERY_THROW );
+    uno::Reference< frame::XFrame > xFrame( xModel->getCurrentController()->getFrame(), uno::UNO_QUERY_THROW );
+    uno::Reference< beans::XPropertySet > xProps( xFrame, uno::UNO_QUERY_THROW );
+
+    if( xProps.is() ){
+        uno::Reference< frame::XLayoutManager > xLayoutManager( xProps->getPropertyValue( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("LayoutManager")) ), uno::UNO_QUERY_THROW );
+        rtl::OUString url(RTL_CONSTASCII_USTRINGPARAM( "private:resource/statusbar/statusbar" ));
+        if( xLayoutManager.is() ){
+            if( bDisplayStatusBar && !xLayoutManager->isElementVisible( url ) ){
+                if( !xLayoutManager->showElement( url ) )
+                    xLayoutManager->createElement( url );
+                return;
+            }
+            else if( !bDisplayStatusBar && xLayoutManager->isElementVisible( url ) ){
+                xLayoutManager->hideElement( url ); 
+                return;
+            }
+        }
+    }
+    return;
+}
+
+uno::Any SAL_CALL
+ScVbaApplication::Workbooks( const uno::Any& aIndex ) throw (uno::RuntimeException)
+{
+	uno::Reference< vba::XCollection > xWorkBooks( new ScVbaWorkbooks( m_xContext ) );
+	if (  aIndex.getValueTypeClass() == uno::TypeClass_VOID )
+	{
+		// void then somebody did Workbooks.something in vba
+	    return uno::Any( xWorkBooks );
+	}
+
+	return uno::Any ( xWorkBooks->Item( aIndex ) );
+}
+
+uno::Any SAL_CALL
+ScVbaApplication::Worksheets( const uno::Any& aIndex ) throw (uno::RuntimeException)
+{
+    uno::Reference< excel::XWorkbook > xWorkbook( getActiveWorkbook(), uno::UNO_QUERY );
+        uno::Any result;
+    if ( xWorkbook.is() )
+        result  = xWorkbook->Worksheets( aIndex );
+
+    else
+        // Fixme - check if this is reasonable/desired behavior
+        throw uno::RuntimeException( rtl::OUString::createFromAscii(
+            "No ActiveWorkBook available" ), uno::Reference< uno::XInterface >() );
+
+	return result;
+}
+
+uno::Any SAL_CALL
+ScVbaApplication::WorksheetFunction( ) throw (::com::sun::star::uno::RuntimeException)
+{
+        return uno::makeAny( uno::Reference< script::XInvocation >( new ScVbaWSFunction(m_xContext) ) );
+}
+
+uno::Any SAL_CALL 
+ScVbaApplication::Evaluate( const ::rtl::OUString& Name ) throw (uno::RuntimeException)
+{
+	// #TODO Evaluate allows other things to be evaluated, e.g. functions
+	// I think ( like SIN(3) etc. ) need to investigate that
+	// named Ranges also? e.g. [MyRange] if so need a list of named ranges
+	uno::Any aVoid;
+	return uno::Any( getActiveWorkbook()->getActiveSheet()->Range( uno::Any( Name ), aVoid ) );	
+}
+
+uno::Any 
+ScVbaApplication::Dialogs( const uno::Any &aIndex ) throw (uno::RuntimeException)
+{
+	uno::Reference< excel::XDialogs > xDialogs( new ScVbaDialogs( m_xContext ) );
+	if( !aIndex.hasValue() )
+		return uno::Any( xDialogs );
+	return uno::Any( xDialogs->Item( aIndex ) );
+}
+
+uno::Reference< excel::XWindow > SAL_CALL 
+ScVbaApplication::getActiveWindow() throw (uno::RuntimeException)
+{
+	return new ScVbaWindow( m_xContext, getCurrentDocument() );
+}
+
+uno::Any SAL_CALL 
+ScVbaApplication::getCutCopyMode() throw (uno::RuntimeException)
+{
+	//# FIXME TODO, implementation
+	uno::Any result;
+	result <<= sal_False;
+	return result;
+}
+
+::rtl::OUString
+ScVbaApplication::getVersion() throw (uno::RuntimeException)
+{
+	return rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(EXCELVERSION));
+}
+
+void SAL_CALL 
+ScVbaApplication::setCutCopyMode( const uno::Any& /*_cutcopymode*/ ) throw (uno::RuntimeException)
+{
+	//# FIXME TODO, implementation
+}
+
+uno::Any SAL_CALL
+ScVbaApplication::getStatusBar() throw (uno::RuntimeException)
+{
+	return uno::makeAny( !getDisplayStatusBar() );
+}
+
+void SAL_CALL 
+ScVbaApplication::setStatusBar( const uno::Any& _statusbar ) throw (uno::RuntimeException)
+{
+    rtl::OUString sText;
+    sal_Bool bDefault;
+	uno::Reference< frame::XModel > xModel( getCurrentDocument(), uno::UNO_QUERY_THROW );
+    uno::Reference< task::XStatusIndicatorSupplier > xStatusIndicatorSupplier( xModel->getCurrentController(), uno::UNO_QUERY_THROW );
+    uno::Reference< task::XStatusIndicator > xStatusIndicator( xStatusIndicatorSupplier->getStatusIndicator(), uno::UNO_QUERY_THROW );
+    if( _statusbar >>= sText )
+    {
+        setDisplayStatusBar( sal_True );
+        xStatusIndicator->start( sText, 100 );
+        //xStatusIndicator->setText( sText );
+    }
+    else if( _statusbar >>= bDefault )
+    {
+        if( bDefault == sal_False )
+        {
+            xStatusIndicator->end();
+            setDisplayStatusBar( sal_True );
+        }
+    }
+    else
+        throw uno::RuntimeException( rtl::OUString::createFromAscii( "Invalid prarameter. It should be a string or False" ),
+            uno::Reference< uno::XInterface >() );
+}
+
+double SAL_CALL 
+ScVbaApplication::CountA( const uno::Any& arg1 ) throw (uno::RuntimeException)
+{
+	double result = 0;
+	uno::Reference< script::XInvocation > xInvoc( WorksheetFunction(), uno::UNO_QUERY_THROW );
+	if  ( xInvoc.is() )
+	{
+		static rtl::OUString FunctionName( RTL_CONSTASCII_USTRINGPARAM("CountA" ) );
+		uno::Sequence< uno::Any > Params(1);
+		Params[0] = arg1;
+		uno::Sequence< sal_Int16 > OutParamIndex;
+		uno::Sequence< uno::Any > OutParam;
+		xInvoc->invoke( FunctionName, Params, OutParamIndex, OutParam ) >>= result;
+	}
+	return result;
+}
+
+::sal_Int32 SAL_CALL 
+ScVbaApplication::getCalculation() throw (css::uno::RuntimeException)
+{
+	return m_xCalculation;
+}
+
+void SAL_CALL 
+ScVbaApplication::setCalculation( ::sal_Int32 _calculation ) throw (css::uno::RuntimeException)
+{
+	m_xCalculation = _calculation;
+}
+
+uno::Any SAL_CALL 
+ScVbaApplication::Windows( const uno::Any& aIndex  ) throw (uno::RuntimeException)
+{
+	uno::Reference< vba::XCollection >  xWindows = ScVbaWindows::Windows( m_xContext );
+	if ( aIndex.getValueTypeClass() == uno::TypeClass_VOID )
+		return uno::Any( xWindows );
+	return uno::Any( xWindows->Item( aIndex ) );	
+}
+void SAL_CALL 
+ScVbaApplication::wait( double time ) throw (css::uno::RuntimeException)
+{
+	StarBASIC* pBasic = SFX_APP()->GetBasic();
+	SFX_APP()->EnterBasicCall();
+	SbxArrayRef aArgs = new SbxArray;
+	SbxVariableRef aRef = new SbxVariable;
+	aRef->PutDouble( time );
+	aArgs->Put(  aRef, 1 );
+	SbMethod* pMeth = (SbMethod*)pBasic->GetRtl()->Find( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("WaitUntil") ), SbxCLASS_METHOD );
+	
+	if ( pMeth )
+	{
+		pMeth->SetParameters( aArgs );
+		SbxVariableRef refTemp = pMeth;
+		// forces a broadcast
+		SbxVariableRef pNew = new  SbxMethod( *((SbxMethod*)pMeth));
+	}
+	SFX_APP()->LeaveBasicCall();
+
+}
+
+uno::Any SAL_CALL 
+ScVbaApplication::Range( const uno::Any& Cell1, const uno::Any& Cell2 ) throw (uno::RuntimeException)
+{
+	uno::Reference< excel::XRange > xVbRange = ScVbaRange::ApplicationRange( m_xContext, Cell1, Cell2 ); 
+	return uno::makeAny( xVbRange ); 
+}
+
+uno::Reference< excel::XWorksheet > SAL_CALL 
+ScVbaApplication::getActiveSheet() throw (uno::RuntimeException)
+{
+    uno::Reference< excel::XWorksheet > result;
+    uno::Reference< excel::XWorkbook > xWorkbook( getActiveWorkbook(), uno::UNO_QUERY );
+    if ( xWorkbook.is() )
+    {
+        uno::Reference< excel::XWorksheet > xWorksheet( 
+            xWorkbook->getActiveSheet(), uno::UNO_QUERY );
+        if ( xWorksheet.is() )
+        {
+            result = xWorksheet;
+        }	
+    }
+
+    if ( !result.is() )
+    {
+        // Fixme - check if this is reasonable/desired behavior
+        throw uno::RuntimeException( rtl::OUString::createFromAscii(
+            "No activeSheet available" ), uno::Reference< uno::XInterface >() );
+    }
+    return result;
+	
+}
+
+/*******************************************************************************
+ *  In msdn: 
+ *  Reference   Optional Variant. The destination. Can be a Range 
+ *  object, a string that contains a cell reference in R1C1-style notation,
+ *  or a string that contains a Visual Basic procedure name.
+ *  Scroll   Optional Variant. True to scrol, False to not scroll through 
+ *  the window. The default is False.
+ *  Parser is split to three parts, Range, R1C1 string and procedure name.
+ *  by test excel, it seems Scroll no effect. ??? 
+*******************************************************************************/
+void SAL_CALL 
+ScVbaApplication::GoTo( const uno::Any& Reference, const uno::Any& Scroll ) throw (uno::RuntimeException)
+{
+    //test Scroll is a boolean
+    sal_Bool bScroll = sal_False;
+    //R1C1-style string or a string of procedure name.
+    
+    if( Scroll.hasValue() )
+    {
+        sal_Bool aScroll;
+        if( Scroll >>= aScroll )
+        {
+            bScroll = aScroll;
+        }
+        else
+            throw uno::RuntimeException( rtl::OUString::createFromAscii( "sencond parameter should be boolean" ),
+                    uno::Reference< uno::XInterface >() );
+    }
+
+    rtl::OUString sRangeName;
+    if( Reference >>= sRangeName )
+    {
+        uno::Reference< frame::XModel > xModel( getCurrentDocument(), uno::UNO_QUERY_THROW );
+        uno::Reference< sheet::XSpreadsheetView > xSpreadsheet(
+                xModel->getCurrentController(), uno::UNO_QUERY_THROW );
+        uno::Reference< sheet::XSpreadsheet > xDoc = xSpreadsheet->getActiveSheet();
+
+        ScTabViewShell* pShell = getCurrentBestViewShell();
+        ScGridWindow* gridWindow = (ScGridWindow*)pShell->GetWindow(); 
+        try
+        {
+            uno::Reference< table::XCellRange > xRange = ScVbaRange::getCellRangeForName( sRangeName, xDoc, ScAddress::CONV_XL_R1C1 );
+            ScVbaRange* pRange = new ScVbaRange( m_xContext, xRange );
+            uno::Reference< excel::XRange > xVbaSheetRange( pRange );
+            if( bScroll )
+            {
+                xVbaSheetRange->Select();
+                uno::Reference< excel::XWindow >  xWindow = getActiveWindow();
+                ScSplitPos eWhich = pShell->GetViewData()->GetActivePart();
+                sal_Int32 nValueX = pShell->GetViewData()->GetPosX(WhichH(eWhich));
+                sal_Int32 nValueY = pShell->GetViewData()->GetPosY(WhichV(eWhich));
+                xWindow->SmallScroll( uno::makeAny( (sal_Int16)(xVbaSheetRange->getRow() - 1) ), 
+                         uno::makeAny( (sal_Int16)nValueY ),
+                         uno::makeAny( (sal_Int16)(xVbaSheetRange->getColumn() - 1)  ), 
+                         uno::makeAny( (sal_Int16)nValueX ) );
+                gridWindow->GrabFocus();
+            }
+            else
+            {
+                xVbaSheetRange->Select();
+                gridWindow->GrabFocus();
+            }
+        }
+        catch( uno::RuntimeException )
+        {
+            //maybe this should be a procedure name
+            //TODO for procedure name
+            //browse::XBrowseNodeFactory is a singlton. OUString::createFromAscii( "/singletons/com.sun.star.script.browse.theBrowseNodeFactory")
+            //and the createView( browse::BrowseNodeFactoryViewTypes::MACROSELECTOR ) to get a root browse::XBrowseNode.
+            //for query XInvocation interface.
+            //but how to directly get the XInvocation?
+            throw uno::RuntimeException( rtl::OUString::createFromAscii( "invalid reference for range name, it should be procedure name" ),
+                    uno::Reference< uno::XInterface >() );
+        }
+        return;
+    }
+    uno::Reference< excel::XRange > xRange;
+    if( Reference >>= xRange )
+    {
+        uno::Reference< excel::XRange > xVbaRange( Reference, uno::UNO_QUERY );
+        ScTabViewShell* pShell = getCurrentBestViewShell();
+        ScGridWindow* gridWindow = (ScGridWindow*)pShell->GetWindow(); 
+        if ( xVbaRange.is() )
+        {
+            //TODO bScroll should be using, In this time, it doesenot have effection
+            if( bScroll )
+            {
+                xVbaRange->Select();
+                uno::Reference< excel::XWindow >  xWindow = getActiveWindow();
+                ScSplitPos eWhich = pShell->GetViewData()->GetActivePart();
+                sal_Int32 nValueX = pShell->GetViewData()->GetPosX(WhichH(eWhich));
+                sal_Int32 nValueY = pShell->GetViewData()->GetPosY(WhichV(eWhich));
+                xWindow->SmallScroll( uno::makeAny( (sal_Int16)(xVbaRange->getRow() - 1) ), 
+                         uno::makeAny( (sal_Int16)nValueY ),
+                         uno::makeAny( (sal_Int16)(xVbaRange->getColumn() - 1)  ), 
+                         uno::makeAny( (sal_Int16)nValueX ) );
+                gridWindow->GrabFocus();
+            }
+            else
+            {
+                xVbaRange->Select();
+                gridWindow->GrabFocus();
+            }
+        }
+        return;
+    }
+    throw uno::RuntimeException( rtl::OUString::createFromAscii( "invalid reference or name" ),
+            uno::Reference< uno::XInterface >() );
+}
+
+sal_Int32 SAL_CALL
+ScVbaApplication::getCursor() throw (uno::RuntimeException)
+{
+	SfxObjectShell* pObject = SfxObjectShell::GetWorkingDocument();//Current();
+    SfxViewFrame* pFrame = SfxViewFrame::GetFirst( pObject );
+    sal_Int32 result = pFrame->GetFrame()->GetWindow().GetSystemWindow()->GetPointer().GetStyle();
+    
+    switch( result )
+    {
+        case POINTER_ARROW:
+            return excel::XlMousePointer::xlNorthwestArrow;
+        case POINTER_NULL:
+            return excel::XlMousePointer::xlDefault;
+        case POINTER_WAIT:
+            return excel::XlMousePointer::xlWait;
+        case POINTER_TEXT:
+            return excel::XlMousePointer::xlIBeam;
+        default:
+            return excel::XlMousePointer::xlDefault;
+    }
+}
+
+void SAL_CALL 
+ScVbaApplication::setCursor( sal_Int32 _cursor ) throw (uno::RuntimeException)
+{
+    SfxObjectShell* pObject = SfxObjectShell::GetWorkingDocument();
+    for( SfxViewFrame* pFrame = SfxViewFrame::GetFirst( pObject ); pFrame; pFrame = SfxViewFrame::GetNext( *pFrame, pObject ) )
+    {
+        switch( _cursor )
+        {
+            case excel::XlMousePointer::xlNorthwestArrow:
+            {
+                const Pointer& rPointer( POINTER_ARROW );
+                pFrame->GetFrame()->GetWindow().GetSystemWindow()->SetPointer( rPointer );
+                pFrame->GetFrame()->GetWindow().GetSystemWindow()->EnableChildPointerOverwrite( sal_False );
+                break;
+            }
+            case excel::XlMousePointer::xlWait:
+            case excel::XlMousePointer::xlIBeam:
+            {
+                const Pointer& rPointer( static_cast< PointerStyle >( _cursor ) );
+                //It will set the edit window, toobar and statusbar's mouse pointer.
+                pFrame->GetFrame()->GetWindow().GetSystemWindow()->SetPointer( rPointer );
+                pFrame->GetFrame()->GetWindow().GetSystemWindow()->EnableChildPointerOverwrite( sal_True );
+                //It only set the edit window's mouse pointer
+                //pFrame->GetFrame()->GetWindow().SetPointer( rPointer );
+                //pFrame->GetFrame()->GetWindow().EnableChildPointerOverwrite( sal_True );
+                //printf("\nset Cursor...%d\n", pFrame->GetFrame()->GetWindow().GetType());
+                break;
+            }
+            case excel::XlMousePointer::xlDefault:
+            {
+                const Pointer& rPointer( POINTER_NULL );
+                pFrame->GetFrame()->GetWindow().GetSystemWindow()->SetPointer( rPointer );
+                pFrame->GetFrame()->GetWindow().GetSystemWindow()->EnableChildPointerOverwrite( sal_False );
+                break;
+            }
+            default:
+                throw uno::RuntimeException( rtl::OUString( 
+                        RTL_CONSTASCII_USTRINGPARAM("Unknown value for Cursor pointer")), uno::Reference< uno::XInterface >() );
+        }
+	}
+}
Index: sc/source/ui/vba/vbaapplication.hxx
===================================================================
RCS file: sc/source/ui/vba/vbaapplication.hxx
diff -N sc/source/ui/vba/vbaapplication.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbaapplication.hxx	21 Feb 2007 17:29:16 -0000	1.1.2.2
@@ -0,0 +1,90 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_APPLICATION_HXX
+#define SC_VBA_APPLICATION_HXX
+
+#include <cppuhelper/implbase1.hxx>
+
+#include <org/openoffice/excel/XWorksheetFunction.hpp>
+#include <org/openoffice/excel/XApplication.hpp>
+#include <com/sun/star/uno/XComponentContext.hpp>
+
+#include "vbahelper.hxx"
+
+typedef ::cppu::WeakImplHelper1< oo::excel::XApplication > ScVbaApplication_BASE;
+
+class ScVbaApplication : public ScVbaApplication_BASE
+{
+private:
+	css::uno::Reference< css::uno::XComponentContext > m_xContext;
+	sal_Int32 m_xCalculation;
+public:
+	ScVbaApplication( css::uno::Reference< css::uno::XComponentContext >& m_xContext );
+	virtual ~ScVbaApplication();
+
+    // XApplication
+	virtual ::sal_Int32 SAL_CALL getCalculation() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setCalculation( ::sal_Int32 _calculation ) throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< oo::excel::XRange > SAL_CALL getSelection() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< oo::excel::XWorkbook > SAL_CALL getActiveWorkbook() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< oo::excel::XRange > SAL_CALL getActiveCell() throw ( css::uno::RuntimeException);
+ virtual css::uno::Reference< oo::excel::XWindow > SAL_CALL getActiveWindow() throw (::com::sun::star::uno::RuntimeException);
+ virtual css::uno::Reference< oo::excel::XWorksheet > SAL_CALL getActiveSheet() throw (::com::sun::star::uno::RuntimeException);
+	virtual sal_Bool SAL_CALL getScreenUpdating() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setScreenUpdating(sal_Bool bUpdate) throw (css::uno::RuntimeException);
+	virtual sal_Bool SAL_CALL getDisplayStatusBar() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setDisplayStatusBar(sal_Bool bDisplayStatusBar) throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< oo::excel::XWorkbook > SAL_CALL getThisWorkbook() throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL Workbooks( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL Worksheets( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL WorksheetFunction( ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL Evaluate( const ::rtl::OUString& Name ) throw (css::uno::RuntimeException); 
+	virtual css::uno::Any SAL_CALL Dialogs( const css::uno::Any& DialogIndex ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL getCutCopyMode() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setCutCopyMode( const css::uno::Any& _cutcopymode ) throw (css::uno::RuntimeException);
+	virtual ::rtl::OUString SAL_CALL getVersion() throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL getStatusBar() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setStatusBar( const css::uno::Any& _statusbar ) throw (css::uno::RuntimeException);
+	virtual ::sal_Int32 SAL_CALL getCursor() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setCursor( ::sal_Int32 _cursor ) throw (css::uno::RuntimeException);
+
+	virtual double SAL_CALL CountA( const css::uno::Any& arg1 ) throw (css::uno::RuntimeException) ;
+
+	virtual css::uno::Any SAL_CALL Windows( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+	virtual void SAL_CALL wait( double time ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL Range( const css::uno::Any& Cell1, const css::uno::Any& Cell2 ) throw (css::uno::RuntimeException);
+	virtual void SAL_CALL GoTo( const css::uno::Any& Reference, const css::uno::Any& Scroll ) throw (css::uno::RuntimeException);
+};
+#endif /* SC_VBA_APPLICATION_HXX */
Index: sc/source/ui/vba/vbaborders.cxx
===================================================================
RCS file: sc/source/ui/vba/vbaborders.cxx
diff -N sc/source/ui/vba/vbaborders.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbaborders.cxx	21 Feb 2007 17:29:16 -0000	1.1.2.2
@@ -0,0 +1,506 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbaborders.hxx"
+
+#include <cppuhelper/implbase3.hxx>
+#include <org/openoffice/excel/XlBordersIndex.hpp>
+#include <org/openoffice/excel/XlBorderWeight.hpp>
+#include <org/openoffice/excel/XlLineStyle.hpp>
+#include <org/openoffice/excel/XlColorIndex.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/table/TableBorder.hpp>
+
+#include "vbapalette.hxx"
+
+using namespace ::com::sun::star;
+using namespace ::org::openoffice;
+using namespace ::org::openoffice::excel;
+
+
+typedef ::cppu::WeakImplHelper1<container::XIndexAccess > RangeBorders_Base;
+typedef ::cppu::WeakImplHelper1<excel::XBorder > ScVbaBorder_Base;
+
+// #TODO sort these indexes to match the order in which Excel iterates over the
+// borders, the enumeration will match the order in this list
+static const sal_Int16 supportedIndexTable[] = {  XlBordersIndex::xlEdgeLeft, XlBordersIndex::xlEdgeTop, XlBordersIndex::xlEdgeBottom, XlBordersIndex::xlEdgeRight, XlBordersIndex::xlDiagonalDown, XlBordersIndex::xlDiagonalUp, XlBordersIndex::xlInsideVertical, XlBordersIndex::xlInsideHorizontal };
+
+const static rtl::OUString sTableBorder( RTL_CONSTASCII_USTRINGPARAM("TableBorder") );
+
+//  Equiv widths in in 1/100 mm
+const static sal_Int32 OOLineThin = 35;
+const static sal_Int32 OOLineMedium = 88;
+const static sal_Int32 OOLineThick = 141;
+const static sal_Int32 OOLineHairline = 2;
+
+class ScVbaBorder : public ScVbaBorder_Base
+{
+private:
+	uno::Reference< beans::XPropertySet > m_xProps;
+	uno::Reference< uno::XComponentContext > m_xContext;
+	sal_Int32 m_LineType;	
+	ScVbaPalette m_Palette;
+	bool setBorderLine( table::BorderLine& rBorderLine )
+	{
+		table::TableBorder aTableBorder;
+		m_xProps->getPropertyValue( sTableBorder ) >>= aTableBorder;
+
+		switch ( m_LineType )
+		{
+			case XlBordersIndex::xlEdgeLeft:
+				aTableBorder.IsLeftLineValid = sal_True;
+				aTableBorder.LeftLine= rBorderLine;
+				break;
+			case XlBordersIndex::xlEdgeTop:
+				aTableBorder.IsTopLineValid = sal_True;
+				aTableBorder.TopLine = rBorderLine;
+				break;
+			
+			case XlBordersIndex::xlEdgeBottom:
+				aTableBorder.IsBottomLineValid = sal_True;
+				aTableBorder.BottomLine = rBorderLine;
+				break;
+			case XlBordersIndex::xlEdgeRight:
+				aTableBorder.IsRightLineValid = sal_True;
+				aTableBorder.RightLine = rBorderLine;
+				break;
+			case XlBordersIndex::xlInsideVertical:
+				aTableBorder.IsVerticalLineValid = sal_True;
+				aTableBorder.VerticalLine = rBorderLine;
+				break;
+			case XlBordersIndex::xlInsideHorizontal:
+				aTableBorder.IsHorizontalLineValid = sal_True;
+				aTableBorder.HorizontalLine = rBorderLine;
+				break;
+			case XlBordersIndex::xlDiagonalDown:
+			case XlBordersIndex::xlDiagonalUp:
+				// #TODO have to ignore at the momement, would be
+				// nice to investigate what we can do here
+				break; 
+			default:
+					return false;
+		}
+		m_xProps->setPropertyValue( sTableBorder, uno::makeAny(aTableBorder) );
+		return true;
+	}	
+
+	bool getBorderLine( table::BorderLine& rBorderLine )
+	{
+		table::TableBorder aTableBorder;
+		m_xProps->getPropertyValue( sTableBorder ) >>= aTableBorder;
+		switch ( m_LineType )
+		{
+			case XlBordersIndex::xlEdgeLeft:
+				if ( aTableBorder.IsLeftLineValid )
+					rBorderLine = aTableBorder.LeftLine;
+				break;
+			case XlBordersIndex::xlEdgeTop:
+				if ( aTableBorder.IsTopLineValid )
+					rBorderLine = aTableBorder.TopLine;
+				break;
+			
+			case XlBordersIndex::xlEdgeBottom:
+				if ( aTableBorder.IsBottomLineValid )
+					rBorderLine = aTableBorder.BottomLine;
+				break;
+			case XlBordersIndex::xlEdgeRight:
+				if ( aTableBorder.IsRightLineValid )
+					rBorderLine = aTableBorder.RightLine;
+				break;
+			case XlBordersIndex::xlInsideVertical:
+                if ( aTableBorder.IsVerticalLineValid )
+                    rBorderLine = aTableBorder.VerticalLine;
+				break;
+			case XlBordersIndex::xlInsideHorizontal:
+                if ( aTableBorder.IsHorizontalLineValid )
+                    rBorderLine = aTableBorder.HorizontalLine;
+				break;
+
+			case XlBordersIndex::xlDiagonalDown:
+			case XlBordersIndex::xlDiagonalUp:
+				// #TODO have to ignore at the momement, would be
+				// nice to investigate what we can do here
+				break; 
+			default:
+					return false;
+		}
+		return true;
+	}	
+	ScVbaBorder(); // no impl
+public:
+	ScVbaBorder( const uno::Reference< beans::XPropertySet > & xProps, const uno::Reference< uno::XComponentContext >& xContext, sal_Int32 lineType, ScVbaPalette& rPalette) : m_xProps( xProps ), m_xContext( xContext ), m_LineType( lineType ), m_Palette( rPalette ) {}  	
+
+	// XBorder
+	uno::Any SAL_CALL getColor() throw (uno::RuntimeException)
+	{
+		table::BorderLine aBorderLine;
+		if ( getBorderLine( aBorderLine ) )
+			return uno::makeAny( OORGBToXLRGB( aBorderLine.Color ) ); 
+		throw uno::RuntimeException( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "No Implementation available" ) ), uno::Reference< uno::XInterface >() );
+	}
+	void SAL_CALL setColor( const uno::Any& _color ) throw (uno::RuntimeException)
+	{
+		sal_Int32 nColor;
+		_color >>= nColor;
+		table::BorderLine aBorderLine;
+		if ( getBorderLine( aBorderLine ) )
+		{
+			aBorderLine.Color = XLRGBToOORGB( nColor );
+			setBorderLine( aBorderLine );	
+		}
+		else
+			throw uno::RuntimeException( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "No Implementation available" ) ), uno::Reference< uno::XInterface >() );
+	}
+
+	uno::Any SAL_CALL getColorIndex() throw (uno::RuntimeException)
+	{
+		sal_Int32 nColor;
+		XLRGBToOORGB( getColor() ) >>= nColor;
+		uno::Reference< container::XIndexAccess > xIndex = m_Palette.getPalette();
+		sal_Int32 nElems = xIndex->getCount();
+		sal_Int32 nIndex = -1;
+		for ( sal_Int32 count=0; count<nElems; ++count )
+		{
+			sal_Int32 nPaletteColor;
+			xIndex->getByIndex( count ) >>= nPaletteColor;
+			if ( nPaletteColor == nColor )
+			{					
+				nIndex = count + 1;
+				break;
+			}
+		}
+		return uno::makeAny(nIndex);
+	}
+
+	void SAL_CALL setColorIndex( const uno::Any& _colorindex ) throw (uno::RuntimeException)
+	{
+		sal_Int32 nColor;
+		_colorindex >>= nColor;
+		if ( !nColor || nColor == XlColorIndex::xlColorIndexAutomatic )
+			nColor = 1;
+		setColor( OORGBToXLRGB( m_Palette.getPalette()->getByIndex( --nColor )  ) );
+	}
+	uno::Any SAL_CALL getWeight() throw (uno::RuntimeException)
+	{
+		table::BorderLine aBorderLine;
+		if ( getBorderLine( aBorderLine ) )
+		{
+			switch ( aBorderLine.OuterLineWidth )
+			{
+				case 0:	// Thin = default OO thickness
+				case OOLineThin:	
+					return uno::makeAny( XlBorderWeight::xlThin );
+				case OOLineMedium:	
+					return uno::makeAny( XlBorderWeight::xlMedium );
+				case OOLineThick:	
+					return uno::makeAny( XlBorderWeight::xlThick );
+				case OOLineHairline:	
+					return uno::makeAny( XlBorderWeight::xlHairline );
+				default: 
+					break;
+			}
+		}
+		throw uno::RuntimeException( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "Method failed" ) ), uno::Reference< uno::XInterface >() );
+	}
+	void SAL_CALL setWeight( const uno::Any& _weight ) throw (uno::RuntimeException)
+	{
+		sal_Int32 nWeight;
+		_weight >>= nWeight;
+		table::BorderLine aBorderLine;
+		if ( getBorderLine( aBorderLine ) )
+		{
+			switch ( nWeight )
+			{
+				case XlBorderWeight::xlThin:	
+					aBorderLine.OuterLineWidth = OOLineThin;
+					break;
+				case XlBorderWeight::xlMedium:
+					aBorderLine.OuterLineWidth = OOLineMedium;
+					break;
+				case XlBorderWeight::xlThick:
+					aBorderLine.OuterLineWidth = OOLineThick;
+					break;
+				case XlBorderWeight::xlHairline:
+					aBorderLine.OuterLineWidth = OOLineHairline;
+					break;
+				default: 
+					throw uno::RuntimeException( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "Bad param" ) ), uno::Reference< uno::XInterface >() );
+					break;
+			}
+			setBorderLine( aBorderLine );
+		}
+		else
+					throw uno::RuntimeException( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "Method failed" ) ), uno::Reference< uno::XInterface >() );
+	}
+
+	uno::Any SAL_CALL getLineStyle() throw (uno::RuntimeException)
+	{
+		// always return xlContinuous;
+		return uno::makeAny( XlLineStyle::xlContinuous );
+	}
+	void SAL_CALL setLineStyle( const uno::Any& _linestyle ) throw (uno::RuntimeException) 
+	{
+		// Urk no choice but to silently ignore we don't support this attribute
+		// #TODO would be nice to support the excel line styles
+        sal_Int32 nLineStyle;
+        _linestyle >>= nLineStyle;
+        table::BorderLine aBorderLine;
+		if ( getBorderLine( aBorderLine ) )
+		{
+			switch ( nLineStyle )
+			{
+                case XlLineStyle::xlContinuous:
+                case XlLineStyle::xlDash:
+                case XlLineStyle::xlDashDot:
+                case XlLineStyle::xlDashDotDot:
+                case XlLineStyle::xlDot:
+                case XlLineStyle::xlDouble:
+                case XlLineStyle::xlLineStyleNone:
+                case XlLineStyle::xlSlantDashDot:
+                    break;
+                default:
+                    throw uno::RuntimeException( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "Bad param" ) ), uno::Reference< uno::XInterface >() );
+                    break;
+            }
+			setBorderLine( aBorderLine );
+        }
+		else
+            throw uno::RuntimeException( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "Method failed" ) ), uno::Reference< uno::XInterface >() );
+	}
+};
+
+class RangeBorders : public RangeBorders_Base
+{
+private:
+	uno::Reference< table::XCellRange > m_xRange;
+	uno::Reference< uno::XComponentContext > m_xContext;
+	ScVbaPalette m_Palette;
+	sal_Int32 getTableIndex( sal_Int32 nConst )
+	{
+		// hokay return position of the index in the table
+		sal_Int32 nIndexes = getCount();
+		sal_Int32 realIndex = 0;
+		const sal_Int16* pTableEntry = supportedIndexTable;
+		for ( ; realIndex < nIndexes; ++realIndex, ++pTableEntry )
+		{
+			if ( *pTableEntry == nConst )
+				return realIndex;
+		}
+		return getCount(); // error condition
+	}
+public:
+	RangeBorders(  const uno::Reference< table::XCellRange >& xRange,  const uno::Reference< uno::XComponentContext > & xContext, ScVbaPalette& rPalette ) : m_xRange( xRange ), m_xContext( xContext ), m_Palette( rPalette )
+	{
+	}
+	// XIndexAccess 
+	virtual ::sal_Int32 SAL_CALL getCount(  ) throw (uno::RuntimeException)
+	{
+		return sizeof( supportedIndexTable ) / sizeof( supportedIndexTable[0] );
+	}
+	virtual uno::Any SAL_CALL getByIndex( ::sal_Int32 Index ) throw (lang::IndexOutOfBoundsException, lang::WrappedTargetException, uno::RuntimeException) 
+	{
+			
+		sal_Int32 nIndex = getTableIndex( Index );
+		if ( nIndex >= 0 && nIndex < getCount() )
+		{
+			uno::Reference< beans::XPropertySet > xProps( m_xRange, uno::UNO_QUERY_THROW );
+			return uno::makeAny( uno::Reference< excel::XBorder >( new ScVbaBorder( xProps, m_xContext, supportedIndexTable[ nIndex ], m_Palette )) );
+		}
+		throw lang::IndexOutOfBoundsException();
+	}
+	virtual uno::Type SAL_CALL getElementType(  ) throw (uno::RuntimeException)
+	{
+		return  excel::XBorder::static_type(0);
+	}
+	virtual ::sal_Bool SAL_CALL hasElements(  ) throw (uno::RuntimeException)
+	{
+		return sal_True;
+	}
+};
+
+uno::Reference< container::XIndexAccess > 
+rangeToBorderIndexAccess( const uno::Reference< table::XCellRange >& xRange,  const uno::Reference< uno::XComponentContext > & xContext, ScVbaPalette& rPalette )
+{
+	return new RangeBorders( xRange, xContext, rPalette );
+}
+
+class RangeBorderEnumWrapper : public EnumerationHelper_BASE
+{
+	uno::Reference<container::XIndexAccess > m_xIndexAccess;
+	sal_Int32 nIndex;
+public:
+	RangeBorderEnumWrapper( const uno::Reference< container::XIndexAccess >& xIndexAccess ) : m_xIndexAccess( xIndexAccess ), nIndex( 0 ) {}
+	virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException)
+	{
+		return ( nIndex < m_xIndexAccess->getCount() );
+	}
+
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+	{
+		if ( nIndex < m_xIndexAccess->getCount() )
+			return m_xIndexAccess->getByIndex( nIndex++ );
+		throw container::NoSuchElementException();
+	}
+};
+
+ScVbaBorders::ScVbaBorders( const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< table::XCellRange >& xRange, ScVbaPalette& rPalette  ):  ScVbaBorders_BASE( xContext, rangeToBorderIndexAccess( xRange ,xContext, rPalette ) ) 
+{
+}
+
+uno::Reference< container::XEnumeration >
+ScVbaBorders::createEnumeration() throw (uno::RuntimeException)
+{
+	return new RangeBorderEnumWrapper( m_xIndexAccess );
+}
+
+uno::Any
+ScVbaBorders::createCollectionObject( const css::uno::Any& aSource )
+{
+	return aSource; // its already a Border object
+}
+
+uno::Type 
+ScVbaBorders::getElementType() throw (uno::RuntimeException)
+{
+	return excel::XBorders::static_type(0);
+}
+
+uno::Any
+ScVbaBorders::getItemByIntIndex( const sal_Int32 nIndex )  throw (uno::RuntimeException)
+{
+	return createCollectionObject( m_xIndexAccess->getByIndex( nIndex ) );
+}
+
+
+uno::Any SAL_CALL ScVbaBorders::getColor() throw (uno::RuntimeException)
+{
+    sal_Int32 count = getCount();
+    uno::Any color;
+    for( sal_Int32 i = 0; i < count ; i++ )
+    {
+        if( XlBordersIndex::xlDiagonalDown != supportedIndexTable[i] && XlBordersIndex::xlDiagonalUp != supportedIndexTable[i] )
+        {
+            uno::Reference< XBorder > xBorder( getItemByIntIndex( supportedIndexTable[i] ), uno::UNO_QUERY_THROW );
+            if( color.hasValue() )
+            {
+                if( color != xBorder->getColor() )
+                    return uno::makeAny( uno::Reference< uno::XInterface >() );
+            }
+            else
+                color = xBorder->getColor();
+        }
+    }
+    return  color;
+}
+void SAL_CALL ScVbaBorders::setColor( const uno::Any& _color ) throw (uno::RuntimeException)
+{
+    sal_Int32 count = getCount();
+    for( sal_Int32 i = 0; i < count ; i++ )
+    {
+        uno::Reference< XBorder > xBorder( getItemByIntIndex( supportedIndexTable[i] ), uno::UNO_QUERY_THROW );
+        xBorder->setColor( _color );
+    }
+}
+uno::Any SAL_CALL ScVbaBorders::getColorIndex() throw (uno::RuntimeException)
+{
+    sal_Int32 count = getCount();
+    uno::Any nColorIndex;
+    for( sal_Int32 i = 0; i < count ; i++ )
+    {
+        if( XlBordersIndex::xlDiagonalDown != supportedIndexTable[i] && XlBordersIndex::xlDiagonalUp != supportedIndexTable[i] )
+        {
+            uno::Reference< XBorder > xBorder( getItemByIntIndex( supportedIndexTable[i] ), uno::UNO_QUERY_THROW );
+            if( nColorIndex.hasValue() )
+            {
+                if( nColorIndex != xBorder->getColorIndex() )
+                    return uno::makeAny( uno::Reference< uno::XInterface >() );
+            }
+            else
+                nColorIndex = xBorder->getColorIndex();
+        }
+    }
+    return  nColorIndex;
+}
+void SAL_CALL ScVbaBorders::setColorIndex( const uno::Any& _colorindex ) throw (uno::RuntimeException)
+{
+    sal_Int32 count = getCount();
+    for( sal_Int32 i = 0; i < count ; i++ )
+    {
+        uno::Reference< XBorder > xBorder( getItemByIntIndex( supportedIndexTable[i] ), uno::UNO_QUERY_THROW );
+        xBorder->setColorIndex( _colorindex );
+    }
+}
+uno::Any SAL_CALL ScVbaBorders::getLineStyle() throw (uno::RuntimeException)
+{
+     //TODO if OOo support
+	throw uno::RuntimeException( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "No Implementation available" ) ), uno::Reference< uno::XInterface >() );
+}
+void SAL_CALL ScVbaBorders::setLineStyle( const uno::Any& _linestyle ) throw (uno::RuntimeException)
+{
+    sal_Int32 count = getCount();
+    for( sal_Int32 i = 0; i < count ; i++ )
+    {
+        uno::Reference< XBorder > xBorder( getItemByIntIndex( supportedIndexTable[i] ), uno::UNO_QUERY_THROW );
+        xBorder->setLineStyle( _linestyle );
+    }
+}
+uno::Any SAL_CALL ScVbaBorders::getWeight() throw (uno::RuntimeException)
+{
+    sal_Int32 count = getCount();
+    uno::Any weight;
+    for( sal_Int32 i = 0; i < count ; i++ )
+    {
+        if( XlBordersIndex::xlDiagonalDown != supportedIndexTable[i] && XlBordersIndex::xlDiagonalUp != supportedIndexTable[i] )
+        {
+            uno::Reference< XBorder > xBorder( getItemByIntIndex( supportedIndexTable[i] ), uno::UNO_QUERY_THROW );
+            if( weight.hasValue() )
+            {
+                if( weight != xBorder->getWeight() )
+                    return uno::makeAny( uno::Reference< uno::XInterface >() );
+            }
+            else
+                weight = xBorder->getWeight();
+        }
+    }
+    return  weight;
+}
+void SAL_CALL ScVbaBorders::setWeight( const uno::Any& _weight ) throw (uno::RuntimeException) 
+{
+    sal_Int32 count = getCount();
+    for( sal_Int32 i = 0; i < count ; i++ )
+    {
+        uno::Reference< XBorder > xBorder( getItemByIntIndex( supportedIndexTable[i] ), uno::UNO_QUERY_THROW );
+        xBorder->setWeight( _weight );
+    }
+}
Index: sc/source/ui/vba/vbaborders.hxx
===================================================================
RCS file: sc/source/ui/vba/vbaborders.hxx
diff -N sc/source/ui/vba/vbaborders.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbaborders.hxx	21 Feb 2007 17:29:16 -0000	1.1.2.2
@@ -0,0 +1,83 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_BORDERS_HXX
+#define SC_VBA_BORDERS_HXX
+
+#include <cppuhelper/implbase1.hxx>
+#include <org/openoffice/excel/XBorders.hpp>
+
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <com/sun/star/table/XCellRange.hpp>
+
+ 
+#include "vbahelper.hxx"
+#include "vbacollectionimpl.hxx"
+
+
+typedef ::cppu::ImplInheritanceHelper1< ScVbaCollectionBaseImpl, oo::excel::XBorders > ScVbaBorders_BASE;
+
+class ScVbaPalette;
+class ScVbaBorders : public ScVbaBorders_BASE
+{
+protected:
+	// XEnumerationAccess
+	virtual css::uno::Any getItemByIntIndex( const sal_Int32 nIndex ) throw (css::uno::RuntimeException);
+
+public:
+	ScVbaBorders( const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::table::XCellRange >& xRange, ScVbaPalette& rPalette );
+	virtual ~ScVbaBorders() {}
+
+	// XEnumerationAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+
+	// XBorders
+
+	// ScVbaCollectionBaseImpl	
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ); 
+	
+	virtual css::uno::Any SAL_CALL getColor() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setColor( const css::uno::Any& _color ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL getColorIndex() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setColorIndex( const css::uno::Any& _colorindex ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL getLineStyle() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setLineStyle( const css::uno::Any& _linestyle ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL getWeight() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setWeight( const  css::uno::Any& ) throw (css::uno::RuntimeException);
+};
+
+#endif //SC_VBA_BORDERS_HXX
+
Index: sc/source/ui/vba/vbacharacters.cxx
===================================================================
RCS file: sc/source/ui/vba/vbacharacters.cxx
diff -N sc/source/ui/vba/vbacharacters.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbacharacters.cxx	21 Feb 2007 17:29:16 -0000	1.1.2.2
@@ -0,0 +1,122 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbacharacters.hxx"
+
+#include "vbaglobals.hxx"
+#include "vbafont.hxx"
+
+
+using namespace ::org::openoffice;
+using namespace ::com::sun::star;
+
+ScVbaCharacters::ScVbaCharacters( const uno::Reference< uno::XComponentContext >& xContext, const ScVbaPalette& dPalette, const uno::Reference< text::XSimpleText>& xRange,const css::uno::Any& Start, const css::uno::Any& Length  ) throw ( css::lang::IllegalArgumentException ) : m_xSimpleText(xRange), m_xContext( xContext ), m_aPalette( dPalette),  nLength(-1), nStart(1)
+{
+	Start >>= nStart;
+	if ( nStart < 1 )
+		nStart = 1; // silently correct user error ( as ms )
+	nStart--; // OOo is 0 based
+	Length >>=nLength;			
+	uno::Reference< text::XTextCursor > xTextCursor( m_xSimpleText->createTextCursor(), uno::UNO_QUERY_THROW );
+	xTextCursor->collapseToStart();
+	if ( nStart )
+		xTextCursor->goRight( nStart, sal_False );
+	if ( nLength < 0 ) // expand to end
+		xTextCursor->gotoEnd( sal_True );
+	else
+		xTextCursor->goRight( nLength, sal_True );
+	m_xTextRange.set( xTextCursor, uno::UNO_QUERY_THROW );
+
+}
+
+::rtl::OUString SAL_CALL 
+ScVbaCharacters::getCaption() throw (css::uno::RuntimeException)
+{
+	return m_xTextRange->getString();
+}
+void SAL_CALL 
+ScVbaCharacters::setCaption( const ::rtl::OUString& _caption ) throw (css::uno::RuntimeException)
+{
+	m_xTextRange->setString( _caption );
+
+}
+
+::sal_Int32 SAL_CALL 
+ScVbaCharacters::getCount() throw (css::uno::RuntimeException)
+{
+	return getCaption().getLength();	
+}
+
+::rtl::OUString SAL_CALL 
+ScVbaCharacters::getText() throw (css::uno::RuntimeException)
+{
+	return getCaption();
+}
+void SAL_CALL 
+ScVbaCharacters::setText( const ::rtl::OUString& _text ) throw (css::uno::RuntimeException)
+{
+	setCaption( _text );
+}
+uno::Reference< excel::XFont > SAL_CALL 
+ScVbaCharacters::getFont() throw (css::uno::RuntimeException) 
+{
+	uno::Reference< beans::XPropertySet > xProps( m_xTextRange, uno::UNO_QUERY_THROW );
+	return uno::Reference< excel::XFont >( new ScVbaFont( m_aPalette, xProps ) );
+}
+void SAL_CALL 
+ScVbaCharacters::setFont( const uno::Reference< excel::XFont >& /*_font*/ ) throw (css::uno::RuntimeException)
+{
+	// #TODO #FIXME needs implementation, or can't be done?
+	throw uno::RuntimeException( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Not Implemented") ), uno::Reference< XInterface >() );
+}
+
+
+// Methods
+void SAL_CALL 
+ScVbaCharacters::Insert( const ::rtl::OUString& String ) throw (css::uno::RuntimeException)
+{
+	m_xSimpleText->insertString( m_xTextRange, String, sal_False );
+}
+
+void SAL_CALL 
+ScVbaCharacters::Delete(  ) throw (css::uno::RuntimeException)
+{
+	// #FIXME #TODO is this a bit suspect?, I wonder should the contents 
+	// of the cell be deleted from the parent ( range )
+	m_xSimpleText->setString(rtl::OUString()); 
+}
+
+
+
+
Index: sc/source/ui/vba/vbacharacters.hxx
===================================================================
RCS file: sc/source/ui/vba/vbacharacters.hxx
diff -N sc/source/ui/vba/vbacharacters.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbacharacters.hxx	21 Feb 2007 17:29:16 -0000	1.1.2.2
@@ -0,0 +1,79 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_CHARACTERS_HXX
+#define SC_VBA_CHARACTERS_HXX
+
+#include <cppuhelper/implbase1.hxx>
+
+#include <org/openoffice/excel/XCharacters.hpp>
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <com/sun/star/text/XSimpleText.hpp>
+
+#include "vbahelper.hxx"
+#include "vbapalette.hxx"
+typedef ::cppu::WeakImplHelper1< oo::excel::XCharacters > ScVbaCharacters_BASE;
+
+class ScVbaCharacters : public ScVbaCharacters_BASE
+{
+private:
+	css::uno::Reference< css::text::XTextRange > m_xTextRange;
+	css::uno::Reference< css::text::XSimpleText > m_xSimpleText;
+	css::uno::Reference< css::uno::XComponentContext > m_xContext;
+	ScVbaPalette m_aPalette;
+	sal_Int16 nLength;
+	sal_Int16 nStart;
+public:
+	ScVbaCharacters( const css::uno::Reference< css::uno::XComponentContext >& xContext,  const ScVbaPalette& dPalette, const css::uno::Reference< css::text::XSimpleText >& xRange, const css::uno::Any& Start, const css::uno::Any& Length  ) throw ( css::lang::IllegalArgumentException );
+
+	virtual ~ScVbaCharacters() {}
+	// Attributes
+	virtual ::rtl::OUString SAL_CALL getCaption() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setCaption( const ::rtl::OUString& _caption ) throw (css::uno::RuntimeException);
+	virtual ::sal_Int32 SAL_CALL getCount() throw (css::uno::RuntimeException);
+	virtual ::rtl::OUString SAL_CALL getText() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setText( const ::rtl::OUString& _text ) throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< oo::excel::XFont > SAL_CALL getFont() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setFont( const css::uno::Reference< oo::excel::XFont >& _font ) throw (css::uno::RuntimeException);
+
+	// Methods
+	virtual void SAL_CALL Insert( const ::rtl::OUString& String ) throw (css::uno::RuntimeException);
+	virtual void SAL_CALL Delete(  ) throw (css::uno::RuntimeException);
+
+
+
+};
+
+#endif /* SC_VBA_CHARACTER_HXX */
+
Index: sc/source/ui/vba/vbachart.cxx
===================================================================
RCS file: sc/source/ui/vba/vbachart.cxx
diff -N sc/source/ui/vba/vbachart.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbachart.cxx	21 Feb 2007 17:29:16 -0000	1.1.2.2
@@ -0,0 +1,63 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbachart.hxx"
+#include <com/sun/star/beans/XPropertySet.hpp>
+
+
+using namespace ::com::sun::star;
+using namespace ::org::openoffice;
+
+const rtl::OUString CHART_NAME( RTL_CONSTASCII_USTRINGPARAM("Name") );
+::rtl::OUString SAL_CALL 
+ScVbaChart::getName() throw (css::uno::RuntimeException)
+{
+	rtl::OUString sName;
+	uno::Reference< beans::XPropertySet > xProps( m_xChartDoc, uno::UNO_QUERY_THROW );
+	try
+	{
+		xProps->getPropertyValue( CHART_NAME ) >>= sName;
+	}
+	catch( uno::Exception e ) // swallow exceptions
+	{
+	}
+	return sName;
+}
+
+uno::Any  SAL_CALL
+ScVbaChart::SeriesCollection(const uno::Any&) throw (uno::RuntimeException)
+{
+	return uno::Any();
+}
+
Index: sc/source/ui/vba/vbachart.hxx
===================================================================
RCS file: sc/source/ui/vba/vbachart.hxx
diff -N sc/source/ui/vba/vbachart.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbachart.hxx	21 Feb 2007 17:29:17 -0000	1.1.2.2
@@ -0,0 +1,57 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_CHART_HXX
+#define SC_VBA_CHART_HXX
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <com/sun/star/chart/XChartDocument.hpp>
+#include <org/openoffice/excel/XChart.hpp>
+#include "vbahelper.hxx"
+
+typedef ::cppu::WeakImplHelper1<oo::excel::XChart > ChartImpl_BASE;
+
+class ScVbaChart : public ChartImpl_BASE
+{		
+
+	css::uno::Reference< css::uno::XComponentContext > m_xContext;
+	css::uno::Reference< css::chart::XChartDocument > m_xChartDoc;
+public:
+	ScVbaChart( const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::chart::XChartDocument >& xChartDoc ) : m_xContext(xContext), m_xChartDoc( xChartDoc ) {}
+	virtual ::rtl::OUString SAL_CALL getName() throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL SeriesCollection(const css::uno::Any&) throw (css::uno::RuntimeException);
+
+};
+
+#endif //SC_VBA_WINDOW_HXX
Index: sc/source/ui/vba/vbachartobject.cxx
===================================================================
RCS file: sc/source/ui/vba/vbachartobject.cxx
diff -N sc/source/ui/vba/vbachartobject.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbachartobject.cxx	21 Feb 2007 17:29:17 -0000	1.1.2.2
@@ -0,0 +1,108 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbachart.hxx"
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/document/XEmbeddedObjectSupplier.hpp>
+#include <com/sun/star/container/XNamed.hpp>
+
+#include "vbachartobject.hxx"
+
+using namespace ::com::sun::star;
+using namespace ::org::openoffice;
+
+const rtl::OUString CHART_NAME( RTL_CONSTASCII_USTRINGPARAM("Name") );
+
+::rtl::OUString SAL_CALL 
+ScVbaChartObject::getName() throw (css::uno::RuntimeException)
+{
+	rtl::OUString sName;
+	uno::Reference< container::XNamed > xNamed( m_xTableChart, uno::UNO_QUERY );
+	if ( xNamed.is() )
+		sName = xNamed->getName();
+	return sName;
+}
+
+
+
+uno::Reference< excel::XChart > SAL_CALL 
+ScVbaChartObject::getChart() throw (css::uno::RuntimeException)
+{
+	uno::Reference< document::XEmbeddedObjectSupplier > xEmbed( m_xTableChart, uno::UNO_QUERY_THROW );
+	uno::Reference< chart::XChartDocument > xChart( xEmbed->getEmbeddedObject(), uno::UNO_QUERY_THROW );
+
+	// #TODO check with vba to see whether its valid to return a 
+	// null object for the Chart property. atm, we throw ( i.e. if in
+	// doubt... throw ) 
+	
+	return new ScVbaChart( m_xContext, xChart );
+}
+/*
+#include<cppuhelper/implbase1.hxx>
+#include<org/openoffice/vba/XChartObject.hpp>
+#include"vbacollectionimpl.hxx"
+
+typedef ::cppu::ImplInheritanceHelper1< ScVbaCollectionBaseImpl, oo::vba::XChartObject > XSeriesCollectionBase;
+class MyCollectionImpl : public XSeriesCollectionBase
+{
+public:
+	//MyCollectionImpl( css::uno::Reference< css::uno::XComponentContext >& xContext ) : ScVbaCollectionBaseImpl( xContext ) {}
+	MyCollectionImpl( css::uno::Reference< css::uno::XComponentContext >& xContext ) : XSeriesCollectionBase( xContext ) {}
+        virtual ::rtl::OUString SAL_CALL getName() throw (css::uno::RuntimeException)
+	{
+		OSL_TRACE("**** In Get Name for mangled object");
+		rtl::OUString dummy;
+		return dummy;
+	}
+        virtual css::uno::Any test() throw (css::uno::RuntimeException)
+	{
+		OSL_TRACE("**** In test  for mangled object");
+		return uno::Any();
+	}
+	virtual css::uno::Reference< oo::vba::XChart > SAL_CALL getChart() throw (css::uno::RuntimeException)
+	{
+		OSL_TRACE("**** In getChart  for mangled object");
+		return css::uno::Reference< oo::vba::XChart >();
+	}
+
+};
+*/
+
+uno::Any SAL_CALL
+ScVbaChartObject::test()throw (css::uno::RuntimeException)
+{
+	return uno::Any();
+}
+
+
Index: sc/source/ui/vba/vbachartobject.hxx
===================================================================
RCS file: sc/source/ui/vba/vbachartobject.hxx
diff -N sc/source/ui/vba/vbachartobject.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbachartobject.hxx	21 Feb 2007 17:29:17 -0000	1.1.2.2
@@ -0,0 +1,58 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_CHARTOBJECT_HXX
+#define SC_VBA_CHARTOBJECT_HXX
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <com/sun/star/table/XTableChart.hpp>
+#include <org/openoffice/excel/XChartObject.hpp>
+#include "vbahelper.hxx"
+
+typedef ::cppu::WeakImplHelper1<oo::excel::XChartObject > ChartObjectImpl_BASE;
+
+class ScVbaChartObject : public ChartObjectImpl_BASE
+{		
+
+	css::uno::Reference< css::uno::XComponentContext > m_xContext;
+	css::uno::Reference< css::table::XTableChart  > m_xTableChart;
+public:
+	ScVbaChartObject( const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::table::XTableChart >& xTableChart ) : m_xContext(xContext), m_xTableChart( xTableChart ) {}
+	virtual ::rtl::OUString SAL_CALL getName() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< oo::excel::XChart > SAL_CALL getChart() throw (css::uno::RuntimeException);
+	
+	virtual css::uno::Any SAL_CALL test(  ) throw (css::uno::RuntimeException); 
+};
+
+#endif //SC_VBA_WINDOW_HXX
Index: sc/source/ui/vba/vbachartobjects.cxx
===================================================================
RCS file: sc/source/ui/vba/vbachartobjects.cxx
diff -N sc/source/ui/vba/vbachartobjects.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbachartobjects.cxx	21 Feb 2007 17:29:17 -0000	1.1.2.2
@@ -0,0 +1,86 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbachart.hxx"
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/document/XEmbeddedObjectSupplier.hpp>
+
+
+#include "vbachartobjects.hxx"
+#include "vbachartobject.hxx"
+#include "vbaglobals.hxx"
+
+using namespace ::com::sun::star;
+using namespace ::org::openoffice;
+
+
+class ChartObjectEnumerationImpl : public EnumerationHelperImpl
+{
+public:
+
+	ChartObjectEnumerationImpl( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< container::XEnumeration >& xEnumeration ) throw ( uno::RuntimeException ) : EnumerationHelperImpl( xContext, xEnumeration ) {}
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException) 
+	{ 
+		uno::Reference< table::XTableChart > xTableChart( m_xEnumeration->nextElement(), uno::UNO_QUERY_THROW );
+		return uno::makeAny( uno::Reference< excel::XChartObject > ( new ScVbaChartObject( m_xContext, xTableChart ) ) );
+	}
+};
+
+
+
+// XEnumerationAccess
+
+uno::Reference< container::XEnumeration >
+ScVbaChartObjects::createEnumeration() throw (uno::RuntimeException)
+{
+	css::uno::Reference< container::XEnumerationAccess > xEnumAccess( m_xTableCharts, uno::UNO_QUERY_THROW );
+	return new ChartObjectEnumerationImpl( m_xContext, xEnumAccess->createEnumeration() );
+}
+
+// XElementAccess
+
+uno::Type 
+ScVbaChartObjects::getElementType() throw (uno::RuntimeException)
+{
+	return excel::XChartObject::static_type(0);
+}
+
+// ScVbaCollectionBaseImpl
+uno::Any
+ScVbaChartObjects::createCollectionObject( const css::uno::Any& aSource )
+{	
+	uno::Reference< table::XTableChart > xTableChart( aSource, uno::UNO_QUERY_THROW );
+	return uno::makeAny( uno::Reference< excel::XChartObject > ( new ScVbaChartObject( m_xContext, xTableChart ) ) );
+}
+
Index: sc/source/ui/vba/vbachartobjects.hxx
===================================================================
RCS file: sc/source/ui/vba/vbachartobjects.hxx
diff -N sc/source/ui/vba/vbachartobjects.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbachartobjects.hxx	21 Feb 2007 17:29:17 -0000	1.1.2.2
@@ -0,0 +1,63 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_CHARTOBJECTS_HXX
+#define SC_VBA_CHARTOBJECTS_HXX
+#include <org/openoffice/excel/XChartObjects.hpp>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <com/sun/star/table/XTableCharts.hpp>
+#include <com/sun/star/container/XEnumerationAccess.hpp>
+#include"vbacollectionimpl.hxx"
+#include "vbahelper.hxx"
+
+
+typedef ::cppu::ImplInheritanceHelper1< ScVbaCollectionBaseImpl, oo::excel::XChartObjects > ChartObjects_BASE;
+
+class ScVbaChartObjects : public ChartObjects_BASE
+{		
+
+	css::uno::Reference< css::uno::XComponentContext > m_xContext;
+	css::uno::Reference< css::table::XTableCharts > m_xTableCharts;
+public:
+	ScVbaChartObjects( const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::table::XTableCharts >& xTableCharts ) : ChartObjects_BASE(xContext, css::uno::Reference< css::container::XIndexAccess >( xTableCharts, css::uno::UNO_QUERY ) ), m_xContext(xContext), m_xTableCharts( xTableCharts ) {}
+	// XEnumerationAccess
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+	// XElementAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	// ScVbaCollectionBaseImpl	
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ); 
+};
+
+#endif //SC_VBA_WINDOW_HXX
Index: sc/source/ui/vba/vbacollectionimpl.cxx
===================================================================
RCS file: sc/source/ui/vba/vbacollectionimpl.cxx
diff -N sc/source/ui/vba/vbacollectionimpl.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbacollectionimpl.cxx	21 Feb 2007 17:29:17 -0000	1.1.2.2
@@ -0,0 +1,141 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include <vbacollectionimpl.hxx>
+#include "vbaglobals.hxx"
+using namespace ::com::sun::star;
+using namespace ::org::openoffice;
+
+
+ScVbaCollectionBaseImpl::ScVbaCollectionBaseImpl( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< container::XIndexAccess >& xIndexAccess ) throw (uno::RuntimeException) : m_xContext( xContext ), m_xIndexAccess( xIndexAccess )
+{
+	m_xNameAccess.set( xIndexAccess, uno::UNO_QUERY );
+}
+
+uno::Any
+ScVbaCollectionBaseImpl::getItemByStringIndex( const rtl::OUString& sIndex ) throw (::uno::RuntimeException)
+{
+	if ( !m_xNameAccess.is() )
+		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ScVbaCollectionBaseImpl string index access not supported by this object") ), uno::Reference< uno::XInterface >() );
+
+	return createCollectionObject( m_xNameAccess->getByName( sIndex ) );	
+}
+
+uno::Any 
+ScVbaCollectionBaseImpl::getItemByIntIndex( const sal_Int32 nIndex ) throw (uno::RuntimeException)
+{
+	if ( !m_xIndexAccess.is() )
+		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ScVbaCollectionBaseImpl numeric index access not supported by this object") ), uno::Reference< uno::XInterface >() );
+	if ( nIndex <= 0 )
+	{
+		throw  lang::IndexOutOfBoundsException( 
+			::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( 
+			"index is 0 or negative" ) ), 
+			uno::Reference< uno::XInterface >() );
+	}
+	// need to adjust for vba index ( for which first element is 1 )
+	return createCollectionObject( m_xIndexAccess->getByIndex( nIndex - 1 ) );	
+}
+
+::sal_Int32 SAL_CALL 
+ScVbaCollectionBaseImpl::getCount() throw (uno::RuntimeException)
+{
+	return m_xIndexAccess->getCount();
+}
+
+uno::Any SAL_CALL 
+ScVbaCollectionBaseImpl::getParent() throw (uno::RuntimeException)
+{
+	// #TODO #FIXME investigate whether this makes sense
+	uno::Reference< excel::XApplication > xApplication =
+		ScVbaGlobals::getGlobalsImpl( m_xContext )->getApplication();
+	uno::Reference< excel::XWorkbook > xWorkbook;
+	if ( xApplication.is() )
+	{
+		xWorkbook = xApplication->getActiveWorkbook();
+	}
+	return uno::Any( xWorkbook );
+}
+
+::sal_Int32 SAL_CALL ScVbaCollectionBaseImpl::getCreator() throw (uno::RuntimeException)
+{
+	// #TODO #FIXE some sort of implementation
+	//SC_VBA_STUB();
+	return 0;
+}
+uno::Reference< excel::XApplication > SAL_CALL ScVbaCollectionBaseImpl::getApplication() throw (uno::RuntimeException)
+{
+	// #TODO #FIXME investigate whether this makes sense
+	uno::Reference< excel::XApplication > xApplication =
+		ScVbaGlobals::getGlobalsImpl( m_xContext )->getApplication();
+	return  xApplication;
+}
+
+uno::Any SAL_CALL ScVbaCollectionBaseImpl::Item( const uno::Any& aIndex ) throw (uno::RuntimeException)
+{
+	if ( aIndex.getValueTypeClass() != uno::TypeClass_STRING )
+	{
+		sal_Int32 nIndex = 0;
+
+		if ( ( aIndex >>= nIndex ) != sal_True )
+		{
+			rtl::OUString message;
+			message = rtl::OUString::createFromAscii(
+				"Couldn't convert index to Int32");
+			throw  lang::IndexOutOfBoundsException( message,
+				uno::Reference< uno::XInterface >() );
+		}
+		return 	getItemByIntIndex( nIndex );
+	}
+	rtl::OUString aStringSheet;
+
+	aIndex >>= aStringSheet;
+	return getItemByStringIndex( aStringSheet );	
+}
+
+::rtl::OUString SAL_CALL 
+ScVbaCollectionBaseImpl::getDefaultMethodName(  ) throw (css::uno::RuntimeException)
+{
+	const static rtl::OUString sName( RTL_CONSTASCII_USTRINGPARAM("Item") );
+	return sName;
+}
+
+	// XElementAccess
+
+::sal_Bool SAL_CALL ScVbaCollectionBaseImpl::hasElements() throw (uno::RuntimeException)
+{
+	return ( m_xIndexAccess->getCount() > 0 );
+}
+
+
Index: sc/source/ui/vba/vbacollectionimpl.hxx
===================================================================
RCS file: sc/source/ui/vba/vbacollectionimpl.hxx
diff -N sc/source/ui/vba/vbacollectionimpl.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbacollectionimpl.hxx	21 Feb 2007 17:29:17 -0000	1.1.2.2
@@ -0,0 +1,106 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_COLLECTION_IMPL_HXX
+#define SC_VBA_COLLECTION_IMPL_HXX
+
+#include <org/openoffice/vba/XCollection.hpp>
+#include <com/sun/star/container/XEnumerationAccess.hpp>
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <com/sun/star/script/XDefaultMethod.hpp>
+#include <com/sun/star/container/XIndexAccess.hpp>
+#include <com/sun/star/container/XNameAccess.hpp>
+
+#include <cppuhelper/implbase3.hxx>
+#include <cppuhelper/implbase2.hxx>
+#include <cppuhelper/implbase1.hxx>
+
+#include "vbahelper.hxx"
+
+
+typedef ::cppu::WeakImplHelper1< css::container::XEnumeration > EnumerationHelper_BASE;
+
+class EnumerationHelperImpl : public EnumerationHelper_BASE
+{
+protected:
+	css::uno::Reference< css::uno::XComponentContext > m_xContext;
+	css::uno::Reference< css::container::XEnumeration > m_xEnumeration;
+public:
+
+	EnumerationHelperImpl( const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::container::XEnumeration >& xEnumeration ) throw ( css::uno::RuntimeException ) : m_xContext( xContext ),  m_xEnumeration( xEnumeration ) { }
+	virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (css::uno::RuntimeException) { return m_xEnumeration->hasMoreElements(); }
+	//virtual css::uno::Any SAL_CALL nextElement(  ) throw (css::container::NoSuchElementException, css::lang::WrappedTargetException, css::uno::RuntimeException) = 0; 
+};
+
+
+
+typedef ::cppu::WeakImplHelper3<oo::vba::XCollection,
+css::container::XEnumerationAccess, css::script::XDefaultMethod > XCollection_BASE;
+
+class ScVbaCollectionBaseImpl : public XCollection_BASE
+{
+protected:
+	css::uno::Reference< css::uno::XComponentContext > m_xContext;
+
+	css::uno::Reference< css::container::XIndexAccess > m_xIndexAccess;
+	css::uno::Reference< css::container::XNameAccess > m_xNameAccess;
+
+	virtual css::uno::Any getItemByStringIndex( const rtl::OUString& sIndex ) throw (css::uno::RuntimeException);
+
+	virtual css::uno::Any getItemByIntIndex( const sal_Int32 nIndex ) throw (css::uno::RuntimeException);
+public:
+	ScVbaCollectionBaseImpl( const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::container::XIndexAccess >& xIndexAccess ) throw( css::uno::RuntimeException );
+
+	//XCollection
+	virtual ::sal_Int32 SAL_CALL getCount() throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL getParent() throw (css::uno::RuntimeException);
+	virtual ::sal_Int32 SAL_CALL getCreator() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< oo::excel::XApplication > SAL_CALL getApplication() throw (css::uno::RuntimeException);
+
+	virtual css::uno::Any SAL_CALL Item( const css::uno::Any& Index ) throw (css::uno::RuntimeException);
+	// XDefaultMethod
+	::rtl::OUString SAL_CALL getDefaultMethodName(  ) throw (css::uno::RuntimeException);
+
+	// XEnumerationAccess
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException) = 0;	
+
+	// XElementAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException) = 0;
+
+	virtual ::sal_Bool SAL_CALL hasElements() throw (css::uno::RuntimeException);
+
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ) = 0;
+
+};
+#endif //SC_VBA_COLLECTION_IMPL_HXX
Index: sc/source/ui/vba/vbacombobox.cxx
===================================================================
RCS file: sc/source/ui/vba/vbacombobox.cxx
diff -N sc/source/ui/vba/vbacombobox.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbacombobox.cxx	5 Mar 2007 13:52:57 -0000	1.1.2.3
@@ -0,0 +1,141 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbacombobox.hxx"
+#include <vector>
+
+using namespace com::sun::star;
+using namespace org::openoffice;
+
+
+const static rtl::OUString CONTROLSOURCEPROP( RTL_CONSTASCII_USTRINGPARAM("DataFieldProperty") );
+const static rtl::OUString ITEMS( RTL_CONSTASCII_USTRINGPARAM("StringItemList") );
+
+ScVbaComboBox::ScVbaComboBox( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< beans::XPropertySet >& xProps ) : m_xContext(xContext), m_xProps( xProps ) 
+{
+	// grab the default value property name
+	m_xProps->getPropertyValue( CONTROLSOURCEPROP ) >>= sSourceName;
+}
+
+
+// Attributes
+uno::Any SAL_CALL 
+ScVbaComboBox::getValue() throw (uno::RuntimeException)
+{
+	return m_xProps->getPropertyValue( sSourceName );
+}
+
+void SAL_CALL 
+ScVbaComboBox::setValue( const uno::Any& _value ) throw (uno::RuntimeException)
+{
+	m_xProps->setPropertyValue( sSourceName, _value );
+}
+
+::rtl::OUString SAL_CALL 
+ScVbaComboBox::getText() throw (uno::RuntimeException)
+{
+	rtl::OUString result;
+	getValue() >>= result;
+	return result;
+}
+
+void SAL_CALL 
+ScVbaComboBox::setText( const ::rtl::OUString& _text ) throw (uno::RuntimeException)
+{
+	setValue( uno::makeAny( _text ) ); // seems the same
+}
+
+// Methods
+void SAL_CALL 
+ScVbaComboBox::AddItem( const uno::Any& pvargItem, const uno::Any& pvargIndex ) throw (uno::RuntimeException)
+{
+	if ( pvargItem.hasValue()  )
+	{
+		uno::Sequence< rtl::OUString > sList;
+		m_xProps->getPropertyValue( ITEMS ) >>= sList;
+
+		sal_Int32 nIndex = sList.getLength();
+
+		if ( pvargIndex.hasValue() )
+			pvargIndex >>= nIndex;
+
+		rtl::OUString sString;
+		pvargItem >>= sString;
+
+		// if no index specified or item is to be appended to end of 
+		// list just realloc the array and set the last item
+		if ( nIndex  == sList.getLength() )
+		{
+			sal_Int32 nOldSize = sList.getLength();
+			sList.realloc( nOldSize + 1 );
+			sList[ nOldSize ] = sString; 
+		}
+		else
+		{
+			// just copy those elements above the one to be inserted
+			std::vector< rtl::OUString > sVec;
+			// reserve just the amount we need to copy
+			sVec.reserve( sList.getLength() - nIndex );
+
+			// point at first element to copy
+			rtl::OUString* pString = sList.getArray() + nIndex;
+			const rtl::OUString* pEndString = sList.getArray() + sList.getLength();
+			// insert the new element
+			sVec.push_back( sString );
+			// copy elements	
+			for ( ; pString != pEndString; ++pString )
+				sVec.push_back( *pString );
+		
+			sList.realloc(  sList.getLength() + 1 );
+
+			// point at first element to be overwritten
+			pString = sList.getArray() + nIndex;
+			pEndString = sList.getArray() + sList.getLength();
+			std::vector< rtl::OUString >::iterator it = sVec.begin();
+			for ( ; pString != pEndString; ++pString, ++it)
+				*pString = *it;	
+			//
+		}
+
+		m_xProps->setPropertyValue( ITEMS, uno::makeAny( sList ) );
+		
+	}
+}
+
+void SAL_CALL 
+ScVbaComboBox::Clear(  ) throw (uno::RuntimeException)
+{
+		setValue( uno::makeAny( rtl::OUString() ) );
+		m_xProps->setPropertyValue( ITEMS, uno::makeAny( uno::Sequence< rtl::OUString >() ) );
+}
Index: sc/source/ui/vba/vbacombobox.hxx
===================================================================
RCS file: sc/source/ui/vba/vbacombobox.hxx
diff -N sc/source/ui/vba/vbacombobox.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbacombobox.hxx	5 Mar 2007 13:52:57 -0000	1.1.2.3
@@ -0,0 +1,75 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_COMBOBOX_HXX
+#define SC_VBA_COMBOBOX_HXX
+#include <cppuhelper/implbase2.hxx>
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/script/XDefaultProperty.hpp>
+#include <org/openoffice/msforms/XComboBox.hpp>
+#include <comphelper/proparrhlp.hxx>
+#include <comphelper/propertycontainer.hxx>
+#include <com/sun/star/beans/PropertyAttribute.hpp>
+
+#include "vbahelper.hxx"
+
+typedef ::cppu::WeakImplHelper2<oo::msforms::XComboBox, css::script::XDefaultProperty > ComboBoxImpl_BASE;
+class ScVbaComboBox : public ComboBoxImpl_BASE
+{		
+
+	css::uno::Reference< css::uno::XComponentContext > m_xContext;
+	css::uno::Reference< css::beans::XPropertySet > m_xProps;
+	rtl::OUString sSourceName; 
+	rtl::OUString msDftPropName;
+
+	
+public:
+	ScVbaComboBox( const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::beans::XPropertySet >& xProps );
+
+	// Attributes
+	virtual css::uno::Any SAL_CALL getValue() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setValue( const css::uno::Any& _value ) throw (css::uno::RuntimeException);
+	virtual ::rtl::OUString SAL_CALL getText() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setText( const ::rtl::OUString& _text ) throw (css::uno::RuntimeException);
+
+	// Methods
+	virtual void SAL_CALL AddItem( const css::uno::Any& pvargItem, const css::uno::Any& pvargIndex ) throw (css::uno::RuntimeException);
+	virtual void SAL_CALL Clear(  ) throw (css::uno::RuntimeException);
+
+	// XDefaultProperty
+        ::rtl::OUString SAL_CALL getDefaultPropertyName(  ) throw (css::uno::RuntimeException) { return ::rtl::OUString::createFromAscii("Value"); }
+};
+
+#endif //
Index: sc/source/ui/vba/vbacomment.cxx
===================================================================
RCS file: sc/source/ui/vba/vbacomment.cxx
diff -N sc/source/ui/vba/vbacomment.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbacomment.cxx	21 Feb 2007 17:29:18 -0000	1.1.2.2
@@ -0,0 +1,233 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbacomment.hxx"
+
+#include <org/openoffice/excel/XlCreator.hpp>
+#include <com/sun/star/sheet/XSpreadsheet.hpp>
+#include <com/sun/star/sheet/XSheetAnnotationAnchor.hpp>
+#include <com/sun/star/sheet/XSheetAnnotationsSupplier.hpp>
+#include <com/sun/star/sheet/XSheetCellRange.hpp>
+#include <com/sun/star/table/CellAddress.hpp>
+#include <com/sun/star/table/XCell.hpp>
+#include <com/sun/star/text/XText.hpp>
+
+#include "vbaglobals.hxx"
+#include "vbacomments.hxx"
+
+
+using namespace ::org::openoffice;
+using namespace ::com::sun::star;
+
+ScVbaComment::ScVbaComment( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< table::XCellRange >& xRange ) throw( lang::IllegalArgumentException )
+: mxRange( xRange ), m_xContext( xContext )
+{
+	if  ( !xContext.is() )
+		throw lang::IllegalArgumentException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "context is not set " ) ), uno::Reference< uno::XInterface >() , 1 );
+	if  ( !xRange.is() )
+		throw lang::IllegalArgumentException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "range is not set " ) ), uno::Reference< uno::XInterface >() , 1 );
+	uno::Reference< text::XSimpleText > xAnnoText( getAnnotation(), uno::UNO_QUERY );
+}
+
+// private helper functions
+
+uno::Reference< sheet::XSheetAnnotation > SAL_CALL
+ScVbaComment::getAnnotation() throw (uno::RuntimeException)
+{
+	uno::Reference< table::XCell > xCell( mxRange->getCellByPosition(0, 0), uno::UNO_QUERY_THROW );
+	uno::Reference< sheet::XSheetAnnotationAnchor > xAnnoAnchor( xCell, uno::UNO_QUERY_THROW );
+	return uno::Reference< sheet::XSheetAnnotation > ( xAnnoAnchor->getAnnotation(), uno::UNO_QUERY_THROW );
+}
+
+uno::Reference< sheet::XSheetAnnotations > SAL_CALL
+ScVbaComment::getAnnotations() throw (uno::RuntimeException)
+{
+	uno::Reference< sheet::XSheetCellRange > xSheetCellRange(mxRange, ::uno::UNO_QUERY_THROW );
+	uno::Reference< sheet::XSpreadsheet > xSheet = xSheetCellRange->getSpreadsheet();
+	uno::Reference< sheet::XSheetAnnotationsSupplier > xAnnosSupp( xSheet, uno::UNO_QUERY_THROW );
+
+	return uno::Reference< sheet::XSheetAnnotations > ( xAnnosSupp->getAnnotations(), uno::UNO_QUERY_THROW );
+}
+
+sal_Int32 SAL_CALL
+ScVbaComment::getAnnotationIndex() throw (uno::RuntimeException)
+{
+	uno::Reference< sheet::XSheetAnnotations > xAnnos = getAnnotations();
+	table::CellAddress aAddress = getAnnotation()->getPosition();
+
+	sal_Int32 aIndex = 0;
+	sal_Int32 aCount = xAnnos->getCount();
+
+	for ( ; aIndex < aCount ; aIndex++ )
+	{
+		uno::Reference< sheet::XSheetAnnotation > xAnno( xAnnos->getByIndex( aIndex ), uno::UNO_QUERY_THROW );
+		table::CellAddress xAddress = xAnno->getPosition();
+	
+		if ( xAddress.Column == aAddress.Column && xAddress.Row == aAddress.Row && xAddress.Sheet == aAddress.Sheet )
+		{
+			OSL_TRACE("** terminating search, index is %d", aIndex );
+			break;
+		}
+	}
+	OSL_TRACE("** returning index is %d", aIndex );
+
+       return aIndex;
+}
+
+uno::Reference< excel::XComment > SAL_CALL
+ScVbaComment::getCommentByIndex( sal_Int32 Index ) throw (uno::RuntimeException)
+{
+	uno::Reference< container::XIndexAccess > xIndexAccess( getAnnotations(), uno::UNO_QUERY_THROW );
+	uno::Reference< vba::XCollection > xColl( uno::Reference< excel::XComments > ( new ScVbaComments( m_xContext, xIndexAccess ) ), uno::UNO_QUERY_THROW );
+
+	return uno::Reference< excel::XComment > ( xColl->Item( uno::makeAny( Index ) ), uno::UNO_QUERY_THROW );
+ }
+
+// public vba functions
+
+uno::Reference< excel::XApplication > SAL_CALL
+ScVbaComment::getApplication() throw (uno::RuntimeException)
+{
+	uno::Reference< excel::XApplication > xApplication =
+		ScVbaGlobals::getGlobalsImpl( m_xContext )->getApplication();
+	if ( xApplication.is() )
+		return xApplication;
+	return uno::Reference< excel::XApplication >(NULL);
+}
+
+rtl::OUString SAL_CALL
+ScVbaComment::getAuthor() throw (uno::RuntimeException)
+{
+	return getAnnotation()->getAuthor();
+}
+
+void SAL_CALL
+ScVbaComment::setAuthor( const rtl::OUString& /*_author*/ ) throw (uno::RuntimeException)
+{
+	// #TODO #FIXME  implementation needed
+}
+
+sal_Int32 SAL_CALL
+ScVbaComment::getCreator() throw (uno::RuntimeException)
+{
+	return excel::XlCreator::xlCreatorCode;
+}
+
+uno::Reference< excel::XRange > SAL_CALL
+ScVbaComment::getParent() throw (uno::RuntimeException)
+{
+	uno::Reference< excel::XApplication > xApplication =
+		ScVbaGlobals::getGlobalsImpl( m_xContext )->getApplication();
+	if ( xApplication.is() )
+		return xApplication->getActiveCell();
+	return uno::Reference< excel::XRange >(NULL);
+}
+
+sal_Bool SAL_CALL
+ScVbaComment::getVisible() throw (uno::RuntimeException)
+{
+	return getAnnotation()->getIsVisible();
+}
+
+void SAL_CALL
+ScVbaComment::setVisible( sal_Bool _visible ) throw (uno::RuntimeException)
+{
+	getAnnotation()->setIsVisible( _visible );
+}
+
+void SAL_CALL
+ScVbaComment::Delete() throw (uno::RuntimeException)
+{
+	getAnnotations()->removeByIndex( getAnnotationIndex() );
+}
+
+uno::Reference< excel::XComment > SAL_CALL
+ScVbaComment::Next() throw (uno::RuntimeException)
+{
+	// index: uno = 0, vba = 1
+	return getCommentByIndex( getAnnotationIndex() + 2 );
+}
+
+uno::Reference< excel::XComment > SAL_CALL
+ScVbaComment::Previous() throw (uno::RuntimeException)
+{
+	// index: uno = 0, vba = 1
+	return getCommentByIndex( getAnnotationIndex() );
+}
+
+rtl::OUString SAL_CALL
+ScVbaComment::Text( const uno::Any& aText, const uno::Any& aStart, const uno::Any& Overwrite ) throw (uno::RuntimeException)
+{
+	rtl::OUString sText;
+	aText >>= sText;
+
+	uno::Reference< text::XSimpleText > xAnnoText( getAnnotation(), uno::UNO_QUERY_THROW );
+	rtl::OUString sAnnoText = xAnnoText->getString();
+
+	if ( aStart.hasValue() )
+	{
+		sal_Int16 nStart;
+		sal_Bool bOverwrite = sal_True;
+		Overwrite >>= bOverwrite;
+
+		if ( aStart >>= nStart )
+		{
+			uno::Reference< text::XTextCursor > xTextCursor( xAnnoText->createTextCursor(), uno::UNO_QUERY_THROW );
+
+			if ( bOverwrite )
+			{
+				xTextCursor->collapseToStart();
+				xTextCursor->gotoStart( sal_False );
+				xTextCursor->goRight( nStart - 1, sal_False );
+				xTextCursor->gotoEnd( sal_True );
+			}
+			else
+			{
+				xTextCursor->collapseToStart();
+				xTextCursor->gotoStart( sal_False );
+				xTextCursor->goRight( nStart - 1 , sal_True );
+			}
+
+			uno::Reference< text::XTextRange > xRange( xTextCursor, uno::UNO_QUERY_THROW );
+			xAnnoText->insertString( xRange, sText, bOverwrite );
+		}
+		else
+			throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "ScVbaComment::Text - bad Start value " ) ), uno::Reference< uno::XInterface >() );
+	}
+	else if ( aText.hasValue() )
+		xAnnoText->setString( sText );
+
+	return sAnnoText;
+}
+
Index: sc/source/ui/vba/vbacomment.hxx
===================================================================
RCS file: sc/source/ui/vba/vbacomment.hxx
diff -N sc/source/ui/vba/vbacomment.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbacomment.hxx	21 Feb 2007 17:29:18 -0000	1.1.2.2
@@ -0,0 +1,83 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_COMMENT_HXX
+#define SC_VBA_COMMENT_HXX
+
+#include <cppuhelper/implbase1.hxx>
+
+#include <org/openoffice/excel/XComment.hpp>
+#include <org/openoffice/excel/XApplication.hpp>
+#include <com/sun/star/sheet/XSheetAnnotations.hpp>
+#include <com/sun/star/sheet/XSheetAnnotation.hpp>
+#include <com/sun/star/table/XCellRange.hpp>
+#include <com/sun/star/uno/XComponentContext.hpp>
+
+#include "vbahelper.hxx"
+
+typedef ::cppu::WeakImplHelper1< oo::excel::XComment > ScVbaComment_BASE;
+
+class ScVbaComment : public ScVbaComment_BASE
+{
+	css::uno::Reference< css::table::XCellRange > mxRange;
+	css::uno::Reference< css::uno::XComponentContext > m_xContext;
+
+private:
+	css::uno::Reference< css::sheet::XSheetAnnotation > SAL_CALL getAnnotation() throw (css::uno::RuntimeException);
+	css::uno::Reference< css::sheet::XSheetAnnotations > SAL_CALL getAnnotations() throw (css::uno::RuntimeException);
+	sal_Int32 SAL_CALL getAnnotationIndex() throw (css::uno::RuntimeException);
+	css::uno::Reference< oo::excel::XComment > SAL_CALL getCommentByIndex( sal_Int32 Index ) throw (css::uno::RuntimeException);
+public:
+    ScVbaComment( const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::table::XCellRange >& xRange ) throw ( css::lang::IllegalArgumentException );
+
+    virtual ~ScVbaComment() {}
+
+    // Attributes
+    virtual css::uno::Reference< oo::excel::XApplication > SAL_CALL getApplication() throw (css::uno::RuntimeException);
+    virtual rtl::OUString SAL_CALL getAuthor() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setAuthor( const rtl::OUString& _author ) throw (css::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getCreator() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< oo::excel::XRange > SAL_CALL getParent() throw (css::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL getVisible() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setVisible( sal_Bool _visible ) throw (css::uno::RuntimeException);
+
+    // Methods
+    virtual void SAL_CALL Delete() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< oo::excel::XComment > SAL_CALL Next() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< oo::excel::XComment > SAL_CALL Previous() throw (css::uno::RuntimeException);
+    virtual rtl::OUString SAL_CALL Text( const css::uno::Any& Text, const css::uno::Any& Start, const css::uno::Any& Overwrite ) throw (css::uno::RuntimeException);
+};
+
+#endif /* SC_VBA_COMMENT_HXX */
+
Index: sc/source/ui/vba/vbacomments.cxx
===================================================================
RCS file: sc/source/ui/vba/vbacomments.cxx
diff -N sc/source/ui/vba/vbacomments.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbacomments.cxx	21 Feb 2007 17:29:18 -0000	1.1.2.2
@@ -0,0 +1,92 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbacomments.hxx"
+
+#include <com/sun/star/container/XChild.hpp>
+#include <com/sun/star/sheet/XSheetAnnotation.hpp>
+
+#include "vbaglobals.hxx"
+
+using namespace ::org::openoffice;
+using namespace ::com::sun::star;
+
+uno::Any AnnotationToComment( const uno::Any& aSource, uno::Reference< uno::XComponentContext > & xContext )
+{
+	uno::Reference< sheet::XSheetAnnotation > xAnno( aSource, uno::UNO_QUERY_THROW );
+	uno::Reference< container::XChild > xChild( xAnno, uno::UNO_QUERY_THROW );
+	uno::Reference< table::XCellRange > xCellRange( xChild->getParent(), uno::UNO_QUERY_THROW );
+
+	return uno::makeAny( uno::Reference< excel::XComment > ( new ScVbaComment( xContext, xCellRange ) ) );
+}
+
+class CommentEnumeration : public EnumerationHelperImpl
+{
+public:
+	CommentEnumeration( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< container::XEnumeration >& xEnumeration ) throw ( uno::RuntimeException ) : EnumerationHelperImpl( xContext, xEnumeration ) {}
+
+	virtual uno::Any SAL_CALL nextElement() throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+	{ 
+		return AnnotationToComment( m_xEnumeration->nextElement(),  m_xContext );
+	}
+
+};
+
+ScVbaComments::ScVbaComments( const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< container::XIndexAccess >& xIndexAccess  )
+: ScVbaComments_BASE( xContext, xIndexAccess )
+{
+}
+
+// public helper functions
+
+uno::Reference< container::XEnumeration >
+ScVbaComments::createEnumeration() throw (uno::RuntimeException)
+{
+	uno::Reference< container::XEnumerationAccess > xEnumAccess( m_xIndexAccess, uno::UNO_QUERY_THROW );
+
+	return new CommentEnumeration( m_xContext, xEnumAccess->createEnumeration() );
+}
+
+uno::Any
+ScVbaComments::createCollectionObject( const css::uno::Any& aSource )
+{
+	return AnnotationToComment( aSource,  m_xContext );
+}
+
+uno::Type 
+ScVbaComments::getElementType() throw (uno::RuntimeException)
+{
+	return excel::XComments::static_type(0);
+}
+
Index: sc/source/ui/vba/vbacomments.hxx
===================================================================
RCS file: sc/source/ui/vba/vbacomments.hxx
diff -N sc/source/ui/vba/vbacomments.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbacomments.hxx	21 Feb 2007 17:29:18 -0000	1.1.2.2
@@ -0,0 +1,65 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_COMMENTS_HXX
+#define SC_VBA_COMMENTS_HXX
+
+#include <cppuhelper/implbase1.hxx>
+
+#include <org/openoffice/excel/XComments.hpp>
+
+#include "vbahelper.hxx"
+#include "vbacollectionimpl.hxx"
+#include "vbacomment.hxx"
+
+typedef ::cppu::ImplInheritanceHelper1< ScVbaCollectionBaseImpl, oo::excel::XComments > ScVbaComments_BASE;
+
+class ScVbaComments : public ScVbaComments_BASE
+{
+public:
+    ScVbaComments( const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::container::XIndexAccess >& xIndexAccess );
+
+    virtual ~ScVbaComments() {}
+
+    // XEnumerationAccess
+    virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+    // ScVbaCollectionBaseImpl	
+    virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ); 
+
+};
+
+#endif /* SC_VBA_COMMENTS_HXX */
+
Index: sc/source/ui/vba/vbadialog.cxx
===================================================================
RCS file: sc/source/ui/vba/vbadialog.cxx
diff -N sc/source/ui/vba/vbadialog.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbadialog.cxx	21 Feb 2007 17:29:18 -0000	1.1.2.2
@@ -0,0 +1,137 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include <comphelper/processfactory.hxx>
+
+#include <com/sun/star/lang/XMultiComponentFactory.hpp>
+#include <com/sun/star/frame/XModel.hpp>
+#include <org/openoffice/excel/XApplication.hpp>
+
+#include <tools/string.hxx>
+
+#include "vbahelper.hxx"
+#include "vbadialog.hxx"
+#include "vbaglobals.hxx"
+
+using namespace ::org::openoffice;
+using namespace ::com::sun::star;
+
+// fails silently
+void
+ScVbaDialog::Show() throw(uno::RuntimeException)
+{
+	rtl::OUString aURL;
+        uno::Reference< frame::XModel > xModel = getCurrentDocument();
+	if ( xModel.is() )
+	{
+		aURL = mapIndexToName( mnIndex );
+		if( aURL.getLength()  )
+			throw uno::RuntimeException(
+				::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( " Unable to open the specified dialog " ) ),
+				uno::Reference< XInterface > () );
+		dispatchRequests( xModel, aURL );
+	}
+}	
+
+uno::Any
+ScVbaDialog::getParent() throw (uno::RuntimeException)
+{
+	uno::Reference< vba::XGlobals > xGlobals = ScVbaGlobals::getGlobalsImpl( m_xContext );
+	uno::Reference< excel::XApplication > xApplication = xGlobals->getApplication();
+	if ( !xApplication.is() )
+	{
+		throw uno::RuntimeException(
+			::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "ScVbaDialgs::getParent: Couldn't access Application object") ),uno::Reference< XInterface >() );
+	}
+	return uno::Any(xApplication);
+}
+                                                                                                                             
+::sal_Int32
+ScVbaDialog::getCreator() throw (uno::RuntimeException)
+{
+	// #TODO #FIXME
+	return 0;
+}
+uno::Reference< excel::XApplication >
+ScVbaDialog::getApplication() throw (uno::RuntimeException)
+{
+	uno::Reference< excel::XApplication > xApplication =  ScVbaGlobals::getGlobalsImpl( m_xContext )->getApplication();
+	if ( !xApplication.is() )
+	{
+		throw uno::RuntimeException(
+		::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "ScVbaWorkbooks::getParent: Couldn't access Application object" ) ),
+		uno::Reference< XInterface >() );
+	}
+	return xApplication;
+}
+
+static const rtl::OUString aStringList[]=
+{
+	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:Open" ) ),
+	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:FormatCellDialog" ) ),
+	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:InsertCell" ) ),
+	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:Print" ) ),
+	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:PasteSpecial" ) ),
+	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:ToolProtectionDocument" ) ),
+	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:ColumnWidth" ) ),
+	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:DefineName" ) ),
+	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:ConfigureDialog" ) ),
+	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:HyperlinkDialog" ) ),
+	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:InsertGraphic" ) ),
+	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:InsertObject" ) ),
+	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:PageFormatDialog" ) ),
+	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:DataSort" ) ),
+	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:RowHeight" ) ),
+	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:AutoCorrectDlg" ) ),
+	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:ConditionalFormatDialog" ) ),
+	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:DataConsolidate" ) ),
+	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:CreateNames" ) ),
+	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:FillSeries" ) ),
+	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:Validation") ),
+	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:DefineLabelRange" ) ),
+	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:DataFilterAutoFilter" ) ),
+	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:DataFilterSpecialFilter" ) ),
+	rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:AutoFormat" ) )	
+};
+
+const sal_Int32 nDialogSize = sizeof( aStringList ) / sizeof( aStringList[ 0 ] );
+
+rtl::OUString 
+ScVbaDialog::mapIndexToName( sal_Int32 nIndex )
+{
+	if( nIndex < nDialogSize )
+		return aStringList[ nIndex ];
+	return rtl::OUString();
+}
+
Index: sc/source/ui/vba/vbadialog.hxx
===================================================================
RCS file: sc/source/ui/vba/vbadialog.hxx
diff -N sc/source/ui/vba/vbadialog.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbadialog.hxx	21 Feb 2007 17:29:19 -0000	1.1.2.2
@@ -0,0 +1,69 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_DIALOG_HXX
+#define SC_VBA_DIALOG_HXX
+
+#include <cppuhelper/implbase1.hxx>
+
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <org/openoffice/vba/XGlobals.hpp>
+#include <org/openoffice/excel/XApplication.hpp>
+#include <org/openoffice/excel/XDialog.hpp>
+ 
+#include "vbahelper.hxx"
+#include "vbadialog.hxx"
+
+typedef ::cppu::WeakImplHelper1< oo::excel::XDialog > ScVbaDialog_BASE;
+
+class ScVbaDialog : public ScVbaDialog_BASE
+{
+	sal_Int32 mnIndex;
+	css::uno::Reference< css::uno::XComponentContext > m_xContext;
+public:
+	ScVbaDialog( sal_Int32 nIndex, css::uno::Reference< css::uno::XComponentContext > xContext ):
+		mnIndex( nIndex ),
+		m_xContext( xContext ) {}
+	virtual ~ScVbaDialog() {}
+
+	// Attributes
+	virtual css::uno::Reference< oo::excel::XApplication > SAL_CALL getApplication() throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL getParent() throw (css::uno::RuntimeException);
+	virtual sal_Int32 SAL_CALL getCreator() throw(css::uno::RuntimeException);
+	// Methods
+	virtual void SAL_CALL Show() throw (css::uno::RuntimeException);
+	rtl::OUString mapIndexToName( sal_Int32 nIndex );
+};
+
+#endif /* SC_VBA_DIALOG_HXX */
Index: sc/source/ui/vba/vbadialogs.cxx
===================================================================
RCS file: sc/source/ui/vba/vbadialogs.cxx
diff -N sc/source/ui/vba/vbadialogs.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbadialogs.cxx	21 Feb 2007 17:29:19 -0000	1.1.2.2
@@ -0,0 +1,104 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include <comphelper/processfactory.hxx>
+
+#include <com/sun/star/lang/XMultiComponentFactory.hpp>
+#include <com/sun/star/frame/XModel.hpp>
+#include <org/openoffice/excel/XApplication.hpp>
+#include <org/openoffice/excel/XDialog.hpp>
+
+#include <tools/string.hxx>
+
+#include "vbahelper.hxx"
+#include "vbadialogs.hxx"
+#include "vbaglobals.hxx"
+#include "vbadialog.hxx"
+
+using namespace ::org::openoffice;
+using namespace ::com::sun::star;
+
+void
+ScVbaDialogs::Dummy() throw (uno::RuntimeException)
+{
+}
+
+uno::Any
+ScVbaDialogs::getParent() throw (uno::RuntimeException)
+{
+	uno::Reference< vba::XGlobals > xGlobals = ScVbaGlobals::getGlobalsImpl( m_xContext );
+	uno::Reference< excel::XApplication > xApplication = xGlobals->getApplication();
+	if ( !xApplication.is() )
+	{
+		throw uno::RuntimeException(
+			::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "ScVbaWorkbooks::getParent: Couldn't access Application				object") ),uno::Reference< XInterface >() );
+	}
+	return uno::Any(xApplication);
+}
+                                                                                                                             
+::sal_Int32
+ScVbaDialogs::getCreator() throw (uno::RuntimeException)
+{
+	// #FIXME #TODO
+	return 0;
+}
+uno::Reference< excel::XApplication >
+ScVbaDialogs::getApplication() throw (uno::RuntimeException)
+{
+	uno::Reference< excel::XApplication > xApplication =  ScVbaGlobals::getGlobalsImpl( m_xContext )->getApplication();
+	if ( !xApplication.is() )
+	{
+		throw uno::RuntimeException(
+		::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "ScVbaWorkbooks::getParent: Couldn't access Application object" ) ),
+		uno::Reference< XInterface >() );
+	}
+	return xApplication;
+}
+
+::sal_Int32
+ScVbaDialogs::getCount() throw (uno::RuntimeException)
+{
+	//#TODO #FIXEME
+	//SC_VBA_STUB();
+	return 0;
+}
+
+uno::Any
+ScVbaDialogs::Item( const uno::Any &aItem ) throw (uno::RuntimeException)
+{
+	sal_Int32 nIndex;
+	aItem >>= nIndex;
+	uno::Reference< excel::XDialog > aDialog( new ScVbaDialog( nIndex, m_xContext ) );
+	return uno::Any( aDialog );
+}
Index: sc/source/ui/vba/vbadialogs.hxx
===================================================================
RCS file: sc/source/ui/vba/vbadialogs.hxx
diff -N sc/source/ui/vba/vbadialogs.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbadialogs.hxx	21 Feb 2007 17:29:19 -0000	1.1.2.2
@@ -0,0 +1,68 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_DIALOGS_HXX
+#define SC_VBA_DIALOGS_HXX
+
+#include <cppuhelper/implbase1.hxx>
+
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <org/openoffice/excel/XDialogs.hpp>
+#include <org/openoffice/vba/XCollection.hpp>
+ 
+class ScModelObj;
+
+typedef ::cppu::WeakImplHelper1< oo::excel::XDialogs > ScVbaDialogs_BASE;
+
+class ScVbaDialogs : public ScVbaDialogs_BASE
+{
+	css::uno::Reference< css::uno::XComponentContext > & m_xContext;
+public:
+	ScVbaDialogs( css::uno::Reference< css::uno::XComponentContext > &xContext ):
+	m_xContext( xContext ) {} 
+	virtual ~ScVbaDialogs() {}
+
+	// XCollection
+	virtual ::sal_Int32 SAL_CALL getCount() throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL getParent() throw (css::uno::RuntimeException);
+	virtual ::sal_Int32 SAL_CALL getCreator() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< oo::excel::XApplication > SAL_CALL getApplication() 
+									throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL Item( const css::uno::Any& Index ) throw (css::uno::RuntimeException);
+
+	// XDialogs
+	virtual void SAL_CALL Dummy() throw (css::uno::RuntimeException);
+};
+
+#endif /* SC_VBA_DIALOGS_HXX */
Index: sc/source/ui/vba/vbafont.cxx
===================================================================
RCS file: sc/source/ui/vba/vbafont.cxx
diff -N sc/source/ui/vba/vbafont.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbafont.cxx	21 Feb 2007 17:29:19 -0000	1.1.2.2
@@ -0,0 +1,401 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include <com/sun/star/beans/XProperty.hpp>
+#include <com/sun/star/awt/FontWeight.hpp>
+#include <com/sun/star/awt/FontUnderline.hpp>
+#include <com/sun/star/awt/FontStrikeout.hpp>
+#include <com/sun/star/awt/FontSlant.hpp>
+#include <org/openoffice/excel/XlColorIndex.hpp>
+#include <org/openoffice/excel/XlUnderlineStyle.hpp>
+#include "vbafont.hxx"
+#include "scitems.hxx"
+
+using namespace ::org::openoffice;
+using namespace ::com::sun::star;
+
+// use local constants there is no need to expose these constants
+// externally. Looking at the Format->Character dialog it seem that 
+// these may infact be even be calculated. Leave hardcoded for now
+// #FIXEME #TBD investigate the code for dialog mentioned above
+
+// The font baseline is not specified.
+const short NORMAL = 0;
+
+// specifies a superscripted.
+const short SUPERSCRIPT = 33;
+
+// specifies a subscripted.
+const short SUBSCRIPT = -33;
+
+// specifies a hight of superscripted font 
+ const sal_Int8 SUPERSCRIPTHEIGHT = 58; 
+
+// specifies a hight of subscripted font 
+const sal_Int8 SUBSCRIPTHEIGHT = 58; 
+
+// specifies a hight of normal font 
+const short NORMALHEIGHT = 100; 
+
+ScVbaFont::ScVbaFont( const ScVbaPalette& dPalette, uno::Reference< beans::XPropertySet > xPropertySet, SfxItemSet* pDataSet  ) throw ( uno::RuntimeException ) : mxFont( xPropertySet, css::uno::UNO_QUERY_THROW ), mPalette( dPalette ),  mpDataSet( pDataSet )
+{
+}
+
+void 
+ScVbaFont::setSuperscript( const uno::Any& aValue ) throw ( uno::RuntimeException )
+{
+	
+	sal_Bool bValue = sal_False;
+	aValue >>= bValue;	
+	sal_Int16 nValue = NORMAL;
+	sal_Int8 nValue2 = NORMALHEIGHT;
+
+        if( bValue ) 
+	{
+		nValue = SUPERSCRIPT;
+	        nValue2 = SUPERSCRIPTHEIGHT;
+	}
+	mxFont->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharEscapement" ) ), ( uno::Any )nValue );
+ 	mxFont->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharEscapementHeight" ) ), ( uno::Any )nValue2 );
+}
+
+uno::Any
+ScVbaFont::getSuperscript() throw ( uno::RuntimeException )
+{
+	short nValue = 0;
+	mxFont->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharEscapement" ) ) ) >>= nValue;
+	return uno::makeAny( ( nValue == SUPERSCRIPT ) );
+}
+
+void 
+ScVbaFont::setSubscript( const uno::Any& aValue ) throw ( uno::RuntimeException )
+{
+	sal_Bool bValue = sal_False;
+	aValue >>= bValue;
+	sal_Int16 nValue = NORMAL;
+	sal_Int8 nValue2 = NORMALHEIGHT;
+
+        if( bValue ) 
+	{
+		nValue= SUBSCRIPT;
+	        nValue2 = SUBSCRIPTHEIGHT;
+	}
+
+ 	mxFont->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharEscapementHeight" ) ), ( uno::Any )nValue2 );
+	mxFont->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharEscapement" ) ), ( uno::Any )nValue );
+
+}
+
+uno::Any
+ScVbaFont::getSubscript() throw ( uno::RuntimeException )
+{
+	short nValue = NORMAL;
+	mxFont->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharEscapement" ) ) ) >>= nValue;
+	return uno::makeAny( ( nValue == SUBSCRIPT ) );
+}
+
+void 
+ScVbaFont::setSize( const uno::Any& aValue ) throw( uno::RuntimeException )
+{
+	mxFont->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharHeight" ) ), aValue );
+} 
+	
+uno::Any
+ScVbaFont::getSize() throw ( uno::RuntimeException )
+{
+	if ( mpDataSet )
+		if (  mpDataSet->GetItemState( ATTR_FONT_HEIGHT, TRUE, NULL) == SFX_ITEM_DONTCARE )
+			return aNULL();
+        return mxFont->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharHeight" ) ) );
+}
+
+void
+ScVbaFont::setColorIndex( const uno::Any& aValue ) throw( uno::RuntimeException )
+{
+	sal_Int32 lValue=0;
+	aValue >>= lValue;
+	// #TODO #FIXME is behavior random or just default, maybe it depends
+	// on the parent object ( which we don't really take care of right now
+	if ( !lValue || lValue == excel::XlColorIndex::xlColorIndexAutomatic )
+		lValue = 1;
+	mxFont->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharColor" ) ), ( uno::Any )mPalette.getPalette()->getByIndex( --lValue ) );
+} 
+	
+
+uno::Any
+ScVbaFont::getColorIndex() throw ( uno::RuntimeException )
+{
+	if ( mpDataSet )
+		if (  mpDataSet->GetItemState( ATTR_FONT_COLOR, TRUE, NULL) == SFX_ITEM_DONTCARE )
+			return aNULL();
+
+//XXX
+        sal_Int32 nColor = -1;
+        uno::Any aValue= mxFont->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharColor" ) ) );
+	aValue >>= nColor;
+	uno::Reference< container::XIndexAccess > xIndex = mPalette.getPalette();
+	sal_Int32 nElems = xIndex->getCount();
+	sal_Int32 nIndex = -1;
+	for ( sal_Int32 count=0; count<nElems; ++count )
+       	{
+		sal_Int32 nPaletteColor;
+		xIndex->getByIndex( count ) >>= nPaletteColor;
+		if ( nPaletteColor == nColor )
+		{
+			nIndex = count + 1; // 1 based
+			break;
+		}
+	} 
+	return uno::makeAny( nIndex );
+}
+
+//////////////////////////////////////////////////////////////////////////////////////////
+void 
+ScVbaFont::setStandardFontSize( const uno::Any& /*aValue*/ ) throw( uno::RuntimeException )
+{
+//XXX #TODO# #FIXME#
+	//mxFont->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharSize" ) ), ( uno::Any )fValue );
+	throw uno::RuntimeException(
+		rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("setStandardFontSize not supported") ), uno::Reference< uno::XInterface >() );
+} 
+	
+
+uno::Any
+ScVbaFont::getStandardFontSize() throw ( uno::RuntimeException )
+{
+//XXX #TODO# #FIXME#
+	throw uno::RuntimeException(
+		rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("getStandardFontSize not supported") ), uno::Reference< uno::XInterface >() );
+	return uno::Any();
+}
+
+
+void 
+ScVbaFont::setStandardFont( const uno::Any& /*aValue*/ ) throw( uno::RuntimeException )
+{
+//XXX #TODO# #FIXME#
+	throw uno::RuntimeException(
+		rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("setStandardFont not supported") ), uno::Reference< uno::XInterface >() );
+} 
+	
+
+uno::Any
+ScVbaFont::getStandardFont() throw ( uno::RuntimeException )
+{
+//XXX #TODO# #FIXME#
+	throw uno::RuntimeException(
+		rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("getStandardFont not supported") ), uno::Reference< uno::XInterface >() );
+	return uno::Any();
+}
+
+void 
+ScVbaFont::setFontStyle( const uno::Any& /*aValue*/ ) throw( uno::RuntimeException )
+{
+//XXX #TODO# #FIXME#
+	//mxFont->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharSize" ) ), ( uno::Any )aValue );
+	throw uno::RuntimeException(
+		rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("setFontStyle not supported") ), uno::Reference< uno::XInterface >() );
+} 
+	
+
+uno::Any
+ScVbaFont::getFontStyle() throw ( uno::RuntimeException )
+{
+//XXX
+	throw uno::RuntimeException(
+		rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("getFontStyle not supported") ), uno::Reference< uno::XInterface >() );
+	return uno::Any();
+}
+
+void 
+ScVbaFont::setBold( const uno::Any& aValue ) throw( uno::RuntimeException )
+{
+	sal_Bool bValue = sal_False;
+	aValue >>= bValue;
+	double fBoldValue = awt::FontWeight::NORMAL;
+	if( bValue )
+		fBoldValue = awt::FontWeight::BOLD;
+	mxFont->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharWeight" ) ), ( uno::Any )fBoldValue );
+	
+} 
+	
+uno::Any
+ScVbaFont::getBold() throw ( uno::RuntimeException )
+{
+	if ( mpDataSet )
+		if (  mpDataSet->GetItemState( ATTR_FONT_WEIGHT, TRUE, NULL) == SFX_ITEM_DONTCARE )
+			return aNULL();
+
+	double fValue;
+	 mxFont->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharWeight" ) ) ) >>= fValue;
+	return uno::makeAny( fValue == awt::FontWeight::BOLD );
+}
+
+void 
+ScVbaFont::setUnderline( const uno::Any& aValue ) throw ( uno::RuntimeException )
+{
+	// default
+	sal_Int32 nValue = excel::XlUnderlineStyle::xlUnderlineStyleNone;
+	aValue >>= nValue;
+	switch ( nValue )
+	{
+// NOTE:: #TODO #FIMXE 
+// xlUnderlineStyleDoubleAccounting & xlUnderlineStyleSingleAccounting
+// don't seem to be supported in Openoffice. 
+// The import filter converts them to single or double underlines as appropriate
+// So, here at the moment we are similarly silently converting 
+// xlUnderlineStyleSingleAccounting to xlUnderlineStyleSingle.
+
+		case excel::XlUnderlineStyle::xlUnderlineStyleNone:
+			nValue = awt::FontUnderline::NONE;
+			break;
+		case excel::XlUnderlineStyle::xlUnderlineStyleSingle:
+		case excel::XlUnderlineStyle::xlUnderlineStyleSingleAccounting:
+			nValue = awt::FontUnderline::SINGLE;
+			break;
+		case excel::XlUnderlineStyle::xlUnderlineStyleDouble:
+		case excel::XlUnderlineStyle::xlUnderlineStyleDoubleAccounting:
+			nValue = awt::FontUnderline::DOUBLE;
+			break;
+		default:
+			throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Unknown value for Underline")), uno::Reference< uno::XInterface >() );
+	}
+
+	mxFont->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharUnderline" ) ), ( uno::Any )nValue );
+	
+}
+
+uno::Any
+ScVbaFont::getUnderline() throw ( uno::RuntimeException )
+{
+	if ( mpDataSet )
+		if (  mpDataSet->GetItemState( ATTR_FONT_UNDERLINE, TRUE, NULL) == SFX_ITEM_DONTCARE )
+			return aNULL();
+
+	sal_Int32 nValue = awt::FontUnderline::NONE;
+	mxFont->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharUnderline" ) ) ) >>= nValue;
+	switch ( nValue )
+	{
+		case  awt::FontUnderline::DOUBLE:
+			nValue = excel::XlUnderlineStyle::xlUnderlineStyleDouble;
+			break;
+		case  awt::FontUnderline::SINGLE:
+			nValue = excel::XlUnderlineStyle::xlUnderlineStyleSingle;
+			break;
+		case  awt::FontUnderline::NONE:
+			nValue = excel::XlUnderlineStyle::xlUnderlineStyleNone;
+			break;
+		default:
+			throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Unknown value retrieved for Underline") ), uno::Reference< uno::XInterface >() );
+		
+	}
+	return uno::makeAny( nValue );
+}
+		
+void
+ScVbaFont::setStrikethrough( const uno::Any& aValue ) throw ( uno::RuntimeException )
+{
+	sal_Bool bValue = sal_False;	
+	aValue >>= bValue;
+	short nValue = awt::FontStrikeout::NONE;
+	if( bValue )
+		nValue = awt::FontStrikeout::SINGLE;
+	mxFont->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharStrikeout" ) ), ( uno::Any )nValue );
+}
+
+uno::Any
+ScVbaFont::getStrikethrough() throw ( uno::RuntimeException )
+{
+	if ( mpDataSet )
+		if (  mpDataSet->GetItemState( ATTR_FONT_CROSSEDOUT, TRUE, NULL) == SFX_ITEM_DONTCARE )
+			return aNULL();
+	short nValue = 0;
+	mxFont->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharStrikeout" ) ) ) >>= nValue;
+	return uno::Any( nValue == awt::FontStrikeout::SINGLE );
+}
+
+void 
+ScVbaFont::setShadow( const uno::Any& aValue ) throw ( uno::RuntimeException )
+{
+	mxFont->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharShadowed" ) ), aValue );
+}
+
+uno::Any
+ScVbaFont::getShadow() throw (uno::RuntimeException)
+{
+	if ( mpDataSet )
+		if (  mpDataSet->GetItemState( ATTR_FONT_SHADOWED, TRUE, NULL) == SFX_ITEM_DONTCARE )
+			return aNULL();
+	return mxFont->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharShadowed" ) ) );
+}
+
+void 
+ScVbaFont::setItalic( const uno::Any& aValue ) throw ( uno::RuntimeException )
+{
+	sal_Bool bValue = sal_False;
+	aValue >>= bValue;
+	short nValue = awt::FontSlant_NONE;
+	if( bValue )
+		nValue = awt::FontSlant_ITALIC;
+    mxFont->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharPosture" ) ), ( uno::Any )nValue );
+}
+
+uno::Any
+ScVbaFont::getItalic() throw ( uno::RuntimeException )
+{
+	if ( mpDataSet )
+		if (  mpDataSet->GetItemState( ATTR_FONT_POSTURE, TRUE, NULL) == SFX_ITEM_DONTCARE )
+			return aNULL();
+
+	short nValue = 0;  
+	mxFont->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharPosture" ) ) ) >>= nValue;
+	return uno::makeAny( nValue == awt::FontSlant_ITALIC );
+}
+
+void 
+ScVbaFont::setName( const uno::Any& aValue ) throw ( uno::RuntimeException )
+{
+	rtl::OUString sString;
+	aValue >>= sString;
+	mxFont->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharFontName" ) ), aValue);	
+}
+
+uno::Any
+ScVbaFont::getName() throw ( uno::RuntimeException )
+{
+	if ( mpDataSet )
+		if (  mpDataSet->GetItemState( ATTR_FONT, TRUE, NULL) == SFX_ITEM_DONTCARE )
+			return aNULL();
+	return mxFont->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharFontName" ) ) );
+}
Index: sc/source/ui/vba/vbafont.hxx
===================================================================
RCS file: sc/source/ui/vba/vbafont.hxx
diff -N sc/source/ui/vba/vbafont.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbafont.hxx	21 Feb 2007 17:29:19 -0000	1.1.2.2
@@ -0,0 +1,91 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_FONT_HXX
+#define SC_VBA_FONT_HXX
+
+#include <cppuhelper/implbase1.hxx>
+
+#include <org/openoffice/excel/XFont.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include "vbahelper.hxx"
+#include "vbapalette.hxx"
+
+class ScTableSheetsObj;
+
+typedef  ::cppu::WeakImplHelper1< oo::excel::XFont > ScVbaFont_BASE;
+
+class ScVbaFont : public ScVbaFont_BASE 
+{
+    css::uno::Reference< css::beans::XPropertySet > mxFont;
+    ScVbaPalette mPalette;
+    SfxItemSet* mpDataSet;
+public:
+	ScVbaFont( const ScVbaPalette& dPalette, css::uno::Reference< css::beans::XPropertySet > xPropertySet, SfxItemSet* pDataSet = NULL ) throw ( css::uno::RuntimeException );
+	virtual ~ScVbaFont() {}
+
+	// Attributes
+    virtual css::uno::Any SAL_CALL getSize() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setSize( const css::uno::Any& _size ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getStandardFontSize() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setStandardFontSize( const css::uno::Any& _standardfontsize ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getStandardFont() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setStandardFont( const css::uno::Any& _standardfont ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getFontStyle() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setFontStyle( const css::uno::Any& _fontstyle ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getColorIndex() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setColorIndex( const css::uno::Any& _colorindex ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getBold() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setBold( const css::uno::Any& _bold ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getUnderline() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setUnderline( const css::uno::Any& _underline ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getStrikethrough() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setStrikethrough( const css::uno::Any& _strikethrough ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getShadow() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setShadow( const css::uno::Any& _shadow ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getItalic() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setItalic( const css::uno::Any& _italic ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getSubscript() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setSubscript( const css::uno::Any& _subscript ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getSuperscript() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setSuperscript( const css::uno::Any& _superscript ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getName() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setName( const css::uno::Any& _name ) throw (css::uno::RuntimeException);
+	
+};
+
+
+
+#endif /* SC_VBA_FONT_HXX */
+
Index: sc/source/ui/vba/vbaglobals.cxx
===================================================================
RCS file: sc/source/ui/vba/vbaglobals.cxx
diff -N sc/source/ui/vba/vbaglobals.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbaglobals.cxx	21 Feb 2007 17:29:19 -0000	1.1.2.2
@@ -0,0 +1,235 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_GLOBALS
+#include "vbaglobals.hxx"
+#endif
+
+#include <com/sun/star/lang/XMultiComponentFactory.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+
+#include "vbaapplication.hxx"
+#include "vbaworksheet.hxx"
+#include "vbarange.hxx"
+#include <cppuhelper/bootstrap.hxx>
+using namespace ::com::sun::star;
+using namespace ::com::sun::star::uno;
+using namespace ::org::openoffice;
+
+
+
+namespace vbaobj
+{
+    ::rtl::OUString SAL_CALL getImplementationName()
+    {
+        static ::rtl::OUString* pImplName = 0;
+		if ( !pImplName )
+		{
+            ::osl::MutexGuard aGuard( ::osl::Mutex::getGlobalMutex() );
+            if ( !pImplName )
+			{
+				static ::rtl::OUString aImplName( RTL_CONSTASCII_USTRINGPARAM( "org.openoffice.vba.Globals" ) );
+				pImplName = &aImplName;
+			}
+		}
+		return *pImplName;
+    }
+
+	uno::Reference< XComponentContext > getComponentContextFromMSF( uno::Reference< lang::XMultiServiceFactory > const& xFactory )  
+	{
+		uno::Reference< XComponentContext > xContext;
+
+	        uno::Reference< beans::XPropertySet > xProps( xFactory, UNO_QUERY );
+		if (xProps.is())
+		{
+			xProps->getPropertyValue(
+			rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("DefaultContext") ) ) >>= xContext;
+		}
+		return xContext;
+	}
+
+
+    uno::Reference< XInterface > SAL_CALL create(
+        Reference< XComponentContext > const & xContext )
+        SAL_THROW( () )
+    {
+	if ( !xContext.is() )
+	{
+		OSL_TRACE("Failed to obtain context" );	
+		return uno::Reference< uno::XInterface >(NULL);
+	}
+	OSL_TRACE("In create component for vbaglobals");
+        return static_cast< lang::XTypeProvider * >( new ScVbaGlobals( xContext ) );
+    }
+
+	Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames()
+	{
+    	const ::rtl::OUString strName( ::vbaobj::getImplementationName() );
+		return Sequence< ::rtl::OUString >( &strName, 1 );
+	}	
+}
+
+// =============================================================================
+// ScVbaGlobals
+// =============================================================================
+
+ScVbaGlobals::ScVbaGlobals( const Reference< XComponentContext >& rxContext )
+        :m_xContext( rxContext )
+{
+//	OSL_TRACE("ScVbaGlobals::ScVbaGlobals()");
+	mxApplication = uno::Reference< excel::XApplication > ( new ScVbaApplication( m_xContext) );
+}
+
+ScVbaGlobals::~ScVbaGlobals()
+{
+//	OSL_TRACE("ScVbaGlobals::~ScVbaGlobals");
+}
+
+// Will throw if singleton can't be accessed 
+uno::Reference< vba::XGlobals >
+ScVbaGlobals::getGlobalsImpl( uno::Reference< uno::XComponentContext >& xContext ) throw ( uno::RuntimeException )
+{
+	uno::Reference< vba::XGlobals > xGlobals( 
+		xContext->getValueByName( ::rtl::OUString::createFromAscii( 
+			"/singletons/org.openoffice.vba.theGlobals") ), uno::UNO_QUERY);
+
+	if ( !xGlobals.is() )
+	{
+		throw uno::RuntimeException(
+                ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ": Couldn't access Globals" ) ),
+                    uno::Reference< XInterface >() );
+	}
+	return xGlobals;
+}
+
+// -----------------------------------------------------------------------------
+// XServiceInfo
+// -----------------------------------------------------------------------------
+
+::rtl::OUString ScVbaGlobals::getImplementationName(  ) throw (RuntimeException)
+{
+	return ::vbaobj::getImplementationName();
+}
+
+sal_Bool ScVbaGlobals::supportsService( const ::rtl::OUString& rServiceName ) throw (RuntimeException)
+{
+	Sequence< ::rtl::OUString > aNames( ::vbaobj::getSupportedServiceNames() );
+	const ::rtl::OUString* pNames = aNames.getConstArray();
+	const ::rtl::OUString* pEnd = pNames + aNames.getLength();
+	for ( ; pNames != pEnd && !pNames->equals( rServiceName ); ++pNames )
+		;
+
+	return pNames != pEnd;
+}
+
+Sequence< ::rtl::OUString > ScVbaGlobals::getSupportedServiceNames(  ) throw (RuntimeException)
+{
+	return vbaobj::getSupportedServiceNames();
+}
+	
+// =============================================================================
+// XGlobals
+// =============================================================================
+uno::Reference<excel::XApplication >
+ScVbaGlobals::getApplication() throw (uno::RuntimeException)
+{
+//	OSL_TRACE("In ScVbaGlobals::getApplication");	
+    return mxApplication;
+}
+
+uno::Reference< excel::XWorkbook > SAL_CALL 
+ScVbaGlobals::getActiveWorkbook() throw (uno::RuntimeException)
+{
+//	OSL_TRACE("In ScVbaGlobals::getActiveWorkbook");	
+    uno::Reference< excel::XWorkbook > xWorkbook( mxApplication->getActiveWorkbook(), uno::UNO_QUERY);
+    if ( xWorkbook.is() )
+    {
+        return xWorkbook;    
+    }
+// FIXME check if this is correct/desired behavior
+    throw uno::RuntimeException( rtl::OUString::createFromAscii(
+        "No activeWorkbook available" ), Reference< uno::XInterface >() );
+}
+
+
+uno::Reference< excel::XWorksheet > SAL_CALL 
+ScVbaGlobals::getActiveSheet() throw (uno::RuntimeException)
+{
+    return mxApplication->getActiveSheet();
+}
+
+uno::Any SAL_CALL 
+ScVbaGlobals::WorkBooks( const uno::Any& aIndex ) throw (uno::RuntimeException)
+{
+	return uno::Any( mxApplication->Workbooks(aIndex) );
+}
+
+uno::Any SAL_CALL
+ScVbaGlobals::WorkSheets(const uno::Any& aIndex) throw (uno::RuntimeException)
+{
+	return mxApplication->Worksheets( aIndex );
+}
+uno::Any SAL_CALL
+ScVbaGlobals::Sheets( const uno::Any& aIndex ) throw (uno::RuntimeException)
+{
+	return WorkSheets( aIndex );
+}
+
+::uno::Sequence< ::uno::Any > SAL_CALL
+ScVbaGlobals::getGlobals(  ) throw (::uno::RuntimeException)
+{
+	sal_uInt32 nMax = 0;
+	uno::Sequence< uno::Any > maGlobals(4);
+	maGlobals[ nMax++ ] <<= ScVbaGlobals::getGlobalsImpl(m_xContext);
+	maGlobals[ nMax++ ] <<= mxApplication;
+
+	uno::Reference< excel::XWorkbook > xWorkbook = mxApplication->getActiveWorkbook();
+	if( xWorkbook.is() )
+	{
+		maGlobals[ nMax++ ] <<= xWorkbook;
+		uno::Reference< excel::XWorksheet > xWorksheet = xWorkbook->getActiveSheet();
+		if( xWorksheet.is() )
+			maGlobals[ nMax++ ] <<= xWorksheet;
+	}
+	maGlobals.realloc( nMax );
+	return maGlobals;
+}
+
+uno::Any SAL_CALL 
+ScVbaGlobals::Range( const uno::Any& Cell1, const uno::Any& Cell2 ) throw (uno::RuntimeException)
+{
+	return getApplication()->Range( Cell1, Cell2 );
+}
+
+
Index: sc/source/ui/vba/vbaglobals.hxx
===================================================================
RCS file: sc/source/ui/vba/vbaglobals.hxx
diff -N sc/source/ui/vba/vbaglobals.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbaglobals.hxx	21 Feb 2007 17:29:19 -0000	1.1.2.2
@@ -0,0 +1,88 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_GLOBALS
+#define SC_VBA_GLOBALS
+
+#include <com/sun/star/lang/XServiceInfo.hpp>
+#include <com/sun/star/lang/XInitialization.hpp>
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <org/openoffice/vba/XGlobals.hpp>
+
+#include <cppuhelper/implbase2.hxx>
+#include "vbahelper.hxx"
+
+    // =============================================================================
+    // class ScVbaGlobals
+    // =============================================================================
+
+    typedef ::cppu::WeakImplHelper2<    
+        oo::vba::XGlobals,
+        css::lang::XServiceInfo > ScVbaGlobals_BASE;
+
+
+    class ScVbaGlobals : public ScVbaGlobals_BASE
+    {
+    private:
+            css::uno::Reference< css::uno::XComponentContext > m_xContext;
+            css::uno::Reference< oo::excel::XApplication > mxApplication;
+    public:
+	
+        ScVbaGlobals(
+            const css::uno::Reference< css::uno::XComponentContext >& rxContext );
+        virtual ~ScVbaGlobals();
+
+		static 	css::uno::Reference< oo::vba::XGlobals > getGlobalsImpl(css::uno::Reference< css::uno::XComponentContext >& ) throw (css::uno::RuntimeException);
+
+        // XServiceInfo
+        virtual ::rtl::OUString SAL_CALL getImplementationName(  ) 
+            throw (css::uno::RuntimeException);
+        virtual sal_Bool SAL_CALL supportsService( const ::rtl::OUString& ServiceName ) 
+            throw (css::uno::RuntimeException);
+        virtual css::uno::Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames(  ) 
+            throw (css::uno::RuntimeException);
+
+        // XGlobals
+        virtual css::uno::Reference<
+                        oo::excel::XApplication > SAL_CALL getApplication()
+                        throw (css::uno::RuntimeException);
+        virtual css::uno::Reference< oo::excel::XWorkbook > SAL_CALL getActiveWorkbook() throw (css::uno::RuntimeException);
+        virtual css::uno::Reference< oo::excel::XWorksheet > SAL_CALL getActiveSheet() throw (css::uno::RuntimeException);
+        virtual css::uno::Any SAL_CALL WorkSheets(const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+        virtual css::uno::Any SAL_CALL WorkBooks(const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL Sheets( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+	virtual css::uno::Sequence< css::uno::Any > SAL_CALL getGlobals(  ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL Range( const css::uno::Any& Cell1, const css::uno::Any& Cell2 ) throw (css::uno::RuntimeException);
+    };
+#endif // 
Index: sc/source/ui/vba/vbahelper.cxx
===================================================================
RCS file: sc/source/ui/vba/vbahelper.cxx
diff -N sc/source/ui/vba/vbahelper.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbahelper.cxx	21 Feb 2007 17:29:20 -0000	1.1.2.3
@@ -0,0 +1,527 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include <cppuhelper/bootstrap.hxx>
+#include <com/sun/star/util/XURLTransformer.hpp>
+#include <com/sun/star/frame/XDispatchProvider.hpp>
+#include <com/sun/star/frame/XModel.hpp>
+#include <com/sun/star/frame/XFrame.hpp>
+#include <com/sun/star/frame/XDesktop.hpp>
+#include <com/sun/star/frame/XController.hpp>
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <com/sun/star/lang/XMultiComponentFactory.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+
+#include <sfx2/objsh.hxx>
+#include <sfx2/viewfrm.hxx>
+#include <sfx2/dispatch.hxx>
+#include <sfx2/app.hxx>
+
+#include <docuno.hxx>
+
+#include <basic/sbx.hxx>
+#include <basic/sbstar.hxx>
+
+#include "vbahelper.hxx"
+#include "tabvwsh.hxx"
+#include "transobj.hxx"
+#include "scmod.hxx"
+
+using namespace ::com::sun::star;
+using namespace ::org::openoffice;
+
+void unoToSbxValue( SbxVariable* pVar, const uno::Any& aValue );
+
+uno::Any sbxToUnoValue( SbxVariable* pVar );
+
+
+namespace org
+{
+namespace openoffice
+{
+
+// helper method to determine if the view ( calc ) is in print-preview mode
+bool isInPrintPreview( SfxViewFrame* pView )
+{
+	sal_uInt16 nViewNo = SID_VIEWSHELL1 - SID_VIEWSHELL0;
+	if ( pView->GetObjectShell()->GetFactory().GetViewFactoryCount() >
+nViewNo && !pView->GetObjectShell()->IsInPlaceActive() )
+	{
+		SfxViewFactory &rViewFactory =
+			pView->GetObjectShell()->GetFactory().GetViewFactory(nViewNo);
+		if (  pView->GetCurViewId() == rViewFactory.GetOrdinal() )
+			return true;	
+	}
+	return false;
+}
+const ::rtl::OUString REPLACE_CELLS_WARNING(  RTL_CONSTASCII_USTRINGPARAM( "ReplaceCellsWarning"));
+const uno::Any&
+aNULL()
+{
+ 	static  uno::Any aNULLL = uno::makeAny( uno::Reference< uno::XInterface >() );
+	return aNULLL;
+}
+
+class PasteCellsWarningReseter
+{
+private:
+	bool bInitialWarningState;
+	static uno::Reference< beans::XPropertySet > getGlobalSheetSettings() throw ( uno::RuntimeException )
+	{
+		static uno::Reference<uno::XComponentContext > xContext( ::cppu::defaultBootstrap_InitialComponentContext(), uno::UNO_QUERY_THROW );
+		static uno::Reference<lang::XMultiComponentFactory > xServiceManager(
+				xContext->getServiceManager(), uno::UNO_QUERY_THROW );
+		static uno::Reference< beans::XPropertySet > xProps( xServiceManager->createInstanceWithContext( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.sheet.GlobalSheetSettings" ) ) ,xContext ), uno::UNO_QUERY_THROW );
+		return xProps;
+	}	
+
+	bool getReplaceCellsWarning() throw ( uno::RuntimeException )
+	{
+		sal_Bool res = sal_False;
+		getGlobalSheetSettings()->getPropertyValue( REPLACE_CELLS_WARNING ) >>= res;
+		return ( res == sal_True );
+	}
+
+	void setReplaceCellsWarning( bool bState ) throw ( uno::RuntimeException )
+	{
+		getGlobalSheetSettings()->setPropertyValue( REPLACE_CELLS_WARNING, uno::makeAny( bState ) );
+	}
+public:
+	PasteCellsWarningReseter() throw ( uno::RuntimeException )
+	{
+		bInitialWarningState = getReplaceCellsWarning();
+		if ( bInitialWarningState )
+			setReplaceCellsWarning( false );
+	}
+	~PasteCellsWarningReseter()
+	{
+		if ( bInitialWarningState )
+		{
+			// don't allow dtor to throw
+			try
+			{
+				setReplaceCellsWarning( true ); 
+			}
+			catch ( uno::Exception& /*e*/ ){}
+		}
+	}
+};
+
+void
+dispatchRequests (uno::Reference< frame::XModel>& xModel,rtl::OUString & aUrl, uno::Sequence< beans::PropertyValue >& sProps ) 
+{
+
+	util::URL  url ;
+	url.Complete = aUrl;
+	rtl::OUString emptyString = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "" ));
+	uno::Reference<frame::XController> xController = xModel->getCurrentController();
+	uno::Reference<frame::XFrame> xFrame = xController->getFrame();
+	uno::Reference<frame::XDispatchProvider> xDispatchProvider (xFrame,uno::UNO_QUERY_THROW);
+	try
+	{
+		uno::Reference<uno::XComponentContext > xContext(  ::cppu::defaultBootstrap_InitialComponentContext());
+		if ( !xContext.is() )
+		{
+			return ;
+		}
+
+		uno::Reference<lang::XMultiComponentFactory > xServiceManager(
+				xContext->getServiceManager() );
+		if ( !xServiceManager.is() )
+		{
+			return ;
+		}
+		uno::Reference<util::XURLTransformer> xParser( xServiceManager->createInstanceWithContext(     rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.util.URLTransformer" ) )
+			,xContext), uno::UNO_QUERY_THROW );
+		if (!xParser.is())
+			return;
+		xParser->parseStrict (url);
+	}
+	catch ( ::cppu::BootstrapException & /*e*/ )
+	{
+		return ;
+	}
+	catch ( uno::Exception & /*e*/ )
+	{
+		return ;
+	}
+
+	uno::Reference<frame::XDispatch> xDispatcher = xDispatchProvider->queryDispatch(url,emptyString,0);
+
+	uno::Sequence<beans::PropertyValue> dispatchProps(1);
+
+	sal_Int32 nProps = sProps.getLength();
+	beans::PropertyValue* pDest = dispatchProps.getArray();
+	if ( nProps )
+	{
+		dispatchProps.realloc( nProps + 1 );
+		// need to reaccquire pDest after realloc
+		pDest = dispatchProps.getArray();
+		beans::PropertyValue* pSrc = sProps.getArray();
+		for ( sal_Int32 index=0; index<nProps; ++index, ++pSrc, ++pDest )
+			*pDest = *pSrc;
+	}
+
+	(*pDest).Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Silent" ));
+	(*pDest).Value <<= (sal_Bool)sal_True;
+
+	if (xDispatcher.is())
+		xDispatcher->dispatch( url, dispatchProps );
+}
+
+void
+dispatchRequests (uno::Reference< frame::XModel>& xModel,rtl::OUString & aUrl) 
+{
+	uno::Sequence<beans::PropertyValue> dispatchProps;
+	dispatchRequests( xModel, aUrl, dispatchProps );
+}
+
+
+void
+implnPaste()
+{
+	PasteCellsWarningReseter resetWarningBox;
+	ScTabViewShell* pViewShell = ScTabViewShell::GetActiveViewShell();
+	if ( pViewShell )
+	{
+		pViewShell->PasteFromSystem();
+		pViewShell->CellContentChanged();
+	}
+}
+
+
+void
+implnCopy()
+{
+	ScTabViewShell* pViewShell = getCurrentBestViewShell();
+	if ( pViewShell )
+		pViewShell->CopyToClip(NULL,false,false,true);
+}
+
+void 
+implnCut()
+{
+	ScTabViewShell* pViewShell =  getCurrentBestViewShell();
+	if ( pViewShell )
+		pViewShell->CutToClip( NULL, TRUE );
+}
+
+void implnPasteSpecial(USHORT nFlags,USHORT nFunction,sal_Bool bSkipEmpty, sal_Bool bTranspose)
+{
+	PasteCellsWarningReseter resetWarningBox;
+	sal_Bool bAsLink(sal_False), bOtherDoc(sal_False);
+	InsCellCmd eMoveMode = INS_NONE;
+
+	ScTabViewShell* pTabViewShell = ScTabViewShell::GetActiveViewShell();
+	if ( !pTabViewShell ) 
+		// none active, try next best
+		pTabViewShell = getCurrentBestViewShell();
+	if ( pTabViewShell )
+	{
+		ScViewData* pView = pTabViewShell->GetViewData();	
+		Window* pWin = ( pView != NULL ) ? pView->GetActiveWin() : NULL;
+		if ( pView && pWin )
+		{
+			if ( bAsLink && bOtherDoc )
+				pTabViewShell->PasteFromSystem(0);//SOT_FORMATSTR_ID_LINK
+			else 
+			{
+				ScTransferObj* pOwnClip = ScTransferObj::GetOwnClipboard( pWin );
+				ScDocument* pDoc = NULL; 
+				if ( pOwnClip )
+					pDoc = pOwnClip->GetDocument();	
+				pTabViewShell->PasteFromClip( nFlags, pDoc,
+					nFunction, bSkipEmpty, bTranspose, bAsLink,
+					eMoveMode, IDF_NONE, TRUE );
+				pTabViewShell->CellContentChanged();
+			}
+		}
+	}
+
+}
+
+bool
+isRangeShortCut( const ::rtl::OUString& sParam )
+{
+        // for a ShortCutRange param, I'd expect the first letter to be
+        //[A-Z] and the last letter to be a digit 0-9 e.g A10, [A1:A10] etc.
+        ::rtl::OString sStr = rtl::OUStringToOString( sParam,
+                RTL_TEXTENCODING_UTF8 );
+        const sal_Char* pFirst = (const sal_Char*)sStr;
+        const sal_Char* pLast = pFirst + ( sStr.getLength() - 1 );
+        if ( (( *pFirst >= 'A' && *pFirst <= 'Z' ) || ( *pFirst >= 'a' && *pFirst <= 'Z' ) )  )
+                if ( ( *pLast >= '0' ) && ( *pLast <= '9' ) )
+                        return true;
+
+        return false;
+}
+
+ uno::Reference< frame::XModel > 
+getCurrentDocument() throw (uno::RuntimeException)
+{
+	uno::Reference< frame::XModel > xModel;
+	SbxObject* pBasic = dynamic_cast< SbxObject* > ( SFX_APP()->GetBasic() );
+	SbxObject* basicChosen =  pBasic ;
+	if ( basicChosen == NULL)
+	{
+		OSL_TRACE("getModelFromBasic() StarBASIC* is NULL" );
+		return xModel;
+	}    
+    SbxObject* p = pBasic;
+    SbxObject* pParent = p->GetParent();
+    SbxObject* pParentParent = pParent ? pParent->GetParent() : NULL;
+
+    if( pParentParent )
+    {
+        basicChosen = pParentParent;
+    }
+    else if( pParent )
+    {
+        basicChosen = pParent;
+    }
+
+
+    uno::Any aModel; 
+    SbxVariable *pCompVar = basicChosen->Find(  UniString(RTL_CONSTASCII_USTRINGPARAM("ThisComponent")), SbxCLASS_OBJECT );
+
+	if ( pCompVar )
+	{
+		aModel = sbxToUnoValue( pCompVar );
+		if ( sal_False == ( aModel >>= xModel ) ||
+			!xModel.is() )
+		{
+			// trying last gasp try the current component
+			uno::Reference<uno::XComponentContext > xCtx( ::cppu::defaultBootstrap_InitialComponentContext(), uno::UNO_QUERY_THROW );
+			uno::Reference<lang::XMultiComponentFactory > xSMgr( xCtx->getServiceManager(), uno::UNO_QUERY_THROW );
+			uno::Reference< frame::XDesktop > xDesktop (xSMgr->createInstanceWithContext(::rtl::OUString::createFromAscii("com.sun.star.frame.Desktop"), xCtx), uno::UNO_QUERY_THROW );
+			xModel.set( xDesktop->getCurrentComponent(), uno::UNO_QUERY );
+			if ( !xModel.is() )
+			{
+				throw uno::RuntimeException( 
+					rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Can't extract model from basic ( its obviously not set yet ) therefore don't know the currently selected document") ), uno::Reference< uno::XInterface >() );
+			}
+			return xModel;
+		}
+		else
+		{
+			OSL_TRACE("Have model ThisComponent points to url %s",
+			::rtl::OUStringToOString( xModel->getURL(),
+				RTL_TEXTENCODING_ASCII_US ).pData->buffer );
+		}
+	}
+	else
+	{
+		OSL_TRACE("Failed to get ThisComponent");
+		throw uno::RuntimeException( 
+			rtl::OUString( 
+				RTL_CONSTASCII_USTRINGPARAM(
+					"Can't determine the currently selected document") ),
+			uno::Reference< uno::XInterface >() );
+	}
+	return xModel;
+}
+
+ScDocShell* 
+getDocShell( css::uno::Reference< css::frame::XModel>& xModel ) 
+{
+	uno::Reference< uno::XInterface > xIf( xModel, uno::UNO_QUERY_THROW );
+	ScModelObj* pModel = dynamic_cast< ScModelObj* >( xIf.get() );
+	ScDocShell* pDocShell = NULL;
+	if ( pModel )
+		pDocShell = (ScDocShell*)pModel->GetEmbeddedObject();
+	return pDocShell;
+
+}
+
+ScTabViewShell* 
+getBestViewShell(  css::uno::Reference< css::frame::XModel>& xModel )
+{
+	ScDocShell* pDocShell = getDocShell( xModel );
+	if ( pDocShell )
+		return pDocShell->GetBestViewShell();
+	return NULL;
+}
+
+ScTabViewShell* 
+getCurrentBestViewShell()
+{ 
+	uno::Reference< frame::XModel > xModel = getCurrentDocument();
+	return getBestViewShell( xModel );
+}
+
+SfxViewFrame* 
+getCurrentViewFrame()
+{
+	ScTabViewShell* pViewShell = getCurrentBestViewShell();	
+	if ( pViewShell )
+		return pViewShell->GetViewFrame();
+	return NULL;
+}
+
+sal_Int32 
+OORGBToXLRGB( sal_Int32 nCol )
+{
+	sal_Int32 nRed = nCol;
+	nRed &= 0x00FF0000;
+	nRed >>= 16;
+	sal_Int32 nGreen = nCol;
+	nGreen &= 0x0000FF00;
+	nGreen >>= 8;
+	sal_Int32 nBlue = nCol;
+	nBlue &= 0x000000FF;
+	sal_Int32 nRGB =  ( (nBlue << 16) | (nGreen << 8) | nRed );
+	return nRGB;
+}
+sal_Int32 
+XLRGBToOORGB( sal_Int32 nCol )
+{
+	sal_Int32 nBlue = nCol;
+	nBlue &= 0x00FF0000;
+	nBlue >>= 16;
+	sal_Int32 nGreen = nCol;
+	nGreen &= 0x0000FF00;
+	nGreen >>= 8;
+	sal_Int32 nRed = nCol;
+	nRed &= 0x000000FF;
+	sal_Int32 nRGB =  ( (nRed << 16) | (nGreen << 8) | nBlue );
+	return nRGB;
+}
+uno::Any 
+OORGBToXLRGB( const uno::Any& aCol )
+{
+	sal_Int32 nCol;
+	aCol >>= nCol;
+	nCol = OORGBToXLRGB( nCol );
+	return uno::makeAny( nCol );
+}
+uno::Any 
+XLRGBToOORGB(  const uno::Any& aCol )
+{
+	sal_Int32 nCol;
+	aCol >>= nCol;
+	nCol = XLRGBToOORGB( nCol );
+	return uno::makeAny( nCol );
+}
+
+void PrintOutHelper( const uno::Any& From, const uno::Any& To, const uno::Any& Copies, const uno::Any& Preview, const uno::Any& /*ActivePrinter*/, const uno::Any& /*PrintToFile*/, const uno::Any& Collate, const uno::Any& PrToFileName, css::uno::Reference< frame::XModel >& xModel, sal_Bool bUseSelection  )
+{
+	sal_Int32 nTo = 0;
+	sal_Int32 nFrom = 0;
+	sal_Int16 nCopies = 1;
+	sal_Bool bPreview = sal_False;
+	sal_Bool bCollate = sal_False;
+	sal_Bool bSelection = bUseSelection;
+	From >>= nFrom;
+	To >>= nTo;
+	Copies >>= nCopies;
+	Preview >>= bPreview;
+	if ( nCopies > 1 ) // Collate only useful when more that 1 copy
+		Collate >>= bCollate;
+
+	rtl::OUString sRange(  RTL_CONSTASCII_USTRINGPARAM( "-" ) );
+	rtl::OUString sFileName;
+	
+	if (( nFrom || nTo ) )
+	{
+		if ( nFrom )
+			sRange = ( ::rtl::OUString::valueOf( nFrom ) + sRange );
+		if ( nTo )
+			sRange += ::rtl::OUString::valueOf( nTo );
+	}
+
+	if (  PrToFileName.getValue() )
+	{
+		PrToFileName >>= sFileName;
+	}
+	ScTabViewShell* pViewShell = getBestViewShell( xModel );
+	SfxViewFrame* pViewFrame = NULL;
+	if ( pViewShell )
+		pViewFrame = pViewShell->GetViewFrame();
+	if ( pViewFrame )
+	{
+		SfxAllItemSet aArgs( SFX_APP()->GetPool() );
+				
+		SfxBoolItem sfxCollate( SID_PRINT_COLLATE, bCollate );
+		aArgs.Put( sfxCollate, sfxCollate.Which() );
+		SfxInt16Item sfxCopies( SID_PRINT_COPIES, nCopies );
+		aArgs.Put( sfxCopies, sfxCopies.Which() );
+		if ( sFileName.getLength() )
+		{
+			SfxStringItem sfxFileName( SID_FILE_NAME, sFileName);
+			aArgs.Put( sfxFileName, sfxFileName.Which() );
+		
+		}
+		if (  sRange.getLength() )
+		{
+			SfxStringItem sfxRange( SID_PRINT_PAGES, sRange );
+			aArgs.Put( sfxRange, sfxRange.Which() );
+		}
+		SfxBoolItem sfxSelection( SID_SELECTION, bSelection );
+		aArgs.Put( sfxSelection, sfxSelection.Which() );
+		SfxBoolItem sfxAsync( SID_ASYNCHRON, sal_False );
+		aArgs.Put( sfxAsync, sfxAsync.Which() );
+		SfxDispatcher* pDispatcher = pViewFrame->GetDispatcher();
+
+		if ( pDispatcher )
+		{
+			if ( bPreview )
+			{
+				if ( !pViewFrame->GetFrame()->IsInPlace() ) 	
+				{
+					SC_MOD()->InputEnterHandler();
+					pViewFrame->GetDispatcher()->Execute( SID_VIEWSHELL1, SFX_CALLMODE_SYNCHRON );
+					while ( isInPrintPreview( pViewFrame ) )
+						Application::Yield();
+				}
+			}
+			else
+				pDispatcher->Execute( (USHORT)SID_PRINTDOC, (SfxCallMode)SFX_CALLMODE_SYNCHRON, aArgs );
+		}
+			
+	}
+	
+	// #FIXME #TODO
+	// 1 Preview ( does such a thing exist in OO.org? )
+	// 2 ActivePrinter ( how/can we switch a printer via API? )
+	// 3 PrintToFile ( ms behaviour if this option is specified but no 
+	//   filename supplied 'PrToFileName' then the user will be prompted )
+	// 4 Need to check behaviour of Selected sheets with range ( e.g. From & To
+	//    values ) in oOO these options are mutually exclusive
+	// 5 There is a pop up to do with transparent objects in the print source
+	//   should be able to disable that via configuration for the duration
+	//   of this method
+}
+
+}
+}
Index: sc/source/ui/vba/vbahelper.hxx
===================================================================
RCS file: sc/source/ui/vba/vbahelper.hxx
diff -N sc/source/ui/vba/vbahelper.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbahelper.hxx	21 Feb 2007 17:29:20 -0000	1.1.2.2
@@ -0,0 +1,80 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_HELPER_HXX
+#define SC_VBA_HELPER_HXX
+
+#include <com/sun/star/frame/XModel.hpp>
+#include <docsh.hxx>
+
+#define css com::sun::star
+#define oo org::openoffice
+namespace org 
+{
+	namespace openoffice 
+	{
+		void dispatchRequests (css::uno::Reference< css::frame::XModel>& xModel,rtl::OUString & aUrl) ;
+		void dispatchRequests (css::uno::Reference< css::frame::XModel>& xModel,rtl::OUString & aUrl, css::uno::Sequence< css::beans::PropertyValue >& sProps ) ;
+		void implnCopy();
+		void implnPaste();
+		void implnCut();
+		void implnPasteSpecial(sal_uInt16 nFlags,sal_uInt16 nFunction,sal_Bool bSkipEmpty, sal_Bool bTranspose);
+		bool isRangeShortCut( const ::rtl::OUString& sParam );
+		css::uno::Reference< css::frame::XModel >
+			getCurrentDocument() throw (css::uno::RuntimeException);
+		ScTabViewShell* getBestViewShell( css::uno::Reference< css::frame::XModel>& xModel ) ;
+		ScDocShell* getDocShell( css::uno::Reference< css::frame::XModel>& xModel ) ;
+		ScTabViewShell* getCurrentBestViewShell();
+		SfxViewFrame* getCurrentViewFrame();
+		sal_Int32 OORGBToXLRGB( sal_Int32 );
+		sal_Int32 XLRGBToOORGB( sal_Int32 );
+		css::uno::Any OORGBToXLRGB( const css::uno::Any& );
+		css::uno::Any XLRGBToOORGB( const css::uno::Any& );
+		// provide a NULL object that can be passed as variant so that 
+		// the object when passed to IsNull will return true. aNULL 
+		// contains an empty object reference
+		const css::uno::Any& aNULL();
+		void PrintOutHelper( const css::uno::Any& From, const css::uno::Any& To, const css::uno::Any& Copies, const css::uno::Any& Preview, const css::uno::Any& ActivePrinter, const css::uno::Any& PrintToFile, const css::uno::Any& Collate, const css::uno::Any& PrToFileName, css::uno::Reference< css::frame::XModel >& xModel, sal_Bool bSelection  );
+	}
+}
+
+#ifdef DEBUG
+#  define SC_VBA_FIXME(a) OSL_TRACE( a )
+#  define SC_VBA_STUB() SC_VBA_FIXME(( "%s - stubbed\n", __FUNCTION__ ))
+#else
+#  define SC_VBA_FIXME(a)
+#  define SC_VBA_STUB()
+#endif
+
+#endif
Index: sc/source/ui/vba/vbainterior.cxx
===================================================================
RCS file: sc/source/ui/vba/vbainterior.cxx
diff -N sc/source/ui/vba/vbainterior.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbainterior.cxx	21 Feb 2007 17:29:20 -0000	1.1.2.2
@@ -0,0 +1,129 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/table/XCell.hpp>
+#include <com/sun/star/table/XColumnRowRange.hpp>
+#include <com/sun/star/beans/XIntrospection.hpp>
+#include <com/sun/star/beans/XIntrospectionAccess.hpp>
+#include <com/sun/star/reflection/XIdlMethod.hpp>
+#include <com/sun/star/beans/MethodConcept.hpp>
+
+#include <org/openoffice/excel/XlColorIndex.hpp>
+
+#include <comphelper/processfactory.hxx>
+#include <cppuhelper/queryinterface.hxx>
+
+#include <svx/xtable.hxx>
+
+#include "vbainterior.hxx"
+#include "vbapalette.hxx"
+using namespace ::com::sun::star;
+using namespace ::org::openoffice;
+static const rtl::OUString BACKCOLOR( RTL_CONSTASCII_USTRINGPARAM( "CellBackColor" ) );
+
+ScVbaInterior::ScVbaInterior( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< beans::XPropertySet >&  xProps, ScDocument* pScDoc ) throw ( lang::IllegalArgumentException) : m_xProps(xProps), m_xContext(xContext), m_pScDoc( pScDoc )
+{
+	if ( !xContext.is() )
+		throw lang::IllegalArgumentException( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "context not set" ) ), uno::Reference< uno::XInterface >(), 1 ); 
+	if ( !m_xProps.is() )
+		throw lang::IllegalArgumentException( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "properties") ), uno::Reference< uno::XInterface >(), 2 ); 
+}
+
+uno::Any
+ScVbaInterior::getColor() throw (uno::RuntimeException) 
+{
+	uno::Any aAny;
+	aAny = OORGBToXLRGB( m_xProps->getPropertyValue( BACKCOLOR ) );
+	return aAny;
+}
+ 
+void 
+ScVbaInterior::setColor( const uno::Any& _color  ) throw (uno::RuntimeException)
+{
+	m_xProps->setPropertyValue( BACKCOLOR , XLRGBToOORGB(_color));
+}
+
+uno::Reference< container::XIndexAccess >
+ScVbaInterior::getPalette()
+{
+	SfxObjectShell* pShell = m_pScDoc->GetDocumentShell();
+	ScVbaPalette aPalette( pShell );	
+	return aPalette.getPalette();	
+}
+
+void SAL_CALL 
+ScVbaInterior::setColorIndex( const css::uno::Any& _colorindex ) throw (css::uno::RuntimeException) 
+{
+	sal_Int32 nIndex = 0;
+	_colorindex >>= nIndex;
+	// #FIXME  xlColorIndexAutomatic & xlColorIndexNone are not really
+	// handled properly here
+	
+	if ( !nIndex || ( nIndex == excel::XlColorIndex::xlColorIndexAutomatic ) || ( nIndex == excel::XlColorIndex::xlColorIndexNone )  )
+		nIndex = 2; // default is white ( this maybe will probably break, e.g. we may at some stage need to know what this interior is,  a cell or something else and then pick a default colour based on that )
+	--nIndex; // OOo indices are zero bases
+	uno::Reference< container::XIndexAccess > xIndex = getPalette();
+	// setColor expects colors in XL RGB values
+	// #FIXME this is daft we convert OO RGB val to XL RGB val and
+	// then back again to OO RGB value
+	setColor( OORGBToXLRGB(xIndex->getByIndex( nIndex )) );
+}
+
+uno::Any SAL_CALL 
+ScVbaInterior::getColorIndex() throw ( css::uno::RuntimeException )
+{
+	sal_Int32 nColor = 0;
+	// getColor returns Xl ColorValue, need to convert it to OO val
+	// as the palette deals with OO RGB values 
+	// #FIXME this is daft in getColor we convert OO RGB val to XL RGB val 
+	// and then back again to OO RGB value
+	XLRGBToOORGB( getColor() ) >>= nColor; 
+	uno::Reference< container::XIndexAccess > xIndex = getPalette();
+	sal_Int32 nElems = xIndex->getCount();
+	sal_Int32 nIndex = -1;
+	for ( sal_Int32 count=0; count<nElems; ++count )
+       	{
+		sal_Int32 nPaletteColor;
+		xIndex->getByIndex( count ) >>= nPaletteColor;
+		if ( nPaletteColor == nColor )
+		{
+			nIndex = count + 1; // 1 based
+			break;
+		}
+	}     
+	return uno::makeAny( nIndex );
+}
+
+
Index: sc/source/ui/vba/vbainterior.hxx
===================================================================
RCS file: sc/source/ui/vba/vbainterior.hxx
diff -N sc/source/ui/vba/vbainterior.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbainterior.hxx	21 Feb 2007 17:29:20 -0000	1.1.2.2
@@ -0,0 +1,71 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_INTERIOR_HXX
+#define SC_VBA_INTERIOR_HXX
+
+#include <cppuhelper/implbase1.hxx>
+#include <org/openoffice/excel/XInterior.hpp>
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/container/XIndexAccess.hpp>
+#include "vbarange.hxx"
+
+#include <com/sun/star/script/XInvocation.hpp>
+
+class ScDocument;
+
+typedef ::cppu::WeakImplHelper1< oo::excel::XInterior > ScVbaInterior_BASE;
+
+class ScVbaInterior :  public ScVbaInterior_BASE
+{
+	css::uno::Reference< css::beans::XPropertySet > m_xProps;
+        css::uno::Reference< css::uno::XComponentContext > m_xContext;
+	ScDocument* m_pScDoc;
+
+        css::uno::Reference< css::container::XIndexAccess > getPalette(); 
+public:
+        ScVbaInterior( const css::uno::Reference< css::uno::XComponentContext >& xContext,
+                 const css::uno::Reference< css::beans::XPropertySet >& xProps, ScDocument* pScDoc ) throw ( css::lang::IllegalArgumentException);
+
+        virtual ~ScVbaInterior(){}
+
+	virtual css::uno::Any SAL_CALL getColor() throw (css::uno::RuntimeException) ;
+	virtual void SAL_CALL setColor( const css::uno::Any& _color ) throw (css::uno::RuntimeException) ;
+
+	virtual css::uno::Any SAL_CALL getColorIndex() throw ( css::uno::RuntimeException);
+	virtual void SAL_CALL setColorIndex( const css::uno::Any& _colorindex ) throw ( css::uno::RuntimeException );
+};
+#endif
+
Index: sc/source/ui/vba/vbaoutline.cxx
===================================================================
RCS file: sc/source/ui/vba/vbaoutline.cxx
diff -N sc/source/ui/vba/vbaoutline.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbaoutline.cxx	21 Feb 2007 17:29:20 -0000	1.1.2.2
@@ -0,0 +1,54 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbaoutline.hxx"
+using namespace ::com::sun::star;
+using namespace ::org::openoffice;
+
+void
+ScVbaOutline::ShowLevels( const uno::Any& RowLevels, const uno::Any& ColumnLevels ) throw (uno::RuntimeException) 
+{
+	sal_Int16 nLevel = 0;
+	if (mxOutline.is()) 
+	{
+		if (RowLevels >>= nLevel)
+		{
+			mxOutline->showLevel(nLevel, table::TableOrientation_ROWS);
+		} 
+		if (ColumnLevels >>= nLevel)
+		{
+			mxOutline->showLevel(nLevel,table::TableOrientation_COLUMNS);
+		}
+	}
+}
Index: sc/source/ui/vba/vbaoutline.hxx
===================================================================
RCS file: sc/source/ui/vba/vbaoutline.hxx
diff -N sc/source/ui/vba/vbaoutline.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbaoutline.hxx	21 Feb 2007 17:29:20 -0000	1.1.2.2
@@ -0,0 +1,58 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_OUTLINE_HXX
+#define SC_VBA_OUTLINE_HXX
+
+#include <com/sun/star/sheet/XSheetOutline.hpp>
+#include <cppuhelper/implbase1.hxx>
+#include <org/openoffice/excel/XOutline.hpp>
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include "vbahelper.hxx"
+
+typedef ::cppu::WeakImplHelper1< oo::excel::XOutline > ScVbaOutline_BASE;
+
+class ScVbaOutline :  public ScVbaOutline_BASE 
+{
+	css::uno::Reference< css::uno::XComponentContext > m_xContext;
+	css::uno::Reference< css::sheet::XSheetOutline > mxOutline;
+public:
+	ScVbaOutline( css::uno::Reference< css::uno::XComponentContext >& xContext,
+		 css::uno::Reference<css::sheet::XSheetOutline> outline):m_xContext(xContext),mxOutline(outline)
+	{}
+	virtual ~ScVbaOutline(){}
+	
+	virtual void SAL_CALL ShowLevels( const css::uno::Any& RowLevels, const css::uno::Any& ColumnLevels ) throw (css::uno::RuntimeException) ;
+};
+#endif
Index: sc/source/ui/vba/vbapalette.cxx
===================================================================
RCS file: sc/source/ui/vba/vbapalette.cxx
diff -N sc/source/ui/vba/vbapalette.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbapalette.cxx	21 Feb 2007 17:29:20 -0000	1.1.2.2
@@ -0,0 +1,106 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbapalette.hxx"
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/beans/XPropertySet.hpp>
+
+
+using namespace ::com::sun::star;
+using namespace ::org::openoffice;
+
+/** Standard EGA colors, bright. */
+#define EXC_PALETTE_EGA_COLORS_LIGHT \
+            0x000000, 0xFFFFFF, 0xFF0000, 0x00FF00, 0x0000FF, 0xFFFF00, 0xFF00FF, 0x00FFFF
+/** Standard EGA colors, dark. */
+#define EXC_PALETTE_EGA_COLORS_DARK \
+            0x800000, 0x008000, 0x000080, 0x808000, 0x800080, 0x008080, 0xC0C0C0, 0x808080
+
+static const ColorData spnDefColorTable8[] =
+{
+/*  8 */    EXC_PALETTE_EGA_COLORS_LIGHT,
+/* 16 */    EXC_PALETTE_EGA_COLORS_DARK,
+/* 24 */    0x9999FF, 0x993366, 0xFFFFCC, 0xCCFFFF, 0x660066, 0xFF8080, 0x0066CC, 0xCCCCFF,
+/* 32 */    0x000080, 0xFF00FF, 0xFFFF00, 0x00FFFF, 0x800080, 0x800000, 0x008080, 0x0000FF,
+/* 40 */    0x00CCFF, 0xCCFFFF, 0xCCFFCC, 0xFFFF99, 0x99CCFF, 0xFF99CC, 0xCC99FF, 0xFFCC99,
+/* 48 */    0x3366FF, 0x33CCCC, 0x99CC00, 0xFFCC00, 0xFF9900, 0xFF6600, 0x666699, 0x969696,
+/* 56 */    0x003366, 0x339966, 0x003300, 0x333300, 0x993300, 0x993366, 0x333399, 0x333333
+};
+
+typedef ::cppu::WeakImplHelper1< container::XIndexAccess > XIndexAccess_BASE;
+
+class DefaultPalette : public XIndexAccess_BASE
+{
+public:
+   DefaultPalette(){}
+
+    // Methods XIndexAccess
+    virtual ::sal_Int32 SAL_CALL getCount() throw (uno::RuntimeException)
+    {
+        return sizeof(spnDefColorTable8) / sizeof(spnDefColorTable8[0]);
+    }
+
+    virtual uno::Any SAL_CALL getByIndex( ::sal_Int32 Index ) throw (lang::IndexOutOfBoundsException, lang::WrappedTargetException, uno::RuntimeException)
+    {
+	if ( Index < 0 || Index >= getCount() )
+		throw lang::IndexOutOfBoundsException();
+        return uno::makeAny( sal_Int32( spnDefColorTable8[ Index ] ) );
+    }
+
+    // Methods XElementAcess
+    virtual uno::Type SAL_CALL getElementType() throw (uno::RuntimeException)
+    {
+        return ::getCppuType( (sal_Int32*)0 );
+    }
+    virtual ::sal_Bool SAL_CALL hasElements() throw (uno::RuntimeException)
+    {
+        return sal_True;
+    }
+
+};
+
+uno::Reference< container::XIndexAccess >
+ScVbaPalette::getPalette()
+{
+	uno::Reference< container::XIndexAccess > xIndex;
+	uno::Reference< beans::XPropertySet > xProps;
+	if ( m_pShell )	
+		xProps.set( m_pShell->GetModel(), uno::UNO_QUERY_THROW );
+	else
+		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Can't extract palette, no doc shell" ) ), uno::Reference< uno::XInterface >() );
+	xIndex.set( xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("ColorPalette") ) ), uno::UNO_QUERY );
+	if ( !xIndex.is() )
+		return new DefaultPalette();
+	return xIndex;	
+}
Index: sc/source/ui/vba/vbapalette.hxx
===================================================================
RCS file: sc/source/ui/vba/vbapalette.hxx
diff -N sc/source/ui/vba/vbapalette.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbapalette.hxx	21 Feb 2007 17:29:21 -0000	1.1.2.2
@@ -0,0 +1,54 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBAPALETTE_HXX
+#define SC_VBAPALETTE_HXX
+
+#include "vbahelper.hxx"
+#include <document.hxx>
+#include <com/sun/star/container/XIndexAccess.hpp>
+
+class ScVbaPalette
+{
+private:
+	SfxObjectShell* m_pShell;
+public:
+	ScVbaPalette(  SfxObjectShell* pShell ) : m_pShell( pShell ){}
+	// if no palette available e.g. because the document doesn't have a 
+	// palette defined then a default palette will be returned.
+	css::uno::Reference< css::container::XIndexAccess > getPalette();
+};
+
+#endif //SC_VBAPALETTE_HXX
+
Index: sc/source/ui/vba/vbapivotcache.cxx
===================================================================
RCS file: sc/source/ui/vba/vbapivotcache.cxx
diff -N sc/source/ui/vba/vbapivotcache.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbapivotcache.cxx	21 Feb 2007 17:29:21 -0000	1.1.2.2
@@ -0,0 +1,50 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbapivotcache.hxx"
+
+
+using namespace ::com::sun::star;
+using namespace ::org::openoffice;
+
+ScVbaPivotCache::ScVbaPivotCache( const uno::Reference< uno::XComponentContext >& xContext,  const uno::Reference< sheet::XDataPilotTable >& xTable ) : m_xContext( xContext ), m_xTable( xTable )
+{
+}
+
+void SAL_CALL 
+ScVbaPivotCache::Refresh() throw (css::uno::RuntimeException)
+{
+	m_xTable->refresh();
+}
+
Index: sc/source/ui/vba/vbapivotcache.hxx
===================================================================
RCS file: sc/source/ui/vba/vbapivotcache.hxx
diff -N sc/source/ui/vba/vbapivotcache.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbapivotcache.hxx	21 Feb 2007 17:29:21 -0000	1.1.2.2
@@ -0,0 +1,56 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_PIVOTCACHE_HXX
+#define SC_VBA_PIVOTCACHE_HXX
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <com/sun/star/sheet/XDataPilotTable.hpp>
+
+#include <org/openoffice/excel/XPivotCache.hpp>
+#include "vbahelper.hxx"
+
+typedef ::cppu::WeakImplHelper1<oo::excel::XPivotCache > PivotCacheImpl_BASE;
+
+class ScVbaPivotCache : public PivotCacheImpl_BASE
+{		
+	css::uno::Reference< css::uno::XComponentContext > m_xContext;
+	css::uno::Reference< css::sheet::XDataPilotTable > m_xTable;
+
+public:
+	ScVbaPivotCache( const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::sheet::XDataPilotTable >& xTable );
+	virtual void SAL_CALL Refresh() throw (css::uno::RuntimeException);
+};
+
+#endif //SC_VBA_PIVOTCACHE_HXX
Index: sc/source/ui/vba/vbapivottable.cxx
===================================================================
RCS file: sc/source/ui/vba/vbapivottable.cxx
diff -N sc/source/ui/vba/vbapivottable.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbapivottable.cxx	21 Feb 2007 17:29:21 -0000	1.1.2.2
@@ -0,0 +1,50 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbapivottable.hxx"
+#include "vbapivotcache.hxx"
+
+
+using namespace ::com::sun::star;
+using namespace ::org::openoffice;
+
+ScVbaPivotTable::ScVbaPivotTable( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< sheet::XDataPilotTable >& xTable ) : m_xContext( xContext ), m_xTable( xTable )
+{
+}
+
+uno::Reference< excel::XPivotCache >
+ScVbaPivotTable::PivotCache() throw (uno::RuntimeException)
+{
+	return new ScVbaPivotCache( m_xContext, m_xTable );
+}
Index: sc/source/ui/vba/vbapivottable.hxx
===================================================================
RCS file: sc/source/ui/vba/vbapivottable.hxx
diff -N sc/source/ui/vba/vbapivottable.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbapivottable.hxx	21 Feb 2007 17:29:21 -0000	1.1.2.2
@@ -0,0 +1,54 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_PIVOTTABLE_HXX
+#define SC_VBA_PIVOTTABLE_HXX
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <com/sun/star/sheet/XDataPilotTable.hpp>
+#include <org/openoffice/excel/XPivotTable.hpp>
+#include "vbahelper.hxx"
+
+typedef ::cppu::WeakImplHelper1<oo::excel::XPivotTable > PivotTableImpl_BASE;
+
+class ScVbaPivotTable : public PivotTableImpl_BASE
+{		
+	css::uno::Reference< css::uno::XComponentContext > m_xContext;
+	css::uno::Reference< css::sheet::XDataPilotTable > m_xTable;
+public:
+	ScVbaPivotTable( const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::sheet::XDataPilotTable >& xTable );
+	virtual css::uno::Reference< oo::excel::XPivotCache > SAL_CALL PivotCache(  ) throw (css::uno::RuntimeException);
+};
+
+#endif //SC_VBA_PIVOTTABLE_HXX
Index: sc/source/ui/vba/vbapivottables.cxx
===================================================================
RCS file: sc/source/ui/vba/vbapivottables.cxx
diff -N sc/source/ui/vba/vbapivottables.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbapivottables.cxx	21 Feb 2007 17:29:21 -0000	1.1.2.2
@@ -0,0 +1,83 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbapivottables.hxx"
+#include "vbapivottable.hxx"
+#include <com/sun/star/sheet/XDataPilotTable.hpp>
+#include <org/openoffice/excel/XPivotTable.hpp>
+
+
+using namespace ::com::sun::star;
+using namespace ::org::openoffice;
+
+uno::Any DataPilotToPivotTable( const uno::Any& aSource, uno::Reference< uno::XComponentContext > & xContext )
+{
+	uno::Reference< sheet::XDataPilotTable > xTable( aSource, uno::UNO_QUERY_THROW );
+	return uno::makeAny( uno::Reference< excel::XPivotTable > ( new ScVbaPivotTable( xContext, xTable ) ) );
+}
+
+class PivotTableEnumeration : public EnumerationHelperImpl
+{
+public:
+	PivotTableEnumeration( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< container::XEnumeration >& xEnumeration ) throw ( uno::RuntimeException ) : EnumerationHelperImpl( xContext, xEnumeration ) {}
+
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException) 
+	{ 
+		return DataPilotToPivotTable( m_xEnumeration->nextElement(),  m_xContext );
+	}
+
+};
+
+ScVbaPivotTables::ScVbaPivotTables( const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< container::XIndexAccess >& xIndexAccess  ):  ScVbaPivotTables_BASE( xContext, xIndexAccess ) 
+{
+}
+
+uno::Reference< container::XEnumeration >
+ScVbaPivotTables::createEnumeration() throw (uno::RuntimeException)
+{
+	uno::Reference< container::XEnumerationAccess > xEnumAccess( m_xIndexAccess, uno::UNO_QUERY_THROW );
+	return new PivotTableEnumeration( m_xContext, xEnumAccess->createEnumeration() );
+}
+
+uno::Any
+ScVbaPivotTables::createCollectionObject( const css::uno::Any& aSource )
+{
+	return DataPilotToPivotTable( aSource,  m_xContext );
+}
+
+uno::Type 
+ScVbaPivotTables::getElementType() throw (uno::RuntimeException)
+{
+	return excel::XPivotTables::static_type(0);
+}
Index: sc/source/ui/vba/vbapivottables.hxx
===================================================================
RCS file: sc/source/ui/vba/vbapivottables.hxx
diff -N sc/source/ui/vba/vbapivottables.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbapivottables.hxx	21 Feb 2007 17:29:21 -0000	1.1.2.2
@@ -0,0 +1,69 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_PIVOTTABLES_HXX
+#define SC_VBA_PIVOTTABLES_HXX
+
+#include <cppuhelper/implbase1.hxx>
+
+#include <org/openoffice/excel/XPivotTables.hpp>
+#include <com/sun/star/container/XEnumerationAccess.hpp>
+#include <com/sun/star/uno/XComponentContext.hpp>
+ 
+#include "vbahelper.hxx"
+#include "vbacollectionimpl.hxx"
+
+
+typedef ::cppu::ImplInheritanceHelper1< ScVbaCollectionBaseImpl, oo::excel::XPivotTables > ScVbaPivotTables_BASE;
+
+class ScVbaPivotTables : public ScVbaPivotTables_BASE
+{
+protected:
+public:
+	ScVbaPivotTables( const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::container::XIndexAccess >& xIndexAccess );
+	virtual ~ScVbaPivotTables() {}
+
+	// XEnumerationAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+
+	// XPivotTables
+
+	// ScVbaCollectionBaseImpl	
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ); 
+
+};
+
+#endif //SC_VBA_PIVOTTABLES
Index: sc/source/ui/vba/vbarange.cxx
===================================================================
RCS file: sc/source/ui/vba/vbarange.cxx
diff -N sc/source/ui/vba/vbarange.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbarange.cxx	5 Mar 2007 13:52:58 -0000	1.1.2.6
@@ -0,0 +1,3768 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include <comphelper/processfactory.hxx>
+#include <sfx2/objsh.hxx>
+
+#include <com/sun/star/script/ArrayWrapper.hpp>
+#include <com/sun/star/sheet/XSheetOperation.hpp>
+#include <com/sun/star/sheet/CellFlags.hpp>
+#include <com/sun/star/table/XColumnRowRange.hpp>
+#include <com/sun/star/sheet/XCellAddressable.hpp>
+#include <com/sun/star/table/CellContentType.hpp>
+#include <com/sun/star/sheet/XCellSeries.hpp>
+#include <com/sun/star/text/XTextRange.hpp>
+#include <com/sun/star/sheet/XCellRangeAddressable.hpp>
+#include <com/sun/star/table/CellRangeAddress.hpp>
+#include <com/sun/star/sheet/XSpreadsheetView.hpp>
+#include <com/sun/star/sheet/XCellRangeReferrer.hpp>
+#include <com/sun/star/sheet/XSheetCellRange.hpp>
+#include <com/sun/star/sheet/XSpreadsheet.hpp>
+#include <com/sun/star/sheet/XSheetCellCursor.hpp>
+#include <com/sun/star/sheet/XArrayFormulaRange.hpp>
+#include <com/sun/star/sheet/XNamedRange.hpp>
+#include <com/sun/star/sheet/XPrintAreas.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/sheet/XFunctionAccess.hpp>
+#include <com/sun/star/frame/XModel.hpp>
+#include <com/sun/star/view/XSelectionSupplier.hpp>
+#include <com/sun/star/table/XCellCursor.hpp>
+#include <com/sun/star/table/XTableRows.hpp>
+#include <com/sun/star/table/XTableColumns.hpp>
+#include <com/sun/star/table/TableSortField.hpp>
+#include <com/sun/star/util/XMergeable.hpp>
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <com/sun/star/lang/XMultiComponentFactory.hpp>
+#include <com/sun/star/sheet/XSpreadsheetDocument.hpp>
+#include <com/sun/star/util/XNumberFormatsSupplier.hpp>
+#include <com/sun/star/util/XNumberFormats.hpp>
+#include <com/sun/star/util/NumberFormat.hpp>
+#include <com/sun/star/util/XNumberFormatTypes.hpp>
+#include <com/sun/star/util/XReplaceable.hpp>
+#include <com/sun/star/util/XSortable.hpp>
+#include <com/sun/star/sheet/XCellRangeMovement.hpp>
+#include <com/sun/star/sheet/XCellRangeData.hpp>
+#include <com/sun/star/sheet/FormulaResult.hpp>
+#include <com/sun/star/sheet/TableFilterField.hpp>
+#include <com/sun/star/sheet/XSheetFilterable.hpp>
+#include <com/sun/star/sheet/FilterConnection.hpp>
+
+#include <com/sun/star/style/XStyleFamiliesSupplier.hpp>
+#include <com/sun/star/awt/XDevice.hpp>
+
+//#include <com/sun/star/sheet/CellDeleteMode.hpp>
+#include <com/sun/star/sheet/XCellRangeMovement.hpp>
+
+#include <org/openoffice/excel/XlPasteSpecialOperation.hpp>
+#include <org/openoffice/excel/XlPasteType.hpp>
+#include <org/openoffice/excel/Constants.hpp>
+#include <org/openoffice/excel/XlFindLookIn.hpp>
+#include <org/openoffice/excel/XlLookAt.hpp>
+#include <org/openoffice/excel/XlSearchOrder.hpp>
+#include <org/openoffice/excel/XlSortOrder.hpp>
+#include <org/openoffice/excel/XlYesNoGuess.hpp>
+#include <org/openoffice/excel/XlSortOrientation.hpp>
+#include <org/openoffice/excel/XlSortMethod.hpp>
+#include <org/openoffice/excel/XlDirection.hpp>
+#include <org/openoffice/excel/XlSortDataOption.hpp>
+#include <org/openoffice/excel/XlDeleteShiftDirection.hpp>
+#include <org/openoffice/excel/XlInsertShiftDirection.hpp>
+#include <org/openoffice/excel/XlReferenceStyle.hpp>
+#include <org/openoffice/excel/XlBordersIndex.hpp>
+#include <org/openoffice/excel/XlPageBreak.hpp>
+#include <org/openoffice/excel/XlAutoFilterOperator.hpp>
+#include <org/openoffice/excel/XlAutoFillType.hpp>
+#include <org/openoffice/excel/XlTextParsingType.hpp>
+#include <org/openoffice/excel/XlTextQualifier.hpp>
+
+#include <scitems.hxx>
+#include <svx/srchitem.hxx>
+#include <cellsuno.hxx>
+#include <dbcolect.hxx>
+#include "docfunc.hxx"
+
+#include <sfx2/dispatch.hxx>
+#include <sfx2/app.hxx>
+#include <sfx2/bindings.hxx>
+#include <sfx2/request.hxx>
+#include <sfx2/viewfrm.hxx>
+#include <sfx2/itemwrapper.hxx>
+#include <sc.hrc>
+#include <globstr.hrc>
+#include <unonames.hxx>
+
+#include "vbarange.hxx"
+#include "vbafont.hxx"
+#include "vbacomment.hxx"
+#include "vbainterior.hxx"
+#include "vbacharacters.hxx"
+#include "vbaborders.hxx"
+#include "vbaworksheet.hxx"
+#include "vbavalidation.hxx"
+
+#include "tabvwsh.hxx"
+#include "rangelst.hxx"
+#include "convuno.hxx"
+#include "compiler.hxx"
+#include "attrib.hxx"
+#include "undodat.hxx"
+#include "dbdocfun.hxx"
+#include <comphelper/anytostring.hxx>
+
+#include <global.hxx>
+
+#include "vbaglobals.hxx"
+#include <vector>
+#include <vbacollectionimpl.hxx>
+// begin test includes
+#include <com/sun/star/sheet/FunctionArgument.hpp>
+// end test includes
+
+using namespace ::org::openoffice;
+using namespace ::com::sun::star;
+
+//    * 1 point = 1/72 inch = 20 twips
+//    * 1 inch = 72 points = 1440 twips
+//    * 1 cm = 567 twips
+double lcl_hmmToPoints( double nVal ) { return ( (double)((nVal /1000 ) * 567 ) / 20 ); }
+double lcl_pointsToHmm( double nVal ) { return (double)( ( nVal * 20 ) / 567 ) * 1000; }
+
+static const sal_Int16 supportedIndexTable[] = {  excel::XlBordersIndex::xlEdgeLeft, excel::XlBordersIndex::xlEdgeTop, excel::XlBordersIndex::xlEdgeBottom, excel::XlBordersIndex::xlEdgeRight, excel::XlBordersIndex::xlDiagonalDown, excel::XlBordersIndex::xlDiagonalUp, excel::XlBordersIndex::xlInsideVertical, excel::XlBordersIndex::xlInsideHorizontal };
+
+USHORT lcl_pointsToTwips( double nVal ) 
+{ 
+	nVal = nVal * static_cast<double>(20);
+	short nTwips = static_cast<short>(nVal);
+	return nTwips;
+}
+double lcl_TwipsToPoints( USHORT nVal ) 
+{ 
+	double nPoints = nVal;
+	return nPoints / 20; 
+}
+
+double lcl_Round2DecPlaces( double nVal )
+{
+	nVal  = (nVal * (double)100);
+	long tmp = static_cast<long>(nVal);
+	if ( ( ( nVal - tmp ) >= 0.5 ) )
+		++tmp;
+	nVal = tmp;
+	nVal = nVal/100;
+	return nVal;
+}
+
+uno::Any lcl_makeRange( uno::Reference< uno::XComponentContext >& xContext, const uno::Any aAny )
+{
+	uno::Reference< table::XCellRange > xCellRange( aAny, uno::UNO_QUERY_THROW );
+	return uno::makeAny( uno::Reference< excel::XRange >( new ScVbaRange( xContext, xCellRange ) ) );
+}
+
+SfxItemSet*  ScVbaRange::getCurrentDataSet( ) throw ( uno::RuntimeException )
+{
+	uno::Reference< uno::XInterface > xIf( mxRange, uno::UNO_QUERY_THROW );
+	//ScCellRangeObj* pUnoCellRange = dynamic_cast< ScCellRangeObj* >( xIf.get() );
+	// FOR_UPSTREAM_BUILD
+	/*SfxItemSet* pDataSet = 	pUnoCellRange->GetCurrentDataSet( true );
+	
+	if ( !pDataSet )
+		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Can't access Itemset for range" ) ), uno::Reference< uno::XInterface >() );
+	return pDataSet;	
+	*/
+	return NULL;
+}
+
+class SingleRangeEnumeration : public EnumerationHelper_BASE
+{
+	uno::Reference< table::XCellRange > m_xRange;
+	uno::Reference< uno::XComponentContext > m_xContext;
+	bool bHasMore;
+public:
+
+	SingleRangeEnumeration( const uno::Reference< css::uno::XComponentContext >& xContext, const uno::Reference< table::XCellRange >& xRange ) throw ( uno::RuntimeException ) : m_xRange( xRange ), m_xContext( xContext ), bHasMore( true ) { }
+	virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException) { return bHasMore; }
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException) 
+	{
+		if ( !bHasMore )
+			throw container::NoSuchElementException();
+		bHasMore = false;
+		return uno::makeAny( m_xRange );
+	}
+};
+
+// very simple class to pass to ScVbaCollectionBaseImpl containing
+// just one item
+typedef ::cppu::WeakImplHelper2< container::XIndexAccess, container::XEnumerationAccess > SingleRange_BASE;
+
+class SingleRangeIndexAccess : public SingleRange_BASE
+{
+private:
+	uno::Reference< table::XCellRange > m_xRange;
+	uno::Reference< uno::XComponentContext > m_xContext;
+	SingleRangeIndexAccess(); // not defined
+public:
+	SingleRangeIndexAccess( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< table::XCellRange >& xRange ):m_xRange( xRange ), m_xContext( xContext ) {}
+	// XIndexAccess
+	virtual ::sal_Int32 SAL_CALL getCount() throw (::uno::RuntimeException) { return 1; }
+	virtual uno::Any SAL_CALL getByIndex( ::sal_Int32 Index ) throw (lang::IndexOutOfBoundsException, lang::WrappedTargetException, uno::RuntimeException)
+	{ 
+		if ( Index != 0 )
+			throw lang::IndexOutOfBoundsException();
+		return uno::makeAny( m_xRange ); 
+	}
+        // XElementAccess
+        virtual uno::Type SAL_CALL getElementType() throw (uno::RuntimeException){ return table::XCellRange::static_type(0); }
+ 
+        virtual ::sal_Bool SAL_CALL hasElements() throw (uno::RuntimeException) { return sal_True; }
+	// XEnumerationAccess
+	virtual uno::Reference< container::XEnumeration > SAL_CALL createEnumeration() throw (uno::RuntimeException) { return new SingleRangeEnumeration( m_xContext, m_xRange ); }
+
+};
+
+
+
+class RangesEnumerationImpl : public EnumerationHelperImpl
+{
+public:
+
+	RangesEnumerationImpl( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< container::XEnumeration >& xEnumeration ) throw ( uno::RuntimeException ) : EnumerationHelperImpl( xContext, xEnumeration ) {}
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException) 
+	{ 
+		return lcl_makeRange( m_xContext, m_xEnumeration->nextElement() );
+	}
+};
+
+
+class ScVbaRangeAreas : public ScVbaCollectionBaseImpl
+{
+
+public:
+	ScVbaRangeAreas( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< container::XIndexAccess >& xIndexAccess ) : ScVbaCollectionBaseImpl( xContext, xIndexAccess ) {}
+
+	// XEnumerationAccess
+	virtual uno::Reference< container::XEnumeration > SAL_CALL createEnumeration() throw (uno::RuntimeException);
+
+	// XElementAccess
+	virtual uno::Type SAL_CALL getElementType() throw (uno::RuntimeException){ return excel::XRange::static_type(0); }
+
+	virtual uno::Any createCollectionObject( const uno::Any& aSource );
+};
+
+
+uno::Reference< container::XEnumeration > SAL_CALL 
+ScVbaRangeAreas::createEnumeration() throw (uno::RuntimeException)
+{
+	uno::Reference< container::XEnumerationAccess > xEnumAccess( m_xIndexAccess, uno::UNO_QUERY_THROW );
+	return new RangesEnumerationImpl( m_xContext, xEnumAccess->createEnumeration() );
+
+}
+
+uno::Any 
+ScVbaRangeAreas::createCollectionObject( const uno::Any& aSource )
+{
+	return lcl_makeRange( m_xContext, aSource );
+}
+
+
+
+
+ScDocShell* getDocShellFromRange( const uno::Reference< table::XCellRange >& xRange )
+{
+	// need the ScCellRangesBase to get docshell
+	uno::Reference< uno::XInterface > xIf( xRange, uno::UNO_QUERY_THROW );
+	ScCellRangesBase* pUno= dynamic_cast< ScCellRangesBase* >( xIf.get() );
+	if ( !pUno )
+		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Failed to access underlying uno range object" ) ), uno::Reference< uno::XInterface >()  );
+	return pUno->GetDocShell();
+}
+
+ScDocument* getDocumentFromRange( const uno::Reference< table::XCellRange >& xRange )
+{
+	ScDocShell* pDocShell = getDocShellFromRange( xRange );
+	if ( !pDocShell )
+		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Failed to access underlying docshell from uno range object" ) ), uno::Reference< uno::XInterface >() );
+	ScDocument* pDoc = pDocShell->GetDocument();
+	return pDoc;
+}
+
+class NumFormatHelper
+{
+	uno::Reference< util::XNumberFormatsSupplier > mxSupplier;
+	uno::Reference< beans::XPropertySet > mxRangeProps;
+	uno::Reference< util::XNumberFormats > mxFormats;
+public:
+	NumFormatHelper( const uno::Reference< table::XCellRange >& xRange )
+	{
+		mxSupplier.set( getCurrentDocument(), uno::UNO_QUERY_THROW );
+		mxRangeProps.set( xRange, uno::UNO_QUERY_THROW);
+		mxFormats = mxSupplier->getNumberFormats();
+	}
+	uno::Reference< beans::XPropertySet > getNumberProps()
+	{	
+		long nIndexKey;
+		uno::Any aValue = mxRangeProps->getPropertyValue(rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NumberFormat")));
+		aValue >>= nIndexKey;
+
+		if ( mxFormats.is() )
+			return  mxFormats->getByKey( nIndexKey );
+		return	uno::Reference< beans::XPropertySet > ();
+	}
+
+	bool isBooleanType()
+	{
+	
+		if ( getNumberFormat() & util::NumberFormat::LOGICAL )
+			return true;
+		return false;
+	}
+
+	rtl::OUString getNumberFormatString()
+	{
+		uno::Reference< uno::XInterface > xIf( mxRangeProps, uno::UNO_QUERY_THROW );
+		ScCellRangeObj* pUnoCellRange = dynamic_cast<  ScCellRangeObj* >( xIf.get() );
+		if ( pUnoCellRange )
+		{
+			// FOR_UPSTREAM_BUILD
+			/*
+			SfxItemSet* pDataSet = 	pUnoCellRange->GetCurrentDataSet( true );
+			SfxItemState eState = pDataSet->GetItemState( ATTR_VALUE_FORMAT, TRUE, NULL);
+			// one of the cells in the range is not like the other ;-)
+			// so return a zero length format to indicate that
+			if ( eState == SFX_ITEM_DONTCARE )
+				return rtl::OUString();
+			*/
+		}
+		
+	
+		uno::Reference< beans::XPropertySet > xNumberProps( getNumberProps(), uno::UNO_QUERY_THROW );
+		::rtl::OUString aFormatString;
+		uno::Any aString = xNumberProps->getPropertyValue(rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FormatString")));
+		aString >>= aFormatString;
+		return aFormatString;
+	}
+
+	sal_Int16 getNumberFormat()
+	{
+		uno::Reference< beans::XPropertySet > xNumberProps = getNumberProps(); 	
+		sal_Int16 nType = ::comphelper::getINT16(
+        	xNumberProps->getPropertyValue( ::rtl::OUString::createFromAscii( "Type" ) ) );
+		return nType;
+	}
+
+	bool setNumberFormat( const  rtl::OUString& rFormat )
+	{
+		lang::Locale aLocale;
+		uno::Reference< beans::XPropertySet > xNumProps = getNumberProps(); 	
+		xNumProps->getPropertyValue( ::rtl::OUString::createFromAscii( "Locale" ) ) >>= aLocale;
+		sal_Int32 nNewIndex = mxFormats->queryKey(rFormat, aLocale, false );
+		if ( nNewIndex == -1 ) // format not defined
+		{
+			nNewIndex = mxFormats->addNew( rFormat, aLocale );
+		}
+		mxRangeProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NumberFormat") ), uno::makeAny( nNewIndex ) );				
+		return true;
+	}
+
+	bool setNumberFormat( sal_Int16 nType )
+	{
+		uno::Reference< beans::XPropertySet > xNumberProps = getNumberProps(); 	
+		lang::Locale aLocale;
+		xNumberProps->getPropertyValue( ::rtl::OUString::createFromAscii( "Locale" ) ) >>= aLocale;
+		uno::Reference<util::XNumberFormatTypes> xTypes( mxFormats, uno::UNO_QUERY );
+		if ( xTypes.is() )
+		{
+			sal_Int32 nNewIndex = xTypes->getStandardFormat( nType, aLocale );
+       		mxRangeProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NumberFormat") ), uno::makeAny( nNewIndex ) );				
+			return true;
+		}
+		return false;
+	}
+
+};
+
+struct CellPos
+{
+	CellPos():m_nRow(-1), m_nCol(-1) {};
+	CellPos( sal_Int32 nRow, sal_Int32 nCol ):m_nRow(nRow), m_nCol(nCol) {};
+sal_Int32 m_nRow;
+sal_Int32 m_nCol;
+};
+
+typedef ::cppu::WeakImplHelper1< container::XEnumeration > CellsEnumeration_BASE;
+typedef vector< CellPos > vCellPos;
+
+class CellsEnumeration : public CellsEnumeration_BASE
+{
+	uno::Reference< uno::XComponentContext > m_xContext;
+	uno::Reference< table::XCellRange > m_xRange;
+	vCellPos m_CellPositions;	
+	vCellPos::const_iterator m_it; 
+public:
+	CellsEnumeration( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< table::XCellRange >& xRange ): m_xContext( xContext ), m_xRange( xRange )
+	{
+		uno::Reference< table::XColumnRowRange > xColumnRowRange(m_xRange, uno::UNO_QUERY_THROW );
+		sal_Int32 nRowCount =  xColumnRowRange->getRows()->getCount();
+		sal_Int32 nColCount = xColumnRowRange->getColumns()->getCount();
+		for ( sal_Int32 i=0; i<nRowCount; ++i )
+			for ( sal_Int32 j=0; j<nColCount; ++j )
+				m_CellPositions.push_back( CellPos( i,j ) );
+		m_it = m_CellPositions.begin();
+	}
+	virtual ::sal_Bool SAL_CALL hasMoreElements() throw (::uno::RuntimeException){ return m_it != m_CellPositions.end(); }
+
+	virtual uno::Any SAL_CALL nextElement() throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+	{
+		if ( !hasMoreElements() )
+			throw container::NoSuchElementException();
+		CellPos aPos = *(m_it)++;
+		uno::Reference< table::XCellRange > xCellRange( m_xRange->getCellByPosition(  aPos.m_nCol, aPos.m_nRow ), uno::UNO_QUERY_THROW );
+		return uno::makeAny( uno::Reference< excel::XRange >( new ScVbaRange( m_xContext, xCellRange ) ) );
+	}
+};
+
+
+const static ::rtl::OUString ISVISIBLE(  RTL_CONSTASCII_USTRINGPARAM( "IsVisible"));
+const static ::rtl::OUString WIDTH(  RTL_CONSTASCII_USTRINGPARAM( "Width"));
+const static ::rtl::OUString HEIGHT(  RTL_CONSTASCII_USTRINGPARAM( "Height"));
+const static rtl::OUString EQUALS( RTL_CONSTASCII_USTRINGPARAM("=") );
+const static rtl::OUString CONTS_HEADER( RTL_CONSTASCII_USTRINGPARAM("ContainsHeader" ));
+
+class CellValueSetter : public ValueSetter
+{
+protected:
+	uno::Any maValue;
+	uno::TypeClass mTypeClass;
+public:
+	CellValueSetter( const uno::Any& aValue );
+	virtual bool processValue( const uno::Any& aValue,  const uno::Reference< table::XCell >& xCell );
+	virtual void visitNode( sal_Int32 x, sal_Int32 y, const uno::Reference< table::XCell >& xCell );
+		
+};
+
+CellValueSetter::CellValueSetter( const uno::Any& aValue ): maValue( aValue ), mTypeClass( aValue.getValueTypeClass() ) {}
+
+void
+CellValueSetter::visitNode( sal_Int32 /*i*/, sal_Int32 /*j*/, const uno::Reference< table::XCell >& xCell )
+{
+	processValue( maValue, xCell );
+}
+
+bool
+CellValueSetter::processValue( const uno::Any& aValue, const uno::Reference< table::XCell >& xCell )
+{
+
+	bool isExtracted = false;
+	switch ( aValue.getValueTypeClass() )
+	{
+		case  uno::TypeClass_BOOLEAN:
+		{
+			sal_Bool bState;
+			if ( aValue >>= bState 	 )
+			{
+				uno::Reference< table::XCellRange > xRange( xCell, uno::UNO_QUERY_THROW );
+				if ( bState )
+					xCell->setValue( (double) 1 );
+				else
+					xCell->setValue( (double) 0 );
+				NumFormatHelper cellNumFormat( xRange );
+				cellNumFormat.setNumberFormat( util::NumberFormat::LOGICAL );
+			}
+			break;
+		}
+		case uno::TypeClass_STRING:
+		{
+			rtl::OUString aString;
+			if ( aValue >>= aString )
+			{
+				uno::Reference< text::XTextRange > xTextRange( xCell, uno::UNO_QUERY_THROW );
+				xTextRange->setString( aString );
+			}
+			else
+				isExtracted = false;	
+			break;
+		}
+		default:
+		{
+			double nDouble;
+			if ( aValue >>= nDouble )
+				xCell->setValue( nDouble );
+			else
+				isExtracted = false;	
+			break;
+		}
+	}
+	return isExtracted;
+		
+}
+
+
+class CellValueGetter : public ValueGetter
+{
+protected:
+	uno::Any maValue;
+	uno::TypeClass mTypeClass;
+public:
+	CellValueGetter() {}
+	virtual void visitNode( sal_Int32 x, sal_Int32 y, const uno::Reference< table::XCell >& xCell );
+	virtual void processValue( sal_Int32 x, sal_Int32 y, const uno::Any& aValue );
+	const uno::Any& getValue() const { return maValue; }
+		
+};
+
+void
+CellValueGetter::processValue(  sal_Int32 /*x*/, sal_Int32 /*y*/, const uno::Any& aValue )
+{
+	maValue = aValue;
+}
+void CellValueGetter::visitNode( sal_Int32 x, sal_Int32 y, const uno::Reference< table::XCell >& xCell )
+{
+	uno::Any aValue;
+	table::CellContentType eType = xCell->getType();
+	if( eType == table::CellContentType_VALUE || eType == table::CellContentType_FORMULA )
+	{
+		if ( eType == table::CellContentType_FORMULA )
+		{
+			rtl::OUString sFormula = xCell->getFormula();
+			if ( sFormula.equals( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("=TRUE()") ) ) )
+				aValue <<= sal_True;
+			else if ( sFormula.equals( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("=FALSE()") ) ) )
+				aValue <<= sal_False;
+			else 	
+				aValue <<= xCell->getValue();
+		}
+		else
+		{
+			uno::Reference< table::XCellRange > xRange( xCell, uno::UNO_QUERY_THROW );
+			NumFormatHelper cellFormat( xRange );
+			if ( cellFormat.isBooleanType() )
+				aValue = uno::makeAny( ( xCell->getValue() != 0.0 ) );
+			else
+				aValue <<= xCell->getValue();
+		}
+	}
+	if( eType == table::CellContentType_TEXT )
+	{
+		uno::Reference< text::XTextRange > xTextRange(xCell, ::uno::UNO_QUERY_THROW);
+		aValue <<= xTextRange->getString();
+	}
+	processValue( x,y,aValue );
+}
+
+class CellFormulaValueSetter : public CellValueSetter
+{
+private:
+	ScDocument*  m_pDoc;
+	ScAddress::Convention m_eConv;
+public:
+	CellFormulaValueSetter( const uno::Any& aValue, ScDocument* pDoc, ScAddress::Convention eConv  ):CellValueSetter( aValue ),  m_pDoc( pDoc ), m_eConv( eConv ){}
+protected:
+	bool processValue( const uno::Any& aValue, const uno::Reference< table::XCell >& xCell )
+	{
+		rtl::OUString sFormula;
+		if ( aValue >>= sFormula )
+		{
+			// get current convention
+			ScAddress::Convention eConv = m_pDoc->GetAddressConvention();
+			if ( eConv != m_eConv )	
+			{
+				uno::Reference< uno::XInterface > xIf( xCell, uno::UNO_QUERY_THROW );
+				ScCellRangesBase* pUnoRangesBase = dynamic_cast< ScCellRangesBase* >( xIf.get() );
+				if ( pUnoRangesBase )
+				{
+					ScRangeList aCellRanges = pUnoRangesBase->GetRangeList();	
+					ScCompiler aCompiler( m_pDoc, aCellRanges.First()->aStart );
+					// compile the string in the format passed in
+					aCompiler.CompileString( sFormula, m_eConv );
+					// set desired convention to that of the document
+					aCompiler.SetRefConvention( eConv );
+					String sConverted;
+					aCompiler.CreateStringFromTokenArray(sConverted);
+					sFormula = EQUALS + sConverted;
+				}
+			}
+
+			xCell->setFormula( sFormula );
+			return true;
+		}
+		return false;
+	}
+		
+};
+
+class CellFormulaValueGetter : public CellValueGetter
+{
+private:
+	ScDocument*  m_pDoc;
+	ScAddress::Convention m_eConv;
+public:
+	CellFormulaValueGetter(ScDocument* pDoc, ScAddress::Convention eConv ) : CellValueGetter( ), m_pDoc( pDoc ), m_eConv( eConv ) {}
+	virtual void visitNode( sal_Int32 x, sal_Int32 y, const uno::Reference< table::XCell >& xCell )
+	{
+		uno::Any aValue;
+		aValue <<= xCell->getFormula();	
+		rtl::OUString sVal;
+		aValue >>= sVal;
+		uno::Reference< uno::XInterface > xIf( xCell, uno::UNO_QUERY_THROW );
+		ScCellRangesBase* pUnoRangesBase = dynamic_cast< ScCellRangesBase* >( xIf.get() );
+		if ( ( xCell->getType() == table::CellContentType_FORMULA ) &&
+			pUnoRangesBase )
+		{
+			ScRangeList aCellRanges = pUnoRangesBase->GetRangeList();	
+			ScCompiler aCompiler( m_pDoc, aCellRanges.First()->aStart );
+			aCompiler.CompileString( sVal,  ScAddress::CONV_OOO );
+			// set desired convention
+			aCompiler.SetRefConvention( m_eConv );
+			String sConverted;
+			aCompiler.CreateStringFromTokenArray(sConverted);
+			sVal = EQUALS + sConverted;
+			aValue <<= sVal;
+		}
+
+		processValue( x,y,aValue );
+	}
+		
+};
+
+
+class Dim2ArrayValueGetter : public ArrayVisitor
+{
+protected:
+	uno::Any maValue;
+	ValueGetter& mValueGetter;
+	virtual void processValue( sal_Int32 x, sal_Int32 y, const uno::Any& aValue )
+	{
+		uno::Sequence< uno::Sequence< uno::Any > >& aMatrix = *( uno::Sequence< uno::Sequence< uno::Any > >* )( maValue.getValue() );
+		aMatrix[x][y] = aValue;
+	}
+
+public:
+	Dim2ArrayValueGetter(sal_Int32 nRowCount, sal_Int32 nColCount, ValueGetter& rValueGetter ): mValueGetter(rValueGetter) 
+	{
+		uno::Sequence< uno::Sequence< uno::Any > > aMatrix;
+		aMatrix.realloc( nRowCount );	
+		for ( sal_Int32 index = 0; index < nRowCount; ++index )
+			aMatrix[index].realloc( nColCount );
+		maValue <<= aMatrix;
+	}
+	void visitNode( sal_Int32 x, sal_Int32 y, const uno::Reference< table::XCell >& xCell )
+
+	{
+		mValueGetter.visitNode( x, y, xCell );
+		processValue( x, y, mValueGetter.getValue() );
+	}
+	const uno::Any& getValue() const { return maValue; }
+
+};
+
+const static rtl::OUString sNA = rtl::OUString::createFromAscii("#N/A"); 
+
+class Dim1ArrayValueSetter : public ArrayVisitor
+{
+	uno::Sequence< uno::Any > aMatrix;
+	sal_Int32 nColCount;
+	ValueSetter& mCellValueSetter;
+public:
+	Dim1ArrayValueSetter( const uno::Any& aValue, ValueSetter& rCellValueSetter ):mCellValueSetter( rCellValueSetter )
+	{
+		aValue >>= aMatrix;
+		nColCount = aMatrix.getLength();
+	}
+	virtual void visitNode( sal_Int32 /*x*/, sal_Int32 y, const uno::Reference< table::XCell >& xCell )
+	{
+		if ( y < nColCount )
+			mCellValueSetter.processValue( aMatrix[ y ], xCell );
+		else
+			mCellValueSetter.processValue( uno::makeAny( sNA ), xCell );
+	}
+};
+
+
+
+class Dim2ArrayValueSetter : public ArrayVisitor
+{
+	uno::Sequence< uno::Sequence< uno::Any > > aMatrix;
+	ValueSetter& mCellValueSetter;
+	sal_Int32 nRowCount;
+	sal_Int32 nColCount;
+public:
+	Dim2ArrayValueSetter( const uno::Any& aValue, ValueSetter& rCellValueSetter ) : mCellValueSetter( rCellValueSetter )
+	{
+		aValue >>= aMatrix;
+		nRowCount = aMatrix.getLength();
+		nColCount = aMatrix[0].getLength();  
+	}
+
+	virtual void visitNode( sal_Int32 x, sal_Int32 y, const uno::Reference< table::XCell >& xCell )
+	{
+		if ( x < nRowCount && y < nColCount )
+			mCellValueSetter.processValue( aMatrix[ x ][ y ], xCell );
+		else
+			mCellValueSetter.processValue( uno::makeAny( sNA ), xCell );
+			
+	}
+};
+
+class RangeProcessor
+{
+public:
+	virtual void process( const uno::Reference< excel::XRange >& xRange ) = 0;
+};
+
+class RangeValueProcessor : public RangeProcessor
+{
+	const uno::Any& m_aVal;
+public:
+	RangeValueProcessor( const uno::Any& rVal ):m_aVal( rVal ) {}
+	virtual void process( const uno::Reference< excel::XRange >& xRange )
+	{
+		xRange->setValue( m_aVal );
+	}
+};
+
+class RangeFormulaProcessor : public RangeProcessor
+{
+	const uno::Any& m_aVal;
+public:
+	RangeFormulaProcessor( const uno::Any& rVal ):m_aVal( rVal ) {}
+	virtual void process( const uno::Reference< excel::XRange >& xRange ) 
+	{
+		xRange->setFormula( m_aVal );
+	}
+};
+
+class RangeCountProcessor : public RangeProcessor
+{
+	double nCount;
+public:
+	RangeCountProcessor():nCount(0){}
+	virtual void process( const uno::Reference< excel::XRange >& xRange )
+	{
+		nCount = nCount + xRange->getCount();
+	}
+	double value() { return nCount; }
+};
+class AreasVisitor
+{
+private:
+	uno::Reference< vba::XCollection > m_Areas;
+public:
+	AreasVisitor( const uno::Reference< vba::XCollection >& rAreas ):m_Areas( rAreas ){} 
+	
+	void visit( RangeProcessor& processor )
+	{
+		if ( m_Areas.is() )
+		{
+			sal_Int32 nItems = m_Areas->getCount();
+			for ( sal_Int32 index=1; index <= nItems; ++index )
+			{
+				uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index) ), uno::UNO_QUERY_THROW );
+				processor.process( xRange ); 
+			}
+		}	
+	}
+};
+
+class RangeHelper
+{
+	uno::Reference< table::XCellRange > m_xCellRange;
+	
+public:
+	RangeHelper( const uno::Reference< table::XCellRange >& xCellRange ) throw (uno::RuntimeException) : m_xCellRange( xCellRange ) 
+	{
+		if ( !m_xCellRange.is() )
+			throw uno::RuntimeException();
+	}
+	RangeHelper( const uno::Any aCellRange ) throw (uno::RuntimeException)
+	{
+		m_xCellRange.set( aCellRange, uno::UNO_QUERY_THROW );
+	}
+	uno::Reference< sheet::XSheetCellRange > getSheetCellRange() throw (uno::RuntimeException)
+	{
+		return uno::Reference< sheet::XSheetCellRange >(m_xCellRange, uno::UNO_QUERY_THROW);
+	}
+	uno::Reference< sheet::XSpreadsheet >  getSpreadSheet() throw (uno::RuntimeException)
+	{
+		return getSheetCellRange()->getSpreadsheet();
+	}	
+
+	uno::Reference< table::XCellRange > getCellRangeFromSheet() throw (uno::RuntimeException)
+	{
+		return uno::Reference< table::XCellRange >(getSpreadSheet(), uno::UNO_QUERY_THROW );
+	}
+
+	uno::Reference< sheet::XCellRangeAddressable >  getCellRangeAddressable() throw (uno::RuntimeException)
+	{
+		return uno::Reference< sheet::XCellRangeAddressable >(m_xCellRange, ::uno::UNO_QUERY_THROW);
+
+	}
+
+	uno::Reference< sheet::XSheetCellCursor > getSheetCellCursor() throw ( uno::RuntimeException )
+	{
+		return 	uno::Reference< sheet::XSheetCellCursor >( getSpreadSheet()->createCursorByRange( getSheetCellRange() ), uno::UNO_QUERY_THROW );
+	}	
+
+	static uno::Reference< excel::XRange > createRangeFromRange( const uno::Reference<uno::XComponentContext >& xContext, const uno::Reference< table::XCellRange >& xRange, const uno::Reference< sheet::XCellRangeAddressable >& xCellRangeAddressable, sal_Int32 nStartColOffset = 0, sal_Int32 nStartRowOffset = 0,
+ sal_Int32 nEndColOffset = 0, sal_Int32 nEndRowOffset = 0 )
+	{
+		return uno::Reference< excel::XRange >( new ScVbaRange( xContext, 
+			xRange->getCellRangeByPosition(
+				xCellRangeAddressable->getRangeAddress().StartColumn + nStartColOffset,
+				xCellRangeAddressable->getRangeAddress().StartRow + nStartRowOffset,
+				xCellRangeAddressable->getRangeAddress().EndColumn + nEndColOffset,
+				xCellRangeAddressable->getRangeAddress().EndRow + nEndRowOffset ) ) );
+	}
+	
+};
+
+static table::CellRangeAddress getCellRangeAddress( const uno::Any& aParam,
+const uno::Reference< sheet::XSpreadsheet >& xDoc )
+{
+	uno::Reference< table::XCellRange > xRangeParam;
+	switch ( aParam.getValueTypeClass() )
+	{
+		case uno::TypeClass_STRING:
+		{
+			rtl::OUString rString;
+			aParam >>= rString;
+			xRangeParam = ScVbaRange::getCellRangeForName( rString, xDoc );
+			break;
+		}
+		case uno::TypeClass_INTERFACE:
+		{
+			uno::Reference< excel::XRange > xRange;
+			aParam >>= xRange;
+			if ( xRange.is() )
+				xRange->getCellRange() >>= xRangeParam;
+			break;
+		}
+		default:
+			throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Can't extact CellRangeAddress from type" ) ), uno::Reference< uno::XInterface >() );
+	}
+	uno::Reference< sheet::XCellRangeAddressable > xAddressable( xRangeParam, uno::UNO_QUERY_THROW );
+	return xAddressable->getRangeAddress();
+}
+
+bool
+getCellRangesForAddress( USHORT& rResFlags, const rtl::OUString& sAddress, ScDocShell* pDocSh, ScRangeList& rCellRanges, ScAddress::Convention& eConv )
+{
+	
+	ScDocument* pDoc = NULL;
+	if ( pDocSh )
+	{
+		pDoc = pDocSh->GetDocument();
+		String aString(sAddress);
+		USHORT nMask = SCA_VALID;
+		//USHORT nParse = rCellRanges.Parse( sAddress, pDoc, nMask, ScAddress::CONV_XL_A1 );
+		rResFlags = rCellRanges.Parse( sAddress, pDoc, nMask, eConv, 0 );
+		if ( rResFlags & SCA_VALID )
+		{
+			return true;
+		}
+	} 
+	return false;
+} 
+
+ScVbaRange*
+getRangeForName( const uno::Reference< uno::XComponentContext >& xContext, const rtl::OUString& sName, ScDocShell* pDocSh, table::CellRangeAddress& pAddr ) throw ( uno::RuntimeException )
+{
+	rtl::OUString sAddress = sName;
+	ScAddress::Convention eConv = ScAddress::CONV_XL_A1; 
+	// see if there is a match with a named range
+	uno::Reference< beans::XPropertySet > xProps( getCurrentDocument(), uno::UNO_QUERY_THROW );
+	uno::Reference< container::XNameAccess > xNameAccess( xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("NamedRanges") ) ), uno::UNO_QUERY_THROW );
+
+	if ( xNameAccess->hasByName( sName ) )
+	{
+		uno::Reference< sheet::XNamedRange > xNamed( xNameAccess->getByName( sName ), uno::UNO_QUERY_THROW );
+		sAddress = xNamed->getContent();
+		// As the address comes from OOO, the addressing
+		// style is may not be XL_A1
+		eConv = pDocSh->GetDocument()->GetAddressConvention();
+	}	
+	ScRange refRange;	
+	ScUnoConversion::FillScRange( refRange, pAddr );
+	ScRangeList aCellRanges;
+	USHORT nFlags = 0;
+	if ( !getCellRangesForAddress( nFlags, sAddress, pDocSh, aCellRanges, eConv ) )
+		throw uno::RuntimeException();
+
+	bool bTabFromReferrer = !( nFlags & SCA_TAB_3D );
+
+	for ( ScRange* pRange = aCellRanges.First() ; pRange; pRange = aCellRanges.Next() )
+	{
+		pRange->aStart.SetCol( refRange.aStart.Col() + pRange->aStart.Col() );
+		pRange->aStart.SetRow( refRange.aStart.Row() + pRange->aStart.Row() );
+                pRange->aStart.SetTab( bTabFromReferrer ? refRange.aStart.Tab()  : pRange->aStart.Tab() );
+		pRange->aEnd.SetCol( refRange.aStart.Col() + pRange->aEnd.Col() );
+		pRange->aEnd.SetRow( refRange.aStart.Row() + pRange->aEnd.Row() );
+                pRange->aEnd.SetTab( bTabFromReferrer ? refRange.aEnd.Tab()  : pRange->aEnd.Tab() );
+	}
+
+	// Single range
+	if ( aCellRanges.First() == aCellRanges.Last() )
+	{
+		uno::Reference< table::XCellRange > xRange( new ScCellRangeObj( pDocSh, *aCellRanges.First() ) );
+		return new ScVbaRange( xContext, xRange );
+	}
+	uno::Reference< sheet::XSheetCellRangeContainer > xRanges( new ScCellRangesObj( pDocSh, aCellRanges ) );
+ 	
+	return new ScVbaRange( xContext, xRanges );
+	
+}
+
+uno::Reference< vba::XCollection >
+lcl_setupBorders( const uno::Reference<uno::XComponentContext>& xContext,  uno::Reference< table::XCellRange >& xRange  ) throw( uno::RuntimeException )
+{
+	ScDocument* pDoc = getDocumentFromRange(xRange);
+	if ( !pDoc )
+		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Failed to access document from shell" ) ), uno::Reference< uno::XInterface >() );
+	ScVbaPalette aPalette( pDoc->GetDocumentShell() );
+ 	uno::Reference< vba::XCollection > borders( new ScVbaBorders( xContext, xRange, aPalette ) );
+	return borders;
+}
+
+ScVbaRange::ScVbaRange( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< table::XCellRange >& xRange, sal_Bool bIsRows, sal_Bool bIsColumns ) throw( lang::IllegalArgumentException )
+: mxRange( xRange ),
+                m_xContext(xContext),
+                mbIsRows( bIsRows ),
+                mbIsColumns( bIsColumns )
+{
+	if  ( !xContext.is() )
+		throw lang::IllegalArgumentException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "context is not set " ) ), uno::Reference< uno::XInterface >() , 1 );
+	if  ( !xRange.is() )
+		throw lang::IllegalArgumentException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "range is not set " ) ), uno::Reference< uno::XInterface >() , 1 );
+
+	uno::Reference< container::XIndexAccess > xIndex( new SingleRangeIndexAccess( m_xContext, xRange ) );
+	m_Areas = new ScVbaRangeAreas( m_xContext, xIndex );
+	
+	m_Borders = lcl_setupBorders( m_xContext, mxRange );
+
+}
+
+ScVbaRange::ScVbaRange( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< sheet::XSheetCellRangeContainer >& xRanges,  sal_Bool bIsRows, sal_Bool bIsColumns  ) throw ( lang::IllegalArgumentException )
+:m_xContext(xContext), mxRanges( xRanges ),mbIsRows( bIsRows ), mbIsColumns( bIsColumns )
+
+{
+	uno::Reference< container::XIndexAccess >  xIndex( mxRanges, uno::UNO_QUERY_THROW );
+	m_Areas	 = new ScVbaRangeAreas( m_xContext, xIndex );
+
+	// Some methods functions seem to operate on the first range defined
+	// but I don't want to enable the line below right now, I'd prefer the 
+	// Selection stuff to be non functional and enable it method by method
+	//m_xRange.set( mxRanges->getByIndex( 0 ); 
+	uno::Reference< table::XCellRange > xRange( mxRanges->getByIndex(0), uno::UNO_QUERY_THROW );
+	m_Borders = lcl_setupBorders( m_xContext, xRange );
+}
+
+ScVbaRange::~ScVbaRange()
+{
+}
+
+uno::Reference< script::XTypeConverter >
+ScVbaRange::getTypeConverter() throw (uno::RuntimeException)
+{
+	static uno::Reference< script::XTypeConverter > xTypeConv( m_xContext->getServiceManager()->createInstanceWithContext( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.script.Converter") ), m_xContext ), uno::UNO_QUERY_THROW );
+	return xTypeConv;
+}
+
+void
+ScVbaRange::visitArray( ArrayVisitor& visitor )
+{
+	uno::Reference< table::XColumnRowRange > xColumnRowRange(mxRange, uno::UNO_QUERY_THROW );
+	sal_Int32 nRowCount = xColumnRowRange->getRows()->getCount();
+	sal_Int32 nColCount = xColumnRowRange->getColumns()->getCount();
+	for ( sal_Int32 i=0; i<nRowCount; ++i )
+	{
+		for ( sal_Int32 j=0; j<nColCount; ++j )
+		{
+			uno::Reference< table::XCell > xCell( mxRange->getCellByPosition( j, i ), uno::UNO_QUERY_THROW );
+
+			visitor.visitNode( i, j, xCell );
+		}
+	}
+}
+
+
+
+uno::Any 
+ScVbaRange::getValue( ValueGetter& valueGetter) throw (uno::RuntimeException)
+{
+	uno::Reference< table::XColumnRowRange > xColumnRowRange(mxRange, uno::UNO_QUERY_THROW );
+	// single cell range
+	if ( isSingleCellRange() )
+	{
+		visitArray( valueGetter );
+		return valueGetter.getValue();
+	}
+	sal_Int32 nRowCount = xColumnRowRange->getRows()->getCount();
+	sal_Int32 nColCount = xColumnRowRange->getColumns()->getCount();
+	// multi cell range ( return array )
+	Dim2ArrayValueGetter arrayGetter( nRowCount, nColCount, valueGetter );
+	visitArray( arrayGetter );
+	return uno::makeAny( script::ArrayWrapper( sal_False, arrayGetter.getValue() ) );
+}
+
+uno::Any SAL_CALL
+ScVbaRange::getValue() throw (uno::RuntimeException)
+{
+	// #TODO code within the test below "if ( m_Areas.... " can be removed
+	// Test is performed only because m_xRange is NOT set to be
+	// the first range in m_Areas ( to force failure while
+	// the implementations for each method are being updated )
+	if ( m_Areas->getCount() > 1 )
+	{
+		uno::Reference< excel::XRange > xRange( getArea( 0 ), uno::UNO_QUERY_THROW );
+		return xRange->getValue();
+	}
+
+	CellValueGetter valueGetter;
+	return getValue( valueGetter );
+
+}
+
+
+void 
+ScVbaRange::setValue(  const uno::Any  &aValue,  ValueSetter& valueSetter ) throw (uno::RuntimeException)
+{
+	uno::TypeClass aClass = aValue.getValueTypeClass();
+	if ( aClass == uno::TypeClass_SEQUENCE )
+	{
+		uno::Reference< script::XTypeConverter > xConverter = getTypeConverter();
+		uno::Any aConverted;
+		try
+		{
+			// test for single dimension, could do 
+			// with a better test than this	
+			if ( aValue.getValueTypeName().indexOf('[') ==  aValue.getValueTypeName().lastIndexOf('[') )
+			{
+				aConverted = xConverter->convertTo( aValue, getCppuType((uno::Sequence< uno::Any >*)0) );
+				Dim1ArrayValueSetter setter( aConverted, valueSetter );
+				visitArray( setter );
+			}
+			else
+			{
+				aConverted = xConverter->convertTo( aValue, getCppuType((uno::Sequence< uno::Sequence< uno::Any > >*)0) );
+				Dim2ArrayValueSetter setter( aConverted, valueSetter );
+				visitArray( setter );
+			}
+		}
+		catch ( uno::Exception& e )
+		{
+			OSL_TRACE("Bahhh, caught exception %s", 
+				rtl::OUStringToOString( e.Message,
+					RTL_TEXTENCODING_UTF8 ).getStr() );
+		}
+	}
+	else
+	{
+		visitArray( valueSetter );
+	}
+}
+
+void SAL_CALL
+ScVbaRange::setValue( const uno::Any  &aValue ) throw (uno::RuntimeException)
+{
+	// If this is a multiple selection apply setValue over all areas
+	if ( m_Areas->getCount() > 1 )
+	{
+		AreasVisitor aVisitor( m_Areas );
+		RangeValueProcessor valueProcessor( aValue );	
+		aVisitor.visit( valueProcessor );
+		return;
+	}	
+	CellValueSetter valueSetter( aValue );
+	setValue( aValue, valueSetter );
+}
+
+void
+ScVbaRange::Clear() throw (uno::RuntimeException)
+{
+	sal_Int32 nFlags = sheet::CellFlags::VALUE | sheet::CellFlags::STRING | sheet::CellFlags::HARDATTR | sheet::CellFlags::FORMATTED | sheet::CellFlags::EDITATTR | sheet::CellFlags::FORMULA;
+	ClearContents( nFlags );
+}
+
+//helper ClearContent
+void
+ScVbaRange::ClearContents( sal_Int32 nFlags ) throw (uno::RuntimeException)
+{
+	// #TODO code within the test below "if ( m_Areas.... " can be removed
+	// Test is performed only because m_xRange is NOT set to be
+	// the first range in m_Areas ( to force failure while
+	// the implementations for each method are being updated )
+	if ( m_Areas->getCount() > 1 )
+	{
+		sal_Int32 nItems = m_Areas->getCount();
+		for ( sal_Int32 index=1; index <= nItems; ++index )
+		{
+			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index) ), uno::UNO_QUERY_THROW );
+			ScVbaRange* pRange = dynamic_cast< ScVbaRange* >( xRange.get() ); 
+			if ( pRange )
+				pRange->ClearContents( nFlags );	
+		}
+		return;
+	}
+
+
+	uno::Reference< sheet::XSheetOperation > xSheetOperation(mxRange, uno::UNO_QUERY_THROW);
+	xSheetOperation->clearContents( nFlags );
+}
+void
+ScVbaRange::ClearComments() throw (uno::RuntimeException)
+{
+	ClearContents( sheet::CellFlags::ANNOTATION );
+}
+
+void
+ScVbaRange::ClearContents() throw (uno::RuntimeException)
+{
+	sal_Int32 nClearFlags = ( sheet::CellFlags::VALUE |
+		sheet::CellFlags::STRING |  sheet::CellFlags::DATETIME | 
+		sheet::CellFlags::FORMULA );
+	ClearContents( nClearFlags );
+}
+
+void
+ScVbaRange::ClearFormats() throw (uno::RuntimeException)
+{
+	//FIXME: need to check if we need to combine sheet::CellFlags::FORMATTED
+	sal_Int32 nClearFlags = sheet::CellFlags::HARDATTR | sheet::CellFlags::FORMATTED | sheet::CellFlags::EDITATTR;
+	ClearContents( nClearFlags );
+}
+
+void
+ScVbaRange::setFormulaValue( const uno::Any& rFormula, ScAddress::Convention eConv ) throw (uno::RuntimeException)
+{
+	// If this is a multiple selection apply setFormula over all areas
+	if ( m_Areas->getCount() > 1 )
+	{
+		AreasVisitor aVisitor( m_Areas );
+		RangeFormulaProcessor valueProcessor( rFormula );	
+		aVisitor.visit( valueProcessor );
+		return;
+	}	
+	CellFormulaValueSetter formulaValueSetter( rFormula, getDocumentFromRange( mxRange ), eConv );
+	setValue( rFormula, formulaValueSetter );
+}
+
+uno::Any 
+ScVbaRange::getFormulaValue( ScAddress::Convention eConv) throw (uno::RuntimeException)
+{
+	// #TODO code within the test below "if ( m_Areas.... " can be removed
+	// Test is performed only because m_xRange is NOT set to be
+	// the first range in m_Areas ( to force failure while
+	// the implementations for each method are being updated )
+	if ( m_Areas->getCount() > 1 )
+	{
+		uno::Reference< excel::XRange > xRange( getArea( 0 ), uno::UNO_QUERY_THROW );
+		return xRange->getFormula();
+	}
+	CellFormulaValueGetter valueGetter( getDocumentFromRange( mxRange ), eConv );
+	return getValue( valueGetter );
+		
+}
+
+void
+ScVbaRange::setFormula(const uno::Any &rFormula ) throw (uno::RuntimeException)
+{
+	// #FIXME converting "=$a$1" e.g. CONV_XL_A1 -> CONV_OOO                        	// results in "=$a$1:a1", temporalily disable conversion
+	//setFormulaValue( rFormula, ScAddress::CONV_XL_A1 );;
+	setFormulaValue( rFormula, ScAddress::CONV_OOO );;
+}
+
+uno::Any
+ScVbaRange::getFormulaR1C1() throw (::com::sun::star::uno::RuntimeException)
+{
+	return getFormulaValue( ScAddress::CONV_XL_R1C1 );
+}
+
+void
+ScVbaRange::setFormulaR1C1(const uno::Any& rFormula ) throw (uno::RuntimeException)
+{
+	setFormulaValue( rFormula, ScAddress::CONV_XL_R1C1 );
+}
+
+uno::Any
+ScVbaRange::getFormula() throw (::com::sun::star::uno::RuntimeException)
+{
+	return getFormulaValue( ScAddress::CONV_XL_A1 );
+}
+
+double 
+ScVbaRange::getCount() throw (uno::RuntimeException)
+{
+	// If this is a multiple selection apply setValue over all areas
+	if ( m_Areas->getCount() > 1 )
+	{
+		AreasVisitor aVisitor( m_Areas );
+		RangeCountProcessor valueProcessor;
+		aVisitor.visit( valueProcessor );
+		return valueProcessor.value();
+	}	
+	double rowCount, colCount;
+	uno::Reference< table::XColumnRowRange > xColumnRowRange(mxRange, uno::UNO_QUERY_THROW );
+	rowCount = xColumnRowRange->getRows()->getCount();
+	colCount = xColumnRowRange->getColumns()->getCount();
+	if( IsRows() )
+		return rowCount;	
+	if( IsColumns() )
+		return colCount;
+	return rowCount * colCount;
+}
+
+sal_Int32 
+ScVbaRange::getRow() throw (uno::RuntimeException)
+{
+	// #TODO code within the test below "if ( m_Areas.... " can be removed
+	// Test is performed only because m_xRange is NOT set to be
+	// the first range in m_Areas ( to force failure while
+	// the implementations for each method are being updated )
+	if ( m_Areas->getCount() > 1 )
+	{
+		uno::Reference< excel::XRange > xRange( getArea( 0 ), uno::UNO_QUERY_THROW );
+		return xRange->getRow();
+	}
+	uno::Reference< sheet::XCellAddressable > xCellAddressable(mxRange->getCellByPosition(0, 0), uno::UNO_QUERY_THROW );
+	return xCellAddressable->getCellAddress().Row + 1; // Zero value indexing 
+}	
+		
+sal_Int32 
+ScVbaRange::getColumn() throw (uno::RuntimeException)
+{
+	// #TODO code within the test below "if ( m_Areas.... " can be removed
+	// Test is performed only because m_xRange is NOT set to be
+	// the first range in m_Areas ( to force failure while
+	// the implementations for each method are being updated )
+	if ( m_Areas->getCount() > 1 )
+	{
+		uno::Reference< excel::XRange > xRange( getArea( 0 ), uno::UNO_QUERY_THROW );
+		return xRange->getColumn();
+	}
+	uno::Reference< sheet::XCellAddressable > xCellAddressable(mxRange->getCellByPosition(0, 0), uno::UNO_QUERY_THROW );
+	return xCellAddressable->getCellAddress().Column + 1; // Zero value indexing
+}
+
+uno::Any
+ScVbaRange::HasFormula() throw (uno::RuntimeException)
+{
+	if ( m_Areas->getCount() > 1 )
+	{
+		sal_Int32 nItems = m_Areas->getCount();
+		uno::Any aResult = aNULL();
+		for ( sal_Int32 index=1; index <= nItems; ++index )
+		{
+			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index) ), uno::UNO_QUERY_THROW );
+			// if the HasFormula for any area is different to another
+			// return null
+			if ( index > 1 )
+				if ( aResult != xRange->HasFormula() )
+					return aNULL();
+			aResult = xRange->HasFormula();	
+			if ( aNULL() == aResult ) 
+				return aNULL();
+		}
+		return aResult;
+	}
+	uno::Reference< uno::XInterface > xIf( mxRange, uno::UNO_QUERY_THROW );
+	ScCellRangesBase* pThisRanges = dynamic_cast< ScCellRangesBase * > ( xIf.get() );
+	if ( pThisRanges )
+	{
+		uno::Reference<uno::XInterface>  xRanges( pThisRanges->queryFormulaCells( ( sheet::FormulaResult::ERROR | sheet::FormulaResult::VALUE |  sheet::FormulaResult::STRING ) ), uno::UNO_QUERY_THROW );
+		ScCellRangesBase* pFormulaRanges = dynamic_cast< ScCellRangesBase * > ( xRanges.get() );
+		// check if there are no formula cell, return false
+		if ( pFormulaRanges->GetRangeList().Count() == 0 ) 
+			return uno::makeAny(sal_False);
+		
+		// chech if there are holes (where some cells are not formulas)
+		// or returned range is not equal to this range	 
+		if ( ( pFormulaRanges->GetRangeList().Count() > 1 ) 
+		|| ( pFormulaRanges->GetRangeList().GetObject(0)->aStart != pThisRanges->GetRangeList().GetObject(0)->aStart ) 
+		|| ( pFormulaRanges->GetRangeList().GetObject(0)->aEnd != pThisRanges->GetRangeList().GetObject(0)->aEnd ) )
+			return aNULL(); // should return aNULL;
+	}
+	return uno::makeAny( sal_True );
+}
+void
+ScVbaRange::fillSeries( sheet::FillDirection nFillDirection, sheet::FillMode nFillMode, sheet::FillDateMode nFillDateMode, double fStep, double fEndValue ) throw( uno::RuntimeException )
+{
+	if ( m_Areas->getCount() > 1 )
+	{
+		// Multi-Area Range
+		uno::Reference< vba::XCollection > xCollection( m_Areas, uno::UNO_QUERY_THROW );
+		for ( sal_Int32 index = 1; index <= xCollection->getCount(); ++index )
+		{
+			uno::Reference< excel::XRange > xRange( xCollection->Item( uno::makeAny( index ) ), uno::UNO_QUERY_THROW );
+			ScVbaRange* pThisRange = dynamic_cast< ScVbaRange* >( xRange.get() );
+			pThisRange->fillSeries( nFillDirection, nFillMode, nFillDateMode, fStep, fEndValue );
+				
+		}
+		return;	
+	}
+	
+	uno::Reference< sheet::XCellSeries > xCellSeries(mxRange, uno::UNO_QUERY_THROW );
+	xCellSeries->fillSeries( nFillDirection, nFillMode, nFillDateMode, fStep, fEndValue );
+}
+
+void 
+ScVbaRange::FillLeft() throw (uno::RuntimeException)
+{
+	fillSeries(sheet::FillDirection_TO_LEFT, 
+		sheet::FillMode_SIMPLE, sheet::FillDateMode_FILL_DATE_DAY, 0, 0x7FFFFFFF);
+}
+
+void 
+ScVbaRange::FillRight() throw (uno::RuntimeException)
+{
+	fillSeries(sheet::FillDirection_TO_RIGHT, 
+		sheet::FillMode_SIMPLE, sheet::FillDateMode_FILL_DATE_DAY, 0, 0x7FFFFFFF);
+}
+
+void 
+ScVbaRange::FillUp() throw (uno::RuntimeException)
+{
+	fillSeries(sheet::FillDirection_TO_TOP, 
+		sheet::FillMode_SIMPLE, sheet::FillDateMode_FILL_DATE_DAY, 0, 0x7FFFFFFF);
+}
+
+void 
+ScVbaRange::FillDown() throw (uno::RuntimeException)
+{
+	fillSeries(sheet::FillDirection_TO_BOTTOM, 
+		sheet::FillMode_SIMPLE, sheet::FillDateMode_FILL_DATE_DAY, 0, 0x7FFFFFFF);
+}
+
+::rtl::OUString
+ScVbaRange::getText() throw (uno::RuntimeException)
+{
+	// #TODO code within the test below "if ( m_Areas.... " can be removed
+	// Test is performed only because m_xRange is NOT set to be
+	// the first range in m_Areas ( to force failure while
+	// the implementations for each method are being updated )
+	if ( m_Areas->getCount() > 1 )
+	{
+		uno::Reference< excel::XRange > xRange( getArea( 0 ), uno::UNO_QUERY_THROW );
+		return xRange->getText();
+	}
+	uno::Reference< text::XTextRange > xTextRange(mxRange->getCellByPosition(0,0), uno::UNO_QUERY_THROW );
+	return xTextRange->getString();
+}
+
+uno::Reference< excel::XRange >
+ScVbaRange::Offset( const ::uno::Any &nRowOff, const uno::Any &nColOff ) throw (uno::RuntimeException)
+{
+	SCROW nRowOffset = 0;
+	SCCOL nColOffset = 0;
+	sal_Bool bIsRowOffset = ( nRowOff >>= nRowOffset );
+	sal_Bool bIsColumnOffset = ( nColOff >>= nColOffset );
+	ScCellRangesBase* pUnoRangesBase = getCellRangesBase();
+
+	ScRangeList aCellRanges = pUnoRangesBase->GetRangeList();
+	
+
+	for ( ScRange* pRange = aCellRanges.First() ; pRange; pRange = aCellRanges.Next() )
+	{
+		if ( bIsColumnOffset )
+		{
+			pRange->aStart.SetCol( pRange->aStart.Col() + nColOffset );
+			pRange->aEnd.SetCol( pRange->aEnd.Col() + nColOffset );
+		}
+		if ( bIsRowOffset )
+		{
+			pRange->aStart.SetRow( pRange->aStart.Row() + nRowOffset );
+			pRange->aEnd.SetRow( pRange->aEnd.Row() + nRowOffset );
+		}
+	}
+
+	if ( aCellRanges.Count() > 1 ) // Multi-Area
+	{
+		uno::Reference< sheet::XSheetCellRangeContainer > xRanges( new ScCellRangesObj( pUnoRangesBase->GetDocShell(), aCellRanges ) );
+		
+		return uno::Reference< excel::XRange >( new ScVbaRange( m_xContext, xRanges ) );
+	}
+	// normal range
+	uno::Reference< table::XCellRange > xRange( new ScCellRangeObj( pUnoRangesBase->GetDocShell(), *aCellRanges.First() ) );
+	return new ScVbaRange( m_xContext, xRange  );
+}
+
+uno::Reference< excel::XRange >
+ScVbaRange::CurrentRegion() throw (uno::RuntimeException)
+{
+	// #TODO code within the test below "if ( m_Areas.... " can be removed
+	// Test is performed only because m_xRange is NOT set to be
+	// the first range in m_Areas ( to force failure while
+	// the implementations for each method are being updated )
+	if ( m_Areas->getCount() > 1 )
+	{
+		uno::Reference< excel::XRange > xRange( getArea( 0 ), uno::UNO_QUERY_THROW );
+		return xRange->CurrentRegion();
+	}
+	
+	RangeHelper helper( mxRange );
+	uno::Reference< sheet::XSheetCellCursor > xSheetCellCursor = 
+		helper.getSheetCellCursor();
+	xSheetCellCursor->collapseToCurrentRegion();
+	uno::Reference< sheet::XCellRangeAddressable > xCellRangeAddressable(xSheetCellCursor, uno::UNO_QUERY_THROW);
+	return RangeHelper::createRangeFromRange( m_xContext, helper.getCellRangeFromSheet(), xCellRangeAddressable );	
+}
+
+uno::Reference< excel::XRange >
+ScVbaRange::CurrentArray() throw (uno::RuntimeException)
+{
+	// #TODO code within the test below "if ( m_Areas.... " can be removed
+	// Test is performed only because m_xRange is NOT set to be
+	// the first range in m_Areas ( to force failure while
+	// the implementations for each method are being updated )
+	if ( m_Areas->getCount() > 1 )
+	{
+		uno::Reference< excel::XRange > xRange( getArea( 0 ), uno::UNO_QUERY_THROW );
+		return xRange->CurrentArray();
+	}
+	RangeHelper helper( mxRange );
+	uno::Reference< sheet::XSheetCellCursor > xSheetCellCursor = 
+		helper.getSheetCellCursor();
+	xSheetCellCursor->collapseToCurrentArray();
+	uno::Reference< sheet::XCellRangeAddressable > xCellRangeAddressable(xSheetCellCursor, uno::UNO_QUERY_THROW);
+	return RangeHelper::createRangeFromRange( m_xContext, helper.getCellRangeFromSheet(), xCellRangeAddressable );	
+}
+
+uno::Any
+ScVbaRange::getFormulaArray() throw (uno::RuntimeException)
+{
+	// #TODO code within the test below "if ( m_Areas.... " can be removed
+	// Test is performed only because m_xRange is NOT set to be
+	// the first range in m_Areas ( to force failure while
+	// the implementations for each method are being updated )
+	if ( m_Areas->getCount() > 1 )
+	{
+		uno::Reference< excel::XRange > xRange( getArea( 0 ), uno::UNO_QUERY_THROW );
+		return xRange->getFormulaArray();
+	}
+	
+	uno::Reference< sheet::XCellRangeFormula> xCellRangeFormula( mxRange, uno::UNO_QUERY_THROW );
+	uno::Reference< script::XTypeConverter > xConverter = getTypeConverter();
+	uno::Any aMatrix;
+	aMatrix = xConverter->convertTo( uno::makeAny( xCellRangeFormula->getFormulaArray() ) , getCppuType((uno::Sequence< uno::Sequence< uno::Any > >*)0)  ) ;
+	return aMatrix;
+}
+
+void 
+ScVbaRange::setFormulaArray(const uno::Any& rFormula) throw (uno::RuntimeException)
+{
+	// #TODO code within the test below "if ( m_Areas.... " can be removed
+	// Test is performed only because m_xRange is NOT set to be
+	// the first range in m_Areas ( to force failure while
+	// the implementations for each method are being updated )
+	if ( m_Areas->getCount() > 1 )
+	{
+		uno::Reference< excel::XRange > xRange( getArea( 0 ), uno::UNO_QUERY_THROW );
+		return xRange->setFormulaArray( rFormula );
+	}
+	// #TODO need to distinguish between getFormula and getFormulaArray e.g. (R1C1)
+	// but for the moment its just easier to treat them the same for setting
+
+	setFormula( rFormula );
+}
+
+::rtl::OUString
+ScVbaRange::Characters(const uno::Any& Start, const uno::Any& Length) throw (uno::RuntimeException)
+{
+	// #TODO code within the test below "if ( m_Areas.... " can be removed
+	// Test is performed only because m_xRange is NOT set to be
+	// the first range in m_Areas ( to force failure while
+	// the implementations for each method are being updated )
+	if ( m_Areas->getCount() > 1 )
+	{
+		uno::Reference< excel::XRange > xRange( getArea( 0 ), uno::UNO_QUERY_THROW );
+		return xRange->Characters( Start, Length );
+	}
+
+	long nIndex, nCount;
+	::rtl::OUString rString;
+	uno::Reference< text::XTextRange > xTextRange(mxRange, ::uno::UNO_QUERY_THROW );
+	rString = xTextRange->getString();
+	if( !( Start >>= nIndex ) && !( Length >>= nCount ) )
+		return rString;
+	if(!( Start >>= nIndex ) )
+		nIndex = 1;
+	if(!( Length >>= nCount ) )
+		nIndex = rString.getLength();
+	return rString.copy( --nIndex, nCount ); // Zero value indexing
+}
+
+::rtl::OUString
+ScVbaRange::Address(  const uno::Any& RowAbsolute, const uno::Any& ColumnAbsolute, const uno::Any& ReferenceStyle, const uno::Any& External, const uno::Any& RelativeTo ) throw (uno::RuntimeException)
+{
+	if ( m_Areas->getCount() > 1 )
+	{
+		// Multi-Area Range
+		rtl::OUString sAddress;
+		uno::Reference< vba::XCollection > xCollection( m_Areas, uno::UNO_QUERY_THROW );
+                uno::Any aExternalCopy = External;
+		for ( sal_Int32 index = 1; index <= xCollection->getCount(); ++index )
+		{
+			uno::Reference< excel::XRange > xRange( xCollection->Item( uno::makeAny( index ) ), uno::UNO_QUERY_THROW );
+			if ( index > 1 )
+			{
+				sAddress += rtl::OUString( ',' );
+                                // force external to be false
+                                // only first address should have the
+                                // document and sheet specifications
+                                aExternalCopy = uno::makeAny(sal_False);
+			}
+			sAddress += xRange->Address( RowAbsolute, ColumnAbsolute, ReferenceStyle, aExternalCopy, RelativeTo );
+		}
+		return sAddress;	
+		
+	}
+	ScAddress::Details dDetails( ScAddress::CONV_XL_A1, 0, 0 );
+	if ( ReferenceStyle.hasValue() )
+	{
+		sal_Int32 refStyle = excel::XlReferenceStyle::xlA1;
+		ReferenceStyle >>= refStyle;
+		if ( refStyle == excel::XlReferenceStyle::xlR1C1 )
+			dDetails = ScAddress::Details( ScAddress::CONV_XL_R1C1, 0, 0 );
+	}
+	USHORT nFlags = SCA_VALID;
+	ScDocument* pDoc =  getDocumentFromRange( mxRange );
+	RangeHelper thisRange( mxRange );	
+	table::CellRangeAddress thisAddress = thisRange.getCellRangeAddressable()->getRangeAddress();
+	ScRange aRange( static_cast< SCCOL >( thisAddress.StartColumn ), static_cast< SCROW >( thisAddress.StartRow ), static_cast< SCTAB >( thisAddress.Sheet ), static_cast< SCCOL >( thisAddress.EndColumn ), static_cast< SCROW >( thisAddress.EndRow ), static_cast< SCTAB >( thisAddress.Sheet ) );
+	String sRange;
+	USHORT ROW_ABSOLUTE = ( SCA_ROW_ABSOLUTE | SCA_ROW2_ABSOLUTE );
+	USHORT COL_ABSOLUTE = ( SCA_COL_ABSOLUTE | SCA_COL2_ABSOLUTE );
+	// default
+	nFlags |= ( SCA_TAB_ABSOLUTE | SCA_COL_ABSOLUTE | SCA_ROW_ABSOLUTE | SCA_TAB2_ABSOLUTE | SCA_COL2_ABSOLUTE | SCA_ROW2_ABSOLUTE );
+	if ( RowAbsolute.hasValue() )
+	{
+		sal_Bool bVal = sal_True;
+		RowAbsolute >>= bVal;
+		if ( !bVal )
+			nFlags &= ~ROW_ABSOLUTE;
+	}
+	if ( ColumnAbsolute.hasValue() )
+	{
+		sal_Bool bVal = sal_True;
+		ColumnAbsolute >>= bVal;
+		if ( !bVal )
+			nFlags &= ~COL_ABSOLUTE;
+	}
+	sal_Bool bLocal = sal_False;
+	if ( External.hasValue() )
+	{
+		External >>= bLocal;
+		if (  bLocal )
+			nFlags |= SCA_TAB_3D | SCA_FORCE_DOC;
+	}
+	if ( RelativeTo.hasValue() )
+	{
+		// #TODO should I throw an error if R1C1 is not set?
+		
+		table::CellRangeAddress refAddress = getCellRangeAddress( RelativeTo, thisRange.getSpreadSheet() );
+		dDetails = ScAddress::Details( ScAddress::CONV_XL_R1C1, static_cast< SCROW >( refAddress.StartRow ), static_cast< SCCOL >( refAddress.StartColumn ) );
+	}
+	aRange.Format( sRange,  nFlags, pDoc, dDetails ); 
+	return sRange;
+}
+
+uno::Reference < excel::XFont >
+ScVbaRange::Font() throw (uno::RuntimeException)
+{
+	uno::Reference< beans::XPropertySet > xProps(mxRange, ::uno::UNO_QUERY );
+	ScDocument* pDoc = getDocumentFromRange(mxRange);
+	if ( !pDoc )
+		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Failed to access document from shell" ) ), uno::Reference< uno::XInterface >() );
+
+	ScVbaPalette aPalette( pDoc->GetDocumentShell() );	
+	return uno::Reference< excel::XFont >( new ScVbaFont( aPalette, xProps, getCurrentDataSet() ) );
+}
+                                                                                                                             
+uno::Reference< excel::XRange >
+ScVbaRange::Cells( const uno::Any &nRowIndex, const uno::Any &nColumnIndex ) throw(uno::RuntimeException)
+{
+	// #TODO code within the test below "if ( m_Areas.... " can be removed
+	// Test is performed only because m_xRange is NOT set to be
+	// the first range in m_Areas ( to force failure while
+	// the implementations for each method are being updated )
+	if ( m_Areas->getCount() > 1 )
+	{
+		uno::Reference< excel::XRange > xRange( getArea( 0 ), uno::UNO_QUERY_THROW );
+		return xRange->Cells( nRowIndex, nColumnIndex );
+	}
+
+	sal_Int32 nRow = 0, nColumn = 0;
+	sal_Bool bIsIndex = nRowIndex >>= nRow, bIsColumnIndex = nColumnIndex >>= nColumn;
+                                                                                                                       
+	RangeHelper thisRange( mxRange );
+	table::CellRangeAddress thisRangeAddress =  thisRange.getCellRangeAddressable()->getRangeAddress();
+	uno::Reference< table::XCellRange > xSheetRange = thisRange.getCellRangeFromSheet();
+	if( !bIsIndex && !bIsColumnIndex ) // .Cells
+		return uno::Reference< excel::XRange >( new ScVbaRange( m_xContext, mxRange ) );
+
+	sal_Int32 nIndex = --nRow;
+	if( bIsIndex && !bIsColumnIndex ) // .Cells(n)
+	{
+		uno::Reference< table::XColumnRowRange > xColumnRowRange(mxRange, ::uno::UNO_QUERY_THROW);
+		sal_Int32 nColCount = xColumnRowRange->getColumns()->getCount();
+
+		if ( !nIndex || nIndex < 0 )
+			nRow = 0;
+		else
+			nRow = nIndex / nColCount;
+		nColumn = nIndex % nColCount;
+	}
+	else
+		--nColumn;
+	nRow = nRow + thisRangeAddress.StartRow;
+	nColumn =  nColumn + thisRangeAddress.StartColumn;	
+
+	return uno::Reference< excel::XRange >( new ScVbaRange( m_xContext, xSheetRange->getCellRangeByPosition( nColumn, nRow,                                        nColumn, nRow ) ) );
+}
+
+void
+ScVbaRange::Select() throw (uno::RuntimeException)
+{
+	ScCellRangesBase* pUnoRangesBase = getCellRangesBase();
+	if ( !pUnoRangesBase )
+		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Failed to access underlying uno range object" ) ), uno::Reference< uno::XInterface >()  );
+	ScDocShell* pShell = pUnoRangesBase->GetDocShell();
+	if ( pShell )
+	{
+		uno::Reference< frame::XModel > xModel( getCurrentDocument(), uno::UNO_QUERY_THROW );
+		uno::Reference< view::XSelectionSupplier > xSelection( xModel->getCurrentController(), uno::UNO_QUERY_THROW );
+		if ( mxRanges.is() )
+			xSelection->select( uno::makeAny( mxRanges ) );
+		else
+			xSelection->select( uno::makeAny( mxRange ) );
+	}
+}
+
+bool cellInRange( const table::CellRangeAddress& rAddr, const sal_Int32& nCol, const sal_Int32& nRow )
+{
+	if ( nCol >= rAddr.StartColumn && nCol <= rAddr.EndColumn &&
+		nRow >= rAddr.StartRow && nRow <= rAddr.EndRow )
+		return true;
+	return false;
+}
+
+void setCursor(  const SCCOL& nCol, const SCROW& nRow, bool bInSel = true )
+{
+	ScTabViewShell* pShell = getCurrentBestViewShell();
+	if ( pShell )
+	{
+		if ( bInSel )
+			pShell->SetCursor( nCol, nRow );
+		else
+			pShell->MoveCursorAbs( nCol, nRow, SC_FOLLOW_NONE, FALSE, FALSE, TRUE, FALSE );
+	}
+}
+
+void
+ScVbaRange::Activate() throw (uno::RuntimeException)
+{
+	RangeHelper thisRange( mxRange );
+	uno::Reference< sheet::XCellRangeAddressable > xThisRangeAddress = thisRange.getCellRangeAddressable();
+	table::CellRangeAddress thisRangeAddress = xThisRangeAddress->getRangeAddress();
+	
+	// get current selection
+	uno::Reference< sheet::XCellRangeAddressable > xRange( getCurrentDocument()->getCurrentSelection(), ::uno::UNO_QUERY);
+
+	uno::Reference< sheet::XSheetCellRanges > xRanges( getCurrentDocument()->getCurrentSelection(), ::uno::UNO_QUERY);
+
+	if ( xRanges.is() )
+	{
+		uno::Sequence< table::CellRangeAddress > nAddrs = xRanges->getRangeAddresses();
+		for ( sal_Int32 index = 0; index < nAddrs.getLength(); ++index )
+		{
+			if ( cellInRange( nAddrs[index], thisRangeAddress.StartColumn, thisRangeAddress.StartRow ) )
+			{
+				setCursor( static_cast< SCCOL >( thisRangeAddress.StartColumn ), static_cast< SCROW >( thisRangeAddress.StartRow ) );
+				return;
+			}
+			
+		}
+	}	
+
+	if ( xRange.is() && cellInRange( xRange->getRangeAddress(), thisRangeAddress.StartColumn, thisRangeAddress.StartRow ) )
+		setCursor( static_cast< SCCOL >( thisRangeAddress.StartColumn ), static_cast< SCROW >( thisRangeAddress.StartRow ) );
+	else
+	{
+		// if this range is multi cell select the range other
+		// wise just position the cell at this single range position
+		if ( isSingleCellRange() ) 
+			// This top-leftmost cell of this Range is not in the current
+			// selection so just select this range
+			setCursor( static_cast< SCCOL >( thisRangeAddress.StartColumn ), static_cast< SCROW >( thisRangeAddress.StartRow ), false  );
+		else
+			Select();
+	}
+
+}
+
+uno::Reference< excel::XRange >
+ScVbaRange::Rows(const uno::Any& aIndex ) throw (uno::RuntimeException)
+{
+	// #TODO code within the test below "if ( m_Areas.... " can be removed
+	// Test is performed only because m_xRange is NOT set to be
+	// the first range in m_Areas ( to force failure while
+	// the implementations for each method are being updated )
+	if ( m_Areas->getCount() > 1 )
+	{
+		uno::Reference< excel::XRange > xRange( getArea( 0 ), uno::UNO_QUERY_THROW );
+		return xRange->Rows( aIndex );
+	}
+	
+	sal_Int32 nValue;
+	rtl::OUString sAddress;
+	if( aIndex.hasValue() )
+	{
+		uno::Reference< sheet::XCellRangeAddressable > xAddressable( mxRange, uno::UNO_QUERY );
+		table::CellRangeAddress aAddress = xAddressable->getRangeAddress();
+		if( aIndex >>= nValue )
+		{
+			aAddress.StartRow = --nValue;
+			aAddress.EndRow = nValue;
+		}
+	
+		else if ( aIndex >>= sAddress ) 
+		{
+				ScAddress::Details dDetails( ScAddress::CONV_XL_A1, 0, 0 );
+			ScRange aRange;
+			aRange.ParseRows( sAddress, getDocumentFromRange( mxRange ), dDetails );
+			aAddress.StartRow = aRange.aStart.Row();
+			aAddress.EndRow = aRange.aEnd.Row();
+		}
+		else
+			throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Illegal param" ) ), uno::Reference< uno::XInterface >() );
+
+		return uno::Reference< excel::XRange >( new ScVbaRange( m_xContext, mxRange->getCellRangeByPosition(
+						aAddress.StartColumn, aAddress.StartRow,
+						aAddress.EndColumn, aAddress.EndRow ), true ) 	); 	
+	}
+	// Questionable return, I'm just copying the invalid Any::value path
+	// above. Would seem to me that this is an internal error and 
+	// warrants an exception thrown
+	return uno::Reference< excel::XRange >( new ScVbaRange( m_xContext, mxRange, true ) );
+}	
+
+uno::Reference< excel::XRange >
+ScVbaRange::Columns( const uno::Any& aIndex ) throw (uno::RuntimeException)
+{
+	// #TODO code within the test below "if ( m_Areas.... " can be removed
+	// Test is performed only because m_xRange is NOT set to be
+	// the first range in m_Areas ( to force failure while
+	// the implementations for each method are being updated )
+	if ( m_Areas->getCount() > 1 )
+	{
+		uno::Reference< excel::XRange > xRange( getArea( 0 ), uno::UNO_QUERY_THROW );
+		return xRange->Columns( aIndex );
+	}
+	if ( aIndex.hasValue() )
+	{
+		uno::Reference< excel::XRange > xRange;
+		sal_Int32 nValue;
+		rtl::OUString sAddress;
+		RangeHelper thisRange( mxRange );
+		uno::Reference< sheet::XCellRangeAddressable > xThisRangeAddress = thisRange.getCellRangeAddressable();
+		uno::Reference< table::XCellRange > xRanges = thisRange.getCellRangeFromSheet();		
+		table::CellRangeAddress thisRangeAddress = xThisRangeAddress->getRangeAddress();
+		uno::Reference< table::XCellRange > xReferrer = xRanges->getCellRangeByPosition( thisRangeAddress.StartColumn, thisRangeAddress.StartRow, MAXCOL, thisRangeAddress.EndRow );
+	
+		if ( aIndex >>= nValue )
+		{
+			--nValue;
+			// col value can expand outside this range
+			// rows however cannot
+
+			thisRangeAddress.StartColumn = nValue;	
+			thisRangeAddress.EndColumn = nValue;	
+		}
+		else if ( aIndex >>= sAddress )
+		{
+			ScAddress::Details dDetails( ScAddress::CONV_XL_A1, 0, 0 );
+			ScRange aRange;
+			aRange.ParseCols( sAddress, getDocumentFromRange( mxRange ), dDetails );
+			thisRangeAddress.StartColumn = aRange.aStart.Col();
+			thisRangeAddress.EndColumn = aRange.aEnd.Col();
+		}
+		else
+			throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Illegal param" ) ), uno::Reference< uno::XInterface >() );
+		return uno::Reference< excel::XRange >( new ScVbaRange( m_xContext, xReferrer->getCellRangeByPosition( thisRangeAddress.StartColumn, thisRangeAddress.StartRow, thisRangeAddress.EndColumn, thisRangeAddress.EndRow ), false, true ) );
+	}
+	// otherwise return this object ( e.g for columns property with no
+	// params
+	return uno::Reference< excel::XRange >( new ScVbaRange( m_xContext, mxRange, false, true ) );
+}
+
+void
+ScVbaRange::setMergeCells( sal_Bool bIsMerged ) throw (uno::RuntimeException)
+{
+	uno::Reference< util::XMergeable > xMerge( mxRange, ::uno::UNO_QUERY_THROW );
+	//FIXME need to check whether all the cell contents are retained or lost by popping up a dialog 
+	xMerge->merge( bIsMerged );
+}
+                                                                                                                             
+sal_Bool
+ScVbaRange::getMergeCells() throw (uno::RuntimeException)
+{
+	uno::Reference< util::XMergeable > xMerge( mxRange, ::uno::UNO_QUERY_THROW );
+	return xMerge->getIsMerged();
+}
+                                                                                                                             
+void
+ScVbaRange::Copy(const ::uno::Any& Destination) throw (uno::RuntimeException)
+{
+	if ( m_Areas->getCount() > 1 )
+		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("That command cannot be used on multiple selections" ) ), uno::Reference< uno::XInterface >() );
+	if ( Destination.hasValue() )
+	{
+		uno::Reference< excel::XRange > xRange( Destination, uno::UNO_QUERY_THROW );
+		uno::Any aRange = xRange->getCellRange();
+		uno::Reference< table::XCellRange > xCellRange;
+		aRange >>= xCellRange;
+		uno::Reference< sheet::XSheetCellRange > xSheetCellRange(xCellRange, ::uno::UNO_QUERY_THROW);
+		uno::Reference< sheet::XSpreadsheet > xSheet = xSheetCellRange->getSpreadsheet();
+		uno::Reference< table::XCellRange > xDest( xSheet, uno::UNO_QUERY_THROW );
+		uno::Reference< sheet::XCellRangeMovement > xMover( xSheet, uno::UNO_QUERY_THROW);
+		uno::Reference< sheet::XCellAddressable > xDestination( xDest->getCellByPosition(
+												xRange->getColumn()-1,xRange->getRow()-1), uno::UNO_QUERY_THROW );
+		uno::Reference< sheet::XCellRangeAddressable > xSource( mxRange, uno::UNO_QUERY);
+		xMover->copyRange( xDestination->getCellAddress(), xSource->getRangeAddress() );
+	}
+	else
+	{
+		Select();
+		implnCopy();
+	}
+}
+
+void
+ScVbaRange::Cut(const ::uno::Any& Destination) throw (uno::RuntimeException)
+{
+	if ( m_Areas->getCount() > 1 )
+		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("That command cannot be used on multiple selections" ) ), uno::Reference< uno::XInterface >() );
+	if (Destination.hasValue())
+	{
+		uno::Reference< excel::XRange > xRange( Destination, uno::UNO_QUERY_THROW );
+		uno::Reference< table::XCellRange > xCellRange( xRange->getCellRange(), uno::UNO_QUERY_THROW );
+		uno::Reference< sheet::XSheetCellRange > xSheetCellRange(xCellRange, ::uno::UNO_QUERY_THROW );
+		uno::Reference< sheet::XSpreadsheet > xSheet = xSheetCellRange->getSpreadsheet();
+		uno::Reference< table::XCellRange > xDest( xSheet, uno::UNO_QUERY_THROW );
+		uno::Reference< sheet::XCellRangeMovement > xMover( xSheet, uno::UNO_QUERY_THROW);
+		uno::Reference< sheet::XCellAddressable > xDestination( xDest->getCellByPosition(
+												xRange->getColumn()-1,xRange->getRow()-1), uno::UNO_QUERY);
+		uno::Reference< sheet::XCellRangeAddressable > xSource( mxRange, uno::UNO_QUERY);
+		xMover->moveRange( xDestination->getCellAddress(), xSource->getRangeAddress() );
+	}
+	{
+		Select();
+		implnCut();
+	}
+}
+                                                                                                                             
+void
+ScVbaRange::setNumberFormat( const uno::Any& aFormat ) throw (uno::RuntimeException)
+{
+	rtl::OUString sFormat;
+	aFormat >>= sFormat;
+	if ( m_Areas->getCount() > 1 )
+	{
+		sal_Int32 nItems = m_Areas->getCount();
+		for ( sal_Int32 index=1; index <= nItems; ++index )
+		{
+			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index) ), uno::UNO_QUERY_THROW );
+			xRange->setNumberFormat( aFormat );	
+		}
+		return;
+	}
+	NumFormatHelper numFormat( mxRange );
+	numFormat.setNumberFormat( sFormat );
+}
+                                                                                                                             
+uno::Any
+ScVbaRange::getNumberFormat() throw (uno::RuntimeException)
+{
+
+	if ( m_Areas->getCount() > 1 )
+	{
+		sal_Int32 nItems = m_Areas->getCount();
+		uno::Any aResult = aNULL();
+		for ( sal_Int32 index=1; index <= nItems; ++index )
+		{
+			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index) ), uno::UNO_QUERY_THROW );
+			// if the numberformat of one area is different to another
+			// return null
+			if ( index > 1 )
+				if ( aResult != xRange->getNumberFormat() )
+					return aNULL();
+			aResult = xRange->getNumberFormat();	
+			if ( aNULL() == aResult ) 
+				return aNULL();
+		}
+		return aResult;
+	}
+	NumFormatHelper numFormat( mxRange );
+	rtl::OUString sFormat = numFormat.getNumberFormatString();
+	if ( sFormat.getLength() > 0 )
+		return uno::makeAny( sFormat );
+	return aNULL();
+}
+
+uno::Reference< excel::XRange >
+ScVbaRange::Resize( const uno::Any &RowSize, const uno::Any &ColumnSize ) throw (uno::RuntimeException)
+{
+	long nRowSize, nColumnSize;
+	sal_Bool bIsRowChanged = ( RowSize >>= nRowSize ), bIsColumnChanged = ( ColumnSize >>= nColumnSize );
+	uno::Reference< table::XColumnRowRange > xColumnRowRange(mxRange, ::uno::UNO_QUERY_THROW);
+	uno::Reference< sheet::XSheetCellRange > xSheetRange(mxRange, ::uno::UNO_QUERY_THROW);
+	uno::Reference< sheet::XSheetCellCursor > xCursor( xSheetRange->getSpreadsheet()->createCursorByRange(xSheetRange), ::uno::UNO_QUERY_THROW );
+
+	if( !bIsRowChanged )
+		nRowSize = xColumnRowRange->getRows()->getCount();
+	if( !bIsColumnChanged )
+		nColumnSize = xColumnRowRange->getColumns()->getCount();
+
+	xCursor->collapseToSize( nColumnSize, nRowSize );
+	uno::Reference< sheet::XCellRangeAddressable > xCellRangeAddressable(xCursor, ::uno::UNO_QUERY_THROW );
+	uno::Reference< table::XCellRange > xRange( xSheetRange->getSpreadsheet(), ::uno::UNO_QUERY_THROW );
+	return uno::Reference< excel::XRange >( new ScVbaRange( m_xContext,xRange->getCellRangeByPosition(
+										xCellRangeAddressable->getRangeAddress().StartColumn,
+										xCellRangeAddressable->getRangeAddress().StartRow,
+										xCellRangeAddressable->getRangeAddress().EndColumn,
+										xCellRangeAddressable->getRangeAddress().EndRow ) ) );
+}
+                                                                                                                             
+void
+ScVbaRange::setWrapText( const uno::Any& aIsWrapped ) throw (uno::RuntimeException)
+{
+	if ( m_Areas->getCount() > 1 )
+	{
+		sal_Int32 nItems = m_Areas->getCount();
+		uno::Any aResult;
+		for ( sal_Int32 index=1; index <= nItems; ++index )
+		{
+			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index) ), uno::UNO_QUERY_THROW );
+			xRange->setWrapText( aIsWrapped );	
+		}
+		return;
+	}
+
+	uno::Reference< beans::XPropertySet > xProps(mxRange, ::uno::UNO_QUERY_THROW );
+	xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "IsTextWrapped" ) ), aIsWrapped );
+}
+                                                                                                                             
+uno::Any
+ScVbaRange::getWrapText() throw (uno::RuntimeException)
+{
+	if ( m_Areas->getCount() > 1 )
+	{
+		sal_Int32 nItems = m_Areas->getCount();
+		uno::Any aResult;
+		for ( sal_Int32 index=1; index <= nItems; ++index )
+		{
+			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index) ), uno::UNO_QUERY_THROW );
+			if ( index > 1 )
+				if ( aResult != xRange->getWrapText() )
+					return aNULL();
+			aResult = xRange->getWrapText(); 
+		}
+		return aResult;
+	}
+
+	SfxItemSet* pDataSet = getCurrentDataSet();
+	
+	SfxItemState eState = pDataSet->GetItemState( ATTR_LINEBREAK, TRUE, NULL);
+	if ( eState == SFX_ITEM_DONTCARE )
+		return aNULL();
+	
+	uno::Reference< beans::XPropertySet > xProps(mxRange, ::uno::UNO_QUERY_THROW );
+	uno::Any aValue = xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "IsTextWrapped" ) ) );
+	return aValue;
+}
+
+uno::Reference< excel::XInterior > ScVbaRange::Interior( ) throw (uno::RuntimeException)
+{
+	uno::Reference< beans::XPropertySet > xProps( mxRange, uno::UNO_QUERY_THROW );
+        return uno::Reference<excel::XInterior> (new ScVbaInterior ( m_xContext, xProps, getDocumentFromRange( mxRange ) ));
+}                                                                                                                             
+uno::Reference< excel::XRange >
+ScVbaRange::Range( const uno::Any &Cell1, const uno::Any &Cell2 ) throw (uno::RuntimeException)
+{
+    return Range( Cell1, Cell2, false );
+}
+uno::Reference< excel::XRange >
+ScVbaRange::Range( const uno::Any &Cell1, const uno::Any &Cell2, bool bForceUseInpuRangeTab ) throw (uno::RuntimeException)
+
+{
+	RangeHelper thisRange( mxRange );
+	uno::Reference< table::XCellRange > xRanges = thisRange.getCellRangeFromSheet();
+	uno::Reference< sheet::XCellRangeAddressable > xAddressable( xRanges, uno::UNO_QUERY_THROW );
+
+	uno::Reference< table::XCellRange > xReferrer = 
+		xRanges->getCellRangeByPosition( getColumn()-1, getRow()-1, 
+				xAddressable->getRangeAddress().EndColumn, 
+				xAddressable->getRangeAddress().EndRow );
+	// xAddressable now for this range	
+	xAddressable.set( xReferrer, uno::UNO_QUERY_THROW );
+
+	
+	if( !Cell1.hasValue() )
+		throw uno::RuntimeException(
+			rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( " Invalid Argument " ) ),
+			uno::Reference< XInterface >() );
+
+	table::CellRangeAddress resultAddress;
+	table::CellRangeAddress parentRangeAddress = xAddressable->getRangeAddress();
+
+	ScRange aRange;
+	// Cell1 defined only
+	if ( !Cell2.hasValue() )
+	{
+		rtl::OUString sName;
+		Cell1 >>= sName;
+		RangeHelper referRange( xReferrer );		
+		table::CellRangeAddress referAddress = referRange.getCellRangeAddressable()->getRangeAddress();
+		return getRangeForName( m_xContext, sName, getDocShellFromRange( mxRange ), referAddress );
+ 
+	}
+	else
+	{
+		table::CellRangeAddress  cell1, cell2;
+		cell1 = getCellRangeAddress( Cell1, thisRange.getSpreadSheet() ); 	
+		// Cell1 & Cell2 defined
+		// Excel seems to combine the range as the range defined by
+		// the combination of Cell1 & Cell2
+	
+		cell2 = getCellRangeAddress( Cell2, thisRange.getSpreadSheet() ); 	
+
+		resultAddress.StartColumn = ( cell1.StartColumn <  cell2.StartColumn ) ? cell1.StartColumn : cell2.StartColumn;
+		resultAddress.StartRow = ( cell1.StartRow <  cell2.StartRow ) ? cell1.StartRow : cell2.StartRow;
+		resultAddress.EndColumn = ( cell1.EndColumn >  cell2.EndColumn ) ? cell1.EndColumn : cell2.EndColumn;
+		resultAddress.EndRow = ( cell1.EndRow >  cell2.EndRow ) ? cell1.EndRow : cell2.EndRow;
+		if ( bForceUseInpuRangeTab )
+		{
+			// this is a call from Application.Range( x,y )
+			// its possiblefor x or y to specify a different sheet from
+			// the current or active on ( but they must be the same )
+			if ( cell1.Sheet != cell2.Sheet )
+				throw uno::RuntimeException();
+			parentRangeAddress.Sheet = cell1.Sheet;
+		}
+		else
+		{
+			// this is not a call from Application.Range( x,y )
+			// if a different sheet from this range is specified it's
+			// an error
+			if ( parentRangeAddress.Sheet != cell1.Sheet 
+			|| parentRangeAddress.Sheet != cell2.Sheet 
+			)
+				throw uno::RuntimeException();
+
+		}
+		ScUnoConversion::FillScRange( aRange, resultAddress );
+	}
+	ScRange parentAddress;
+	ScUnoConversion::FillScRange( parentAddress, parentRangeAddress);	
+	uno::Reference< table::XCellRange > xCellRange;
+	if ( aRange.aStart.Col() >= 0 && aRange.aStart.Row() >= 0 && aRange.aEnd.Col() >= 0 && aRange.aEnd.Row() >= 0 )
+	{
+		sal_Int32 nStartX = parentAddress.aStart.Col() + aRange.aStart.Col();
+		sal_Int32 nStartY = parentAddress.aStart.Row() + aRange.aStart.Row();
+		sal_Int32 nEndX = parentAddress.aStart.Col() + aRange.aEnd.Col();
+		sal_Int32 nEndY = parentAddress.aStart.Row() + aRange.aEnd.Row();
+
+		if ( nStartX <= nEndX && nEndX <= parentAddress.aEnd.Col() &&
+			 nStartY <= nEndY && nEndY <= parentAddress.aEnd.Row() )
+		{
+			ScRange aNew( (SCCOL)nStartX, (SCROW)nStartY, parentAddress.aStart.Tab(),
+						  (SCCOL)nEndX, (SCROW)nEndY, parentAddress.aEnd.Tab() );
+			xCellRange = new ScCellRangeObj( getDocShellFromRange( mxRange ), aNew );
+		}
+	}
+		
+	return uno::Reference< excel::XRange > ( new ScVbaRange( m_xContext, xCellRange )  );
+
+}
+
+// Allow access to underlying openoffice uno api ( useful for debugging
+// with openoffice basic ) 
+::com::sun::star::uno::Any SAL_CALL
+ScVbaRange::getCellRange(  ) throw (::com::sun::star::uno::RuntimeException)
+{
+	uno::Any aAny;
+	if ( mxRanges.is() )
+		aAny <<= mxRanges;
+	else if ( mxRange.is() )
+		aAny <<= mxRange;
+	return aAny;
+}
+
+static USHORT 
+getPasteFlags (sal_Int32 Paste)
+{
+	USHORT nFlags = IDF_NONE;	
+	switch (Paste) {
+        case excel::XlPasteType::xlPasteComments: 
+		nFlags = IDF_NOTE;break;
+        case excel::XlPasteType::xlPasteFormats: 
+		nFlags = IDF_ATTRIB;break;
+        case excel::XlPasteType::xlPasteFormulas: 
+		nFlags = IDF_FORMULA;break;
+        case excel::XlPasteType::xlPasteFormulasAndNumberFormats : 
+        case excel::XlPasteType::xlPasteValues: 
+		// FOR_UPSTREAM_BUILD
+		//nFlags = ( IDF_VALUE | IDF_DATETIME | IDF_STRING | IDF_SPECIAL_BOOLEAN ); break;
+		nFlags = ( IDF_VALUE | IDF_DATETIME | IDF_STRING ); break;
+        case excel::XlPasteType::xlPasteValuesAndNumberFormats:
+		nFlags = IDF_VALUE | IDF_ATTRIB; break;
+        case excel::XlPasteType::xlPasteColumnWidths:
+        case excel::XlPasteType::xlPasteValidation: 
+		nFlags = IDF_NONE;break;
+	case excel::XlPasteType::xlPasteAll: 
+        case excel::XlPasteType::xlPasteAllExceptBorders: 
+	default:
+		nFlags = IDF_ALL;break;
+	};
+return nFlags;
+}
+
+static USHORT 
+getPasteFormulaBits( sal_Int32 Operation)
+{
+	USHORT nFormulaBits = PASTE_NOFUNC ;
+	switch (Operation)
+	{
+	case excel::XlPasteSpecialOperation::xlPasteSpecialOperationAdd: 
+		nFormulaBits = PASTE_ADD;break;
+	case excel::XlPasteSpecialOperation::xlPasteSpecialOperationSubtract: 
+		nFormulaBits = PASTE_SUB;break;
+	case excel::XlPasteSpecialOperation::xlPasteSpecialOperationMultiply: 
+		nFormulaBits = PASTE_MUL;break;
+	case excel::XlPasteSpecialOperation::xlPasteSpecialOperationDivide:
+		nFormulaBits = PASTE_DIV;break;
+
+	case excel::XlPasteSpecialOperation::xlPasteSpecialOperationNone: 
+	default:
+		nFormulaBits = PASTE_NOFUNC; break;
+	};
+	
+return nFormulaBits;
+}
+void SAL_CALL 
+ScVbaRange::PasteSpecial( const uno::Any& Paste, const uno::Any& Operation, const uno::Any& SkipBlanks, const uno::Any& Transpose ) throw (::com::sun::star::uno::RuntimeException) 
+{
+	if ( m_Areas->getCount() > 1 )
+		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("That command cannot be used on multiple selections" ) ), uno::Reference< uno::XInterface >() );
+	// set up defaults	
+	sal_Int32 nPaste = excel::XlPasteType::xlPasteAll;
+	sal_Int32 nOperation = excel::XlPasteSpecialOperation::xlPasteSpecialOperationNone;
+	sal_Bool bTranspose = sal_False;
+	sal_Bool bSkipBlanks = sal_False;
+
+	if ( Paste.hasValue() )
+		Paste >>= nPaste;
+	if ( Operation.hasValue() )
+		Operation >>= nOperation;
+	if ( SkipBlanks.hasValue() )
+		SkipBlanks >>= bSkipBlanks;
+	if ( Transpose.hasValue() )
+		Transpose >>= bTranspose;
+
+	USHORT nFlags = getPasteFlags(nPaste);
+	USHORT nFormulaBits = getPasteFormulaBits(nOperation);
+	implnPasteSpecial(nFlags,nFormulaBits,bSkipBlanks,bTranspose);
+}
+
+uno::Reference< excel::XRange > 
+ScVbaRange::getEntireColumnOrRow( bool bColumn ) throw (uno::RuntimeException)
+{
+	ScCellRangesBase* pUnoRangesBase = getCellRangesBase();
+	// copy the range list
+	ScRangeList aCellRanges = pUnoRangesBase->GetRangeList(); 
+
+	for ( ScRange* pRange = aCellRanges.First() ; pRange; pRange = aCellRanges.Next() )
+	{
+		if ( bColumn ) 
+		{
+			pRange->aStart.SetRow( 0 );
+			pRange->aEnd.SetRow( MAXROW );
+		}	
+		else
+		{
+			pRange->aStart.SetCol( 0 );
+			pRange->aEnd.SetCol( MAXCOL );
+		}
+	}
+	if ( aCellRanges.Count() > 1 ) // Multi-Area
+	{
+		uno::Reference< sheet::XSheetCellRangeContainer > xRanges( new ScCellRangesObj( pUnoRangesBase->GetDocShell(), aCellRanges ) );
+		
+		return uno::Reference< excel::XRange >( new ScVbaRange( m_xContext, xRanges, !bColumn, bColumn ) );
+	}
+	uno::Reference< table::XCellRange > xRange( new ScCellRangeObj( pUnoRangesBase->GetDocShell(), *aCellRanges.First() ) );
+	return new ScVbaRange( m_xContext, xRange, !bColumn, bColumn  );
+}
+
+uno::Reference< excel::XRange > SAL_CALL 
+ScVbaRange::getEntireRow() throw (uno::RuntimeException)
+{
+	return getEntireColumnOrRow(false);
+}
+
+uno::Reference< excel::XRange > SAL_CALL 
+ScVbaRange::getEntireColumn() throw (uno::RuntimeException)
+{
+	return getEntireColumnOrRow();
+}
+
+uno::Reference< excel::XComment > SAL_CALL 
+ScVbaRange::AddComment( const uno::Any& Text ) throw (uno::RuntimeException)
+{
+	uno::Reference< excel::XComment > xComment( new ScVbaComment( m_xContext, mxRange ) );
+	// if you don't pass a valid text or if there is already a comment
+	// associated with the range then return NULL
+	if ( !xComment->Text( Text, uno::Any(), uno::Any() ).getLength() 
+	||   xComment->Text( uno::Any(), uno::Any(), uno::Any() ).getLength() )
+		return NULL;
+	return xComment;
+}
+
+uno::Reference< excel::XComment > SAL_CALL
+ScVbaRange::getComment() throw (uno::RuntimeException)
+{
+	// intentional behavior to return a null object if no
+	// comment defined
+	uno::Reference< excel::XComment > xComment( new ScVbaComment( m_xContext, mxRange ) );
+	if ( !xComment->Text( uno::Any(), uno::Any(), uno::Any() ).getLength() )
+		return NULL;
+	return xComment;
+	
+}
+
+uno::Reference< beans::XPropertySet >
+getRowOrColumnProps( const uno::Reference< table::XCellRange >& xCellRange, bool bRows ) throw ( uno::RuntimeException )
+{
+	uno::Reference< table::XColumnRowRange > xColRow( xCellRange, uno::UNO_QUERY_THROW );
+	uno::Reference< beans::XPropertySet > xProps;
+	if ( bRows )
+		xProps.set( xColRow->getRows(), uno::UNO_QUERY_THROW );
+	else
+		xProps.set( xColRow->getColumns(), uno::UNO_QUERY_THROW );
+	return xProps;	
+}
+
+uno::Any SAL_CALL 
+ScVbaRange::getHidden() throw (uno::RuntimeException)
+{
+	// if multi-area result is the result of the 
+	// first area
+	if ( m_Areas->getCount() > 1 )
+	{
+		uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(sal_Int32(1)) ), uno::UNO_QUERY_THROW );
+		return xRange->getHidden();	
+	}
+	bool bIsVisible = false;
+	try
+	{
+		uno::Reference< beans::XPropertySet > xProps = getRowOrColumnProps( mxRange, mbIsRows );
+		if ( !( xProps->getPropertyValue( ISVISIBLE ) >>= bIsVisible ) )
+			throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Failed to get IsVisible property")), uno::Reference< uno::XInterface >() );
+	}
+	catch( uno::Exception& e )
+	{
+		throw uno::RuntimeException( e.Message, uno::Reference< uno::XInterface >() );
+	}
+	return uno::makeAny( !bIsVisible ); 
+}
+
+void SAL_CALL 
+ScVbaRange::setHidden( const uno::Any& _hidden ) throw (uno::RuntimeException)
+{
+	if ( m_Areas->getCount() > 1 )
+	{
+		sal_Int32 nItems = m_Areas->getCount();
+		for ( sal_Int32 index=1; index <= nItems; ++index )
+		{
+			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index) ), uno::UNO_QUERY_THROW );
+			xRange->setHidden( _hidden );	
+		}
+		return;
+	}
+
+	sal_Bool bHidden;
+	if ( !(_hidden >>= bHidden) )
+		throw uno::RuntimeException( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Failed to extract param for Hidden property" ) ), uno::Reference< uno::XInterface >() ); 
+
+	try
+	{
+		uno::Reference< beans::XPropertySet > xProps = getRowOrColumnProps( mxRange, mbIsRows );
+		xProps->setPropertyValue( ISVISIBLE, uno::makeAny( !bHidden ) );
+	}
+	catch( uno::Exception& e )
+	{
+		throw uno::RuntimeException( e.Message, uno::Reference< uno::XInterface >() );
+	}	
+}
+
+::sal_Bool SAL_CALL 
+ScVbaRange::Replace( const ::rtl::OUString& What, const ::rtl::OUString& Replacement, const uno::Any& LookAt, const uno::Any& SearchOrder, const uno::Any& MatchCase, const uno::Any& MatchByte, const uno::Any& SearchFormat, const uno::Any& ReplaceFormat  ) throw (uno::RuntimeException)
+{
+	if ( m_Areas->getCount() > 1 )
+	{
+		for ( sal_Int32 index = 1; index <= m_Areas->getCount(); ++index )
+		{
+			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny( index ) ), uno::UNO_QUERY_THROW );
+			xRange->Replace( What, Replacement,  LookAt, SearchOrder, MatchCase, MatchByte, SearchFormat, ReplaceFormat );
+		}
+		return sal_True; // seems to return true always ( or at least I haven't found the trick of 
+	}	
+	// sanity check required params
+	if ( !What.getLength() || !Replacement.getLength() )
+		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Range::Replace, missing params" )) , uno::Reference< uno::XInterface >() );
+
+	// #TODO #FIXME SearchFormat & ReplacesFormat are not processed
+	// What do we do about MatchByte.. we don't seem to support that
+	const SvxSearchItem& globalSearchOptions = ScGlobal::GetSearchItem();
+	SvxSearchItem newOptions( globalSearchOptions );
+
+	sal_Int16 nLook =  globalSearchOptions.GetWordOnly() ?  excel::XlLookAt::xlPart : excel::XlLookAt::xlWhole; 
+	sal_Int16 nSearchOrder = globalSearchOptions.GetRowDirection() ? excel::XlSearchOrder::xlByRows : excel::XlSearchOrder::xlByColumns;
+
+	sal_Bool bMatchCase = sal_False;
+
+	uno::Reference< util::XReplaceable > xReplace( mxRange, uno::UNO_QUERY );
+	if ( xReplace.is() )
+	{
+		uno::Reference< util::XReplaceDescriptor > xDescriptor =
+			xReplace->createReplaceDescriptor();
+		
+		xDescriptor->setSearchString( What); 		
+		xDescriptor->setReplaceString( Replacement); 		
+		if ( LookAt.hasValue() )
+		{
+			// sets SearchWords ( true is Cell match )
+			nLook =  ::comphelper::getINT16( LookAt );
+			sal_Bool bSearchWords = sal_False;
+			if ( nLook == excel::XlLookAt::xlPart )
+				bSearchWords = sal_False;
+			else if ( nLook == excel::XlLookAt::xlWhole )
+				bSearchWords = sal_True;
+			else
+				throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Range::Replace, illegal value for LookAt" )) , uno::Reference< uno::XInterface >() );
+			// set global search props ( affects the find dialog
+			// and of course the defaults for this method
+			newOptions.SetWordOnly( bSearchWords );
+			xDescriptor->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( SC_UNO_SRCHWORDS ) ), uno::makeAny( bSearchWords ) ); 	
+		}
+		// sets SearchByRow ( true for Rows )
+		if ( SearchOrder.hasValue() )
+		{
+			nSearchOrder =  ::comphelper::getINT16( SearchOrder );
+			sal_Bool bSearchByRow = sal_False;
+			if ( nSearchOrder == excel::XlSearchOrder::xlByColumns )
+				bSearchByRow = sal_False;
+			else if ( nSearchOrder == excel::XlSearchOrder::xlByRows )
+				bSearchByRow = sal_True;
+			else
+				throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Range::Replace, illegal value for SearchOrder" )) , uno::Reference< uno::XInterface >() );
+			
+			newOptions.SetRowDirection( bSearchByRow ); 
+			xDescriptor->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( SC_UNO_SRCHBYROW ) ), uno::makeAny( bSearchByRow ) ); 	
+		}			
+		if ( MatchCase.hasValue() )
+		{
+			// SearchCaseSensitive
+			MatchCase >>= bMatchCase;	
+			xDescriptor->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( SC_UNO_SRCHCASE ) ), uno::makeAny( bMatchCase ) ); 	
+		}			
+
+		ScGlobal::SetSearchItem( newOptions );	
+		// ignore MatchByte for the moment, its not supported in
+		// OOo.org afaik
+
+		uno::Reference< util::XSearchDescriptor > xSearch( xDescriptor, uno::UNO_QUERY );
+		xReplace->replaceAll( xSearch );
+	}
+	return sal_True; // always
+}
+
+uno::Reference< table::XCellRange > 
+ScVbaRange::getCellRangeForName(  const rtl::OUString& sRangeName, const uno::Reference< sheet::XSpreadsheet >& xDoc, ScAddress::Convention aConv )
+{
+	uno::Reference< uno::XInterface > xRanges( xDoc, uno::UNO_QUERY_THROW );
+	ScCellRangeObj* pRanges = dynamic_cast< ScCellRangeObj* >( xRanges.get() );
+    ScAddress::Convention eConv = aConv;//ScAddress::CONV_XL_A1;   the default. 
+
+	ScAddress::Details dDetails( eConv, 0, 0 );
+		
+	uno::Reference< table::XCellRange > xRange;
+	if ( pRanges )
+		xRange = pRanges->getCellRangeByName( sRangeName, dDetails );
+	return xRange;	
+}
+
+uno::Reference< table::XCellRange > processKey( const uno::Any& Key, uno::Reference< table::XCellRange >& xRange )
+{
+	uno::Reference< table::XCellRange > xKey;
+	if ( Key.getValueType() == excel::XRange::static_type() )
+	{
+		uno::Reference< excel::XRange > xKeyRange( Key, uno::UNO_QUERY_THROW );
+		xKey.set( xKeyRange->getCellRange(), uno::UNO_QUERY_THROW );
+	}
+	else if ( Key.getValueType() == ::getCppuType( static_cast< const rtl::OUString* >(0) )  )
+			
+	{
+		rtl::OUString sRangeName = ::comphelper::getString( Key );
+		RangeHelper dRange( xRange );
+		xKey = ScVbaRange::getCellRangeForName( sRangeName,  dRange.getSpreadSheet() );
+	}
+	else
+		throw uno::RuntimeException( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Range::Sort illegal type value for key param")), uno::Reference< uno::XInterface >() );
+	return xKey;
+}
+
+// helper method for Sort
+sal_Int32 findSortPropertyIndex( const uno::Sequence< beans::PropertyValue >& props,
+const rtl::OUString& sPropName ) throw( uno::RuntimeException )
+{
+	const beans::PropertyValue* pProp = props.getConstArray();
+	sal_Int32 nItems = props.getLength();
+
+	 sal_Int32 count=0;
+	for ( ; count < nItems; ++count, ++pProp )
+		if ( pProp->Name.equals( sPropName ) )
+			return count;
+	if ( count == nItems )
+		throw uno::RuntimeException( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Range::Sort unknown sort property")), uno::Reference< uno::XInterface >() );
+	return -1; //should never reach here ( satisfy compiler )
+}
+
+// helper method for Sort
+void updateTableSortField( const uno::Reference< table::XCellRange >& xParentRange,
+	const uno::Reference< table::XCellRange >& xColRowKey, sal_Int16 nOrder, 
+	table::TableSortField& aTableField, sal_Bool bIsSortColumn, sal_Bool bMatchCase ) throw ( uno::RuntimeException )
+{
+		RangeHelper parentRange( xParentRange );	
+		RangeHelper colRowRange( xColRowKey );	
+
+		table::CellRangeAddress parentRangeAddress = parentRange.getCellRangeAddressable()->getRangeAddress();
+
+		table::CellRangeAddress colRowKeyAddress = colRowRange.getCellRangeAddressable()->getRangeAddress();
+
+		// make sure that upper left poing of key range is within the
+		// parent range
+		if (  colRowKeyAddress.StartColumn >= parentRangeAddress.StartColumn &&
+			colRowKeyAddress.StartColumn <= parentRangeAddress.EndColumn  &&
+			colRowKeyAddress.StartRow >= parentRangeAddress.StartRow &&
+			colRowKeyAddress.StartRow <= parentRangeAddress.EndRow  )
+		{
+			//determine col/row index
+			if ( bIsSortColumn )
+				aTableField.Field = colRowKeyAddress.StartRow - parentRangeAddress.StartRow;			 
+			else
+				aTableField.Field = colRowKeyAddress.StartColumn - parentRangeAddress.StartColumn;			 
+			aTableField.IsCaseSensitive = bMatchCase;
+
+			if ( nOrder ==  excel::XlSortOrder::xlAscending ) 
+				aTableField.IsAscending = sal_True; 
+			else	
+				aTableField.IsAscending = sal_False; 
+		}
+		else
+			throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Illegal Key param" ) ), uno::Reference< uno::XInterface >() );
+
+						
+} 
+
+void SAL_CALL
+ScVbaRange::Sort( const uno::Any& Key1, const uno::Any& Order1, const uno::Any& Key2, const uno::Any& /*Type*/, const uno::Any& Order2, const uno::Any& Key3, const uno::Any& Order3, const uno::Any& Header, const uno::Any& OrderCustom, const uno::Any& MatchCase, const uno::Any& Orientation, const uno::Any& SortMethod,  const uno::Any& DataOption1, const uno::Any& DataOption2, const uno::Any& DataOption3  ) throw (uno::RuntimeException)
+{
+	// #TODO# #FIXME# can we do something with Type
+	if ( m_Areas->getCount() > 1 )
+		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("That command cannot be used on multiple selections" ) ), uno::Reference< uno::XInterface >() );
+
+	sal_Int16 nDataOption1 = excel::XlSortDataOption::xlSortNormal;
+	sal_Int16 nDataOption2 = excel::XlSortDataOption::xlSortNormal;;
+	sal_Int16 nDataOption3 = excel::XlSortDataOption::xlSortNormal;
+
+	ScDocument* pDoc = getDocumentFromRange( mxRange );
+	if ( !pDoc )
+		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Failed to access document from shell" ) ), uno::Reference< uno::XInterface >() );
+
+	RangeHelper thisRange( mxRange );
+	table::CellRangeAddress thisRangeAddress = thisRange.getCellRangeAddressable()->getRangeAddress();
+	//SCTAB nTab = thisRangeAddress.Sheet;
+
+	ScSortParam aSortParam;
+	// FOR_UPSTREAM_BUILD
+	//pDoc->GetSortParam( aSortParam, nTab );
+
+	if ( DataOption1.hasValue() )
+		DataOption1 >>= nDataOption1;
+	if ( DataOption2.hasValue() )
+		DataOption2 >>= nDataOption2;
+	if ( DataOption3.hasValue() )
+		DataOption3 >>= nDataOption3;
+
+	// 1) #TODO #FIXME need to process DataOption[1..3] not used currently
+	// 2) #TODO #FIXME need to refactor this ( below ) into a IsSingleCell() method
+	uno::Reference< table::XColumnRowRange > xColumnRowRange(mxRange, uno::UNO_QUERY_THROW );
+			
+	// 'Fraid I don't remember what I was trying to achieve here ???
+/* 
+	if (  isSingleCellRange() )
+	{
+		uno::Reference< vba::XRange > xCurrent = CurrentRegion();
+		xCurrent->Sort( Key1, Order1, Key2, Type, Order2, Key3, Order3, Header, OrderCustom, MatchCase, Orientation, SortMethod, DataOption1, DataOption2, DataOption3 );
+		return; 
+	}
+*/
+	// set up defaults
+
+	sal_Int16 nOrder1 = aSortParam.bAscending[0] ? excel::XlSortOrder::xlAscending : excel::XlSortOrder::xlDescending;
+	sal_Int16 nOrder2 = aSortParam.bAscending[1] ? excel::XlSortOrder::xlAscending : excel::XlSortOrder::xlDescending;
+	sal_Int16 nOrder3 = aSortParam.bAscending[2] ? excel::XlSortOrder::xlAscending : excel::XlSortOrder::xlDescending;
+
+	sal_Int16 nCustom = aSortParam.nUserIndex;
+	sal_Int16 nSortMethod = excel::XlSortMethod::xlPinYin;
+	sal_Bool bMatchCase = aSortParam.bCaseSens;
+
+	// seems to work opposite to expected, see below
+	sal_Int16 nOrientation = aSortParam.bByRow ?  excel::XlSortOrientation::xlSortColumns :  excel::XlSortOrientation::xlSortRows;
+
+	if ( Orientation.hasValue() )
+	{
+		// Documentation says xlSortRows is default but that doesn't appear to be 
+		// the case. Also it appears that xlSortColumns is the default which 
+		// strangely enought sorts by Row
+		nOrientation = ::comphelper::getINT16( Orientation );
+		// persist new option to be next calls default
+		if ( nOrientation == excel::XlSortOrientation::xlSortRows )
+			aSortParam.bByRow = FALSE;
+		else
+			aSortParam.bByRow = TRUE;
+
+	}
+
+	sal_Bool bIsSortColumns=sal_False; // sort by row
+
+	if ( nOrientation == excel::XlSortOrientation::xlSortRows )
+		bIsSortColumns = sal_True;
+
+	// FOR_UPSTREAM_BUILD
+	//sal_Int16 nHeader = aSortParam.nCompatHeader;
+	sal_Int16 nHeader = 0;
+	sal_Bool bContainsHeader = sal_False;
+
+	if ( Header.hasValue() )
+	{
+		nHeader = ::comphelper::getINT16( Header );
+		// FOR_UPSTREAM_BUILD
+		//aSortParam.nCompatHeader = nHeader;
+	}			
+
+	if ( nHeader == excel::XlYesNoGuess::xlGuess )
+	{
+		bool bHasColHeader = pDoc->HasColHeader(  static_cast< SCCOL >( thisRangeAddress.StartColumn ), static_cast< SCROW >( thisRangeAddress.StartRow ), static_cast< SCCOL >( thisRangeAddress.EndColumn ), static_cast< SCROW >( thisRangeAddress.EndRow ), static_cast< SCTAB >( thisRangeAddress.Sheet ));
+		bool bHasRowHeader = pDoc->HasRowHeader(  static_cast< SCCOL >( thisRangeAddress.StartColumn ), static_cast< SCROW >( thisRangeAddress.StartRow ), static_cast< SCCOL >( thisRangeAddress.EndColumn ), static_cast< SCROW >( thisRangeAddress.EndRow ), static_cast< SCTAB >( thisRangeAddress.Sheet ) );
+		if ( bHasColHeader || bHasRowHeader )
+			nHeader =  excel::XlYesNoGuess::xlYes; 
+		else
+			nHeader =  excel::XlYesNoGuess::xlNo; 
+		// save set param as default
+		// FOR_UPSTREAM_BUILD
+		//aSortParam.nCompatHeader = nHeader;
+	}
+
+	if ( nHeader == excel::XlYesNoGuess::xlYes )
+		bContainsHeader = sal_True;
+
+	if ( SortMethod.hasValue() )
+	{
+		nSortMethod = ::comphelper::getINT16( SortMethod );
+	}
+	
+	if ( OrderCustom.hasValue() )
+	{
+		OrderCustom >>= nCustom;
+		--nCustom; // 0-based in OOo
+		aSortParam.nUserIndex = nCustom;
+	}
+
+	if ( MatchCase.hasValue() )
+	{
+		MatchCase >>= bMatchCase;
+		aSortParam.bCaseSens = bMatchCase;
+	}
+
+	if ( Order1.hasValue() )
+	{
+		nOrder1 = ::comphelper::getINT16(Order1);
+		if (  nOrder1 == excel::XlSortOrder::xlAscending ) 
+			aSortParam.bAscending[0]  = TRUE;
+		else
+			aSortParam.bAscending[0]  = FALSE;
+
+	}
+	if ( Order2.hasValue() )
+	{
+		nOrder2 = ::comphelper::getINT16(Order2);
+		if ( nOrder2 == excel::XlSortOrder::xlAscending ) 
+			aSortParam.bAscending[1]  = TRUE;
+		else
+			aSortParam.bAscending[1]  = FALSE;
+	}
+	if ( Order3.hasValue() )
+	{
+		nOrder3 = ::comphelper::getINT16(Order3);
+		if ( nOrder3 == excel::XlSortOrder::xlAscending ) 
+			aSortParam.bAscending[2]  = TRUE;
+		else
+			aSortParam.bAscending[2]  = FALSE;
+	}
+
+	uno::Reference< table::XCellRange > xKey1;	
+	uno::Reference< table::XCellRange > xKey2;	
+	uno::Reference< table::XCellRange > xKey3;	
+
+	xKey1 = processKey( Key1, mxRange );
+	if ( !xKey1.is() )
+		throw uno::RuntimeException( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Range::Sort needs a key1 param")), uno::Reference< uno::XInterface >() );
+
+	if ( Key2.hasValue() )
+		xKey2 = processKey( Key2, mxRange );
+	if ( Key3.hasValue() )
+		xKey3 = processKey( Key3, mxRange );
+
+	uno::Reference< util::XSortable > xSort( mxRange, uno::UNO_QUERY_THROW );
+	uno::Sequence< beans::PropertyValue > sortDescriptor = xSort->createSortDescriptor();
+	sal_Int32 nTableSortFieldIndex = findSortPropertyIndex( sortDescriptor, rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("SortFields") ) );
+
+	uno::Sequence< table::TableSortField > sTableFields(1);
+	sal_Int32 nTableIndex = 0;
+	updateTableSortField(  mxRange, xKey1, nOrder1, sTableFields[ nTableIndex++ ], bIsSortColumns, bMatchCase );
+
+	if ( xKey2.is() ) 
+	{
+		sTableFields.realloc( sTableFields.getLength() + 1 );
+		updateTableSortField(  mxRange, xKey2, nOrder2, sTableFields[ nTableIndex++ ], bIsSortColumns, bMatchCase );
+	}
+	if ( xKey3.is()  ) 
+	{
+		sTableFields.realloc( sTableFields.getLength() + 1 );
+		updateTableSortField(  mxRange, xKey3, nOrder3, sTableFields[ nTableIndex++ ], bIsSortColumns, bMatchCase );
+	}
+	sortDescriptor[ nTableSortFieldIndex ].Value <<= sTableFields;
+
+	sal_Int32 nIndex = 	findSortPropertyIndex( sortDescriptor,  rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("IsSortColumns")) );
+	sortDescriptor[ nIndex ].Value <<= bIsSortColumns;
+
+	nIndex = 	findSortPropertyIndex( sortDescriptor, CONTS_HEADER );
+	sortDescriptor[ nIndex ].Value <<= bContainsHeader;
+
+	// FOR_UPSTREAM_BUILD
+	//pDoc->SetSortParam( aSortParam, nTab );
+	xSort->sort( sortDescriptor );
+
+	// #FIXME #TODO
+	// The SortMethod param is not processed ( not sure what its all about, need to
+
+}
+
+uno::Reference< excel::XRange > SAL_CALL 
+ScVbaRange::End( ::sal_Int32 Direction )  throw (uno::RuntimeException)
+{
+	if ( m_Areas->getCount() > 1 )
+	{
+		uno::Reference< excel::XRange > xRange( getArea( 0 ), uno::UNO_QUERY_THROW );
+		return xRange->End( Direction );
+	}
+
+	
+	// #FIXME #TODO
+	// euch! found my orig implementation sucked, so 
+	// trying this even suckier one ( really need to use/expose code in
+	// around  ScTabView::MoveCursorArea(), thats the bit that calcutes
+	// where the cursor should go ) 
+	// Main problem with this method is the ultra hacky attempt to preserve
+	// the ActiveCell, there should be no need to go to these extreems
+	
+	// Save ActiveCell pos ( to restore later )
+	uno::Any aDft;
+	rtl::OUString sActiveCell =	ScVbaGlobals::getGlobalsImpl(
+                       m_xContext )->getApplication()->getActiveCell()->Address(aDft, aDft, aDft, aDft, aDft );
+
+	// position current cell upper left of this range
+	Cells( uno::makeAny( (sal_Int32) 1 ), uno::makeAny( (sal_Int32) 1 ) )->Select();
+
+	SfxViewFrame* pViewFrame = getCurrentViewFrame();
+	if ( pViewFrame )
+	{
+		SfxAllItemSet aArgs( SFX_APP()->GetPool() );
+		// Hoping this will make sure this slot is called
+		// synchronously
+		SfxBoolItem sfxAsync( SID_ASYNCHRON, sal_False );
+		aArgs.Put( sfxAsync, sfxAsync.Which() );
+		SfxDispatcher* pDispatcher = pViewFrame->GetDispatcher();
+
+		USHORT nSID = 0;
+	
+		switch( Direction )
+		{
+			case excel::XlDirection::xlDown:
+				nSID = SID_CURSORBLKDOWN;
+				break;
+			case excel::XlDirection::xlUp:
+				nSID = SID_CURSORBLKUP;
+				break;
+			case excel::XlDirection::xlToLeft:
+				nSID = SID_CURSORBLKLEFT;
+				break;
+			case excel::XlDirection::xlToRight:
+				nSID = SID_CURSORBLKRIGHT;
+				break;
+			default:
+				throw uno::RuntimeException( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ": Invalid ColumnIndex" ) ), uno::Reference< uno::XInterface >() ); 
+		}
+		if ( pDispatcher )
+		{
+			pDispatcher->Execute( nSID, (SfxCallMode)SFX_CALLMODE_SYNCHRON, aArgs );
+		}
+	}
+
+	// result is the ActiveCell		
+	rtl::OUString sMoved =	ScVbaGlobals::getGlobalsImpl(
+                       m_xContext )->getApplication()->getActiveCell()->Address(aDft, aDft, aDft, aDft, aDft );
+
+	// restore old ActiveCell		
+	uno::Any aVoid;
+	uno::Reference< excel::XRange > xOldActiveCell( ScVbaGlobals::getGlobalsImpl(
+		m_xContext )->getActiveSheet()->Range( uno::makeAny( sActiveCell ), aVoid ), uno::UNO_QUERY_THROW );
+	xOldActiveCell->Select();
+
+	uno::Reference< excel::XRange > resultCell;
+	resultCell.set( ScVbaGlobals::getGlobalsImpl(
+		m_xContext )->getActiveSheet()->Range( uno::makeAny( sMoved ), aVoid ), uno::UNO_QUERY_THROW );
+
+	// return result
+	
+	return resultCell;
+}
+
+bool
+ScVbaRange::isSingleCellRange()
+{
+	uno::Reference< table::XColumnRowRange > xColumnRowRange(mxRange, uno::UNO_QUERY_THROW );
+	if ( xColumnRowRange->getRows()->getCount() == 1 && xColumnRowRange->getColumns()->getCount() == 1 )
+		return true;
+	return false;
+}
+
+uno::Reference< excel::XCharacters > SAL_CALL 
+ScVbaRange::characters( const uno::Any& Start, const uno::Any& Length ) throw (uno::RuntimeException)
+{
+	if ( !isSingleCellRange() )
+		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Can't create Characters property for multicell range ") ), uno::Reference< uno::XInterface >() );
+	uno::Reference< text::XSimpleText > xSimple(mxRange->getCellByPosition(0,0) , uno::UNO_QUERY_THROW );
+	ScDocument* pDoc = getDocumentFromRange(mxRange);
+	if ( !pDoc )
+		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Failed to access document from shell" ) ), uno::Reference< uno::XInterface >() );
+
+	ScVbaPalette aPalette( pDoc->GetDocumentShell() );
+	return uno::Reference< excel::XCharacters >( new ScVbaCharacters( m_xContext, aPalette, xSimple, Start, Length ) );
+}
+
+ void SAL_CALL 
+ScVbaRange::Delete( const uno::Any& Shift ) throw (uno::RuntimeException)
+{
+	
+	if ( m_Areas->getCount() > 1 )
+	{
+		sal_Int32 nItems = m_Areas->getCount();
+		for ( sal_Int32 index=1; index <= nItems; ++index )
+		{
+			uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index) ), uno::UNO_QUERY_THROW );
+			xRange->Delete( Shift );	
+		}
+		return;
+	}
+	sheet::CellDeleteMode mode = sheet::CellDeleteMode_NONE ; 
+	if ( Shift.hasValue() )		
+	{
+		sal_Int32 nShift;
+		Shift >>= nShift;
+		switch ( nShift )
+		{
+			case excel::XlDeleteShiftDirection::xlShiftUp:
+				mode = sheet::CellDeleteMode_UP;
+				break;
+			case excel::XlDeleteShiftDirection::xlShiftToLeft:
+				mode = sheet::CellDeleteMode_LEFT;
+				break;
+			default:
+				throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM ("Illegal paramater ") ), uno::Reference< uno::XInterface >() );
+		}
+	}
+	else
+		if ( getRow() >  getColumn() )
+			mode = sheet::CellDeleteMode_UP;
+		else
+			mode = sheet::CellDeleteMode_LEFT;
+	RangeHelper thisRange( mxRange );
+	uno::Reference< sheet::XCellRangeMovement > xCellRangeMove( thisRange.getSpreadSheet(), uno::UNO_QUERY_THROW );
+	xCellRangeMove->removeRange( thisRange.getCellRangeAddressable()->getRangeAddress(), mode ); 
+	
+}
+
+//XElementAccess
+sal_Bool SAL_CALL 
+ScVbaRange::hasElements() throw (uno::RuntimeException)
+{
+	uno::Reference< table::XColumnRowRange > xColumnRowRange(mxRange, uno::UNO_QUERY );
+	if ( xColumnRowRange.is() )
+		if ( xColumnRowRange->getRows()->getCount() ||
+			xColumnRowRange->getColumns()->getCount() )
+			return sal_True;
+	return sal_False;
+}
+
+// XEnumerationAccess
+uno::Reference< container::XEnumeration > SAL_CALL 
+ScVbaRange::createEnumeration() throw (uno::RuntimeException)
+{
+	return new CellsEnumeration( m_xContext, mxRange );
+}
+
+::rtl::OUString SAL_CALL 
+ScVbaRange::getDefaultMethodName(  ) throw (uno::RuntimeException)
+{
+	const static rtl::OUString sName( RTL_CONSTASCII_USTRINGPARAM("Cells") );
+	return sName;
+}
+
+
+uno::Reference< awt::XDevice > 
+getDeviceFromDoc( const uno::Reference< frame::XModel >& xModel ) throw( uno::RuntimeException )
+{
+	uno::Reference< frame::XController > xController( xModel->getCurrentController(), uno::UNO_QUERY_THROW );
+	uno::Reference< frame::XFrame> xFrame( xController->getFrame(), uno::UNO_QUERY_THROW );
+	uno::Reference< awt::XDevice > xDevice( xFrame->getComponentWindow(), uno::UNO_QUERY_THROW );
+	return xDevice;
+}
+
+// returns calc internal col. width ( in points )
+double 
+ScVbaRange::getCalcColWidth( const table::CellRangeAddress& rAddress) throw (uno::RuntimeException)
+{
+	ScDocument* pDoc = getDocumentFromRange( mxRange );
+	USHORT nWidth = pDoc->GetOriginalWidth( static_cast< SCCOL >( rAddress.StartColumn ), static_cast< SCTAB >( rAddress.Sheet ) );
+	double nPoints = lcl_TwipsToPoints( nWidth );
+	nPoints = lcl_Round2DecPlaces( nPoints );
+	return nPoints;
+}
+
+double
+ScVbaRange::getCalcRowHeight( const table::CellRangeAddress& rAddress ) throw (uno::RuntimeException)
+{
+	ScDocument* pDoc = getDocumentFromRange( mxRange );
+	USHORT nWidth = pDoc->GetOriginalHeight( rAddress.StartRow, rAddress.Sheet );
+	double nPoints = lcl_TwipsToPoints( nWidth );
+	nPoints = lcl_Round2DecPlaces( nPoints );
+	return nPoints;	
+}
+
+// return Char Width in points
+double getDefaultCharWidth( const uno::Reference< frame::XModel >& xModel ) throw ( uno::RuntimeException )
+{
+	const static rtl::OUString sDflt( RTL_CONSTASCII_USTRINGPARAM("Default")); 
+	const static rtl::OUString sCharFontName( RTL_CONSTASCII_USTRINGPARAM("CharFontName")); 
+	const static rtl::OUString sPageStyles( RTL_CONSTASCII_USTRINGPARAM("PageStyles")); 
+	// get the font from the default style
+	uno::Reference< style::XStyleFamiliesSupplier > xStyleSupplier( xModel, uno::UNO_QUERY_THROW );
+	uno::Reference< container::XNameAccess > xNameAccess( xStyleSupplier->getStyleFamilies(), uno::UNO_QUERY_THROW );
+	uno::Reference< container::XNameAccess > xNameAccess2( xNameAccess->getByName( sPageStyles ), uno::UNO_QUERY_THROW );
+	uno::Reference< beans::XPropertySet > xProps( xNameAccess2->getByName( sDflt ), uno::UNO_QUERY_THROW );
+	rtl::OUString sFontName;
+	xProps->getPropertyValue( sCharFontName ) >>= sFontName;
+
+	uno::Reference< awt::XDevice > xDevice = getDeviceFromDoc( xModel );
+	awt::FontDescriptor aDesc;
+	aDesc.Name = sFontName;
+	uno::Reference< awt::XFont > xFont( xDevice->getFont( aDesc ), uno::UNO_QUERY_THROW );
+	double nCharPixelWidth =  xFont->getCharWidth( (sal_Int8)'0' );	
+
+	double nPixelsPerMeter = xDevice->getInfo().PixelPerMeterX;
+	double nCharWidth = nCharPixelWidth /  nPixelsPerMeter;
+	nCharWidth = nCharWidth * (double)56700;// in twips
+	return lcl_TwipsToPoints( (USHORT)nCharWidth );	
+}
+
+uno::Any SAL_CALL 
+ScVbaRange::getColumnWidth() throw (uno::RuntimeException)
+{
+	double nColWidth = 	0;
+	ScDocShell* pShell = getDocShellFromRange( mxRange );
+	if ( pShell )
+	{
+		RangeHelper thisRange( mxRange );
+		table::CellRangeAddress thisAddress = thisRange.getCellRangeAddressable()->getRangeAddress();	
+		uno::Reference< table::XColumnRowRange > xColRowRange( mxRange, uno::UNO_QUERY_THROW );			
+		uno::Reference< beans::XPropertySet > xProps( xColRowRange->getColumns(), uno::UNO_QUERY_THROW ); 
+		uno::Reference< frame::XModel > xModel = pShell->GetModel();
+		if ( xModel.is() )
+			nColWidth = getCalcColWidth(thisAddress) / getDefaultCharWidth( xModel );
+	}
+	nColWidth = lcl_Round2DecPlaces( nColWidth );
+	return uno::makeAny( nColWidth );
+}
+
+void SAL_CALL 
+ScVbaRange::setColumnWidth( const uno::Any& _columnwidth ) throw (uno::RuntimeException)
+{
+	double nColWidth = 0;
+	_columnwidth >>= nColWidth;
+	nColWidth = lcl_Round2DecPlaces( nColWidth );
+        ScDocShell* pDocShell = getDocShellFromRange( mxRange );
+        if ( pDocShell )
+        {
+                uno::Reference< frame::XModel > xModel = pDocShell->GetModel();
+                if ( xModel.is() )
+                {
+
+			nColWidth = ( nColWidth * getDefaultCharWidth( xModel ) );
+			RangeHelper thisRange( mxRange );	
+			table::CellRangeAddress thisAddress = thisRange.getCellRangeAddressable()->getRangeAddress();
+			USHORT nTwips = lcl_pointsToTwips( nColWidth );
+			
+			ScDocFunc aFunc(*pDocShell);
+			SCCOLROW nColArr[2];
+			nColArr[0] = thisAddress.StartColumn;
+			nColArr[1] = thisAddress.EndColumn;
+			aFunc.SetWidthOrHeight( TRUE, 1, nColArr, thisAddress.Sheet, SC_SIZE_ORIGINAL,
+		                                                                        nTwips, TRUE, TRUE );		
+			
+		}
+	}
+}
+
+uno::Any SAL_CALL 
+ScVbaRange::getWidth() throw (uno::RuntimeException)
+{
+	uno::Reference< table::XColumnRowRange > xColRowRange( mxRange, uno::UNO_QUERY_THROW );			
+	uno::Reference< container::XIndexAccess > xIndexAccess( xColRowRange->getColumns(), uno::UNO_QUERY_THROW ); 
+	sal_Int32 nElems = xIndexAccess->getCount();	
+	double nWidth = 0;
+	for ( sal_Int32 index=0; index<nElems; ++index )
+	{
+		uno::Reference< sheet::XCellRangeAddressable > xAddressable( xIndexAccess->getByIndex( index ), uno::UNO_QUERY_THROW ); 
+		double nTmpWidth = getCalcColWidth( xAddressable->getRangeAddress() );
+		nWidth += nTmpWidth;
+	}
+	return uno::makeAny( nWidth );
+}
+
+uno::Any SAL_CALL 
+ScVbaRange::Areas( const uno::Any& item) throw (uno::RuntimeException)
+{
+	if ( !item.hasValue() )
+		return uno::makeAny( m_Areas );
+	return m_Areas->Item( item );	
+}
+
+uno::Reference< excel::XRange >
+ScVbaRange::getArea( sal_Int32 nIndex ) throw( css::uno::RuntimeException )
+{
+	if ( !m_Areas.is() )
+		throw uno::RuntimeException( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("No areas available")), uno::Reference< uno::XInterface >() );
+	uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny( ++nIndex ) ), uno::UNO_QUERY_THROW );
+	return xRange;
+}
+
+uno::Any
+ScVbaRange::Borders( const uno::Any& item ) throw( css::uno::RuntimeException )
+{
+	if ( !item.hasValue() )
+		return uno::makeAny( m_Borders );
+	return m_Borders->Item( item );
+}
+
+uno::Any SAL_CALL
+ScVbaRange::BorderAround( const css::uno::Any& LineStyle, const css::uno::Any& Weight,
+                const css::uno::Any& ColorIndex, const css::uno::Any& Color ) throw (css::uno::RuntimeException)
+{
+    sal_Int32 nCount = m_Borders->getCount();
+    uno::Reference< excel::XBorders > xBorders( m_Borders, uno::UNO_QUERY_THROW);
+    for( sal_Int32 i = 0; i < nCount; i++ )
+    {
+        const sal_Int32 nLineType = supportedIndexTable[i];
+        switch( nLineType )
+        {
+            case excel::XlBordersIndex::xlEdgeLeft:
+            case excel::XlBordersIndex::xlEdgeTop:
+            case excel::XlBordersIndex::xlEdgeBottom:
+            case excel::XlBordersIndex::xlEdgeRight:
+            {
+                uno::Reference< excel::XBorder > xBorder( m_Borders->Item( uno::makeAny( nLineType ) ), uno::UNO_QUERY_THROW );
+                if( LineStyle.hasValue() )
+                {
+                    xBorder->setLineStyle( LineStyle );
+                }
+                if( Weight.hasValue() )
+                {
+                    xBorder->setWeight( Weight );
+                }
+                if( ColorIndex.hasValue() )
+                {
+                    xBorder->setColorIndex( ColorIndex );
+                }
+                if( Color.hasValue() )
+                {
+                    xBorder->setColor( Color );
+                }
+                break;
+            }
+            case excel::XlBordersIndex::xlInsideVertical:
+            case excel::XlBordersIndex::xlInsideHorizontal:
+            case excel::XlBordersIndex::xlDiagonalDown:
+            case excel::XlBordersIndex::xlDiagonalUp:
+                break;
+            default:
+                return uno::makeAny( sal_False );
+        }
+    }
+    return uno::makeAny( sal_True );
+}
+
+uno::Any SAL_CALL 
+ScVbaRange::getRowHeight() throw (uno::RuntimeException)
+{
+	RangeHelper thisRange( mxRange );	
+	table::CellRangeAddress thisAddress = thisRange.getCellRangeAddressable()->getRangeAddress();
+	double nHeight = getCalcRowHeight( thisAddress );
+	return uno::makeAny( nHeight );
+}
+
+void SAL_CALL 
+ScVbaRange::setRowHeight( const uno::Any& _rowheight) throw (uno::RuntimeException)
+{
+	 double nHeight; // Incomming height is in points
+        _rowheight >>= nHeight;
+	nHeight = lcl_Round2DecPlaces( nHeight );
+	RangeHelper thisRange( mxRange );	
+	table::CellRangeAddress thisAddress = thisRange.getCellRangeAddressable()->getRangeAddress();
+	USHORT nTwips = lcl_pointsToTwips( nHeight );
+	
+	ScDocShell* pDocShell = getDocShellFromRange( mxRange );
+	ScDocFunc aFunc(*pDocShell);
+	SCCOLROW nRowArr[2];
+	nRowArr[0] = thisAddress.StartRow;
+	nRowArr[1] = thisAddress.EndRow;
+	aFunc.SetWidthOrHeight( FALSE, 1, nRowArr, thisAddress.Sheet, SC_SIZE_ORIGINAL,
+                                                                        nTwips, TRUE, TRUE );		
+}
+
+uno::Any SAL_CALL 
+ScVbaRange::getPageBreak() throw (uno::RuntimeException)
+{
+	sal_Int32 nPageBreak = excel::XlPageBreak::XlPageBreakNone;
+	ScDocShell* pShell = getDocShellFromRange( mxRange );
+	if ( pShell )
+	{
+		RangeHelper thisRange( mxRange );
+		table::CellRangeAddress thisAddress = thisRange.getCellRangeAddressable()->getRangeAddress();
+		BOOL bColumn = FALSE;
+		
+		if (thisAddress.StartRow==0)
+		    bColumn = TRUE;
+		
+		uno::Reference< frame::XModel > xModel = pShell->GetModel();
+		if ( xModel.is() )
+		{
+	        ScDocument* pDoc =  getDocumentFromRange( mxRange );
+	        
+			BYTE nFlag = 0;
+			if ( !bColumn )
+			    nFlag = pDoc -> GetRowFlags(thisAddress.StartRow, thisAddress.Sheet);
+			else
+			    nFlag = pDoc -> GetColFlags(static_cast<SCCOL>(thisAddress.StartColumn), thisAddress.Sheet);
+			    
+			if ( nFlag & CR_PAGEBREAK)
+			    nPageBreak = excel::XlPageBreak::XlPageBreakAutomatic;
+			    
+			if ( nFlag & CR_MANUALBREAK)
+			    nPageBreak = excel::XlPageBreak::XlPageBreakManual;
+		}		
+	}
+
+	return uno::makeAny( nPageBreak );
+}
+
+void SAL_CALL 
+ScVbaRange::setPageBreak( const uno::Any& _pagebreak) throw (uno::RuntimeException)
+{
+	sal_Int32 nPageBreak; 
+    _pagebreak >>= nPageBreak;
+		
+	ScDocShell* pShell = getDocShellFromRange( mxRange );
+	if ( pShell )
+	{
+		RangeHelper thisRange( mxRange );
+		table::CellRangeAddress thisAddress = thisRange.getCellRangeAddressable()->getRangeAddress();
+		if ((thisAddress.StartColumn==0) && (thisAddress.StartRow==0))
+		    return;
+		BOOL bColumn = FALSE;
+		
+		if (thisAddress.StartRow==0)
+		    bColumn = TRUE;
+		
+		ScAddress aAddr( static_cast<SCCOL>(thisAddress.StartColumn), thisAddress.StartRow, thisAddress.Sheet );	
+		uno::Reference< frame::XModel > xModel = pShell->GetModel();
+		if ( xModel.is() )
+		{
+			ScTabViewShell* pViewShell = getBestViewShell( xModel );
+			if ( nPageBreak == excel::XlPageBreak::XlPageBreakManual )
+			    pViewShell->InsertPageBreak( bColumn, TRUE, &aAddr);
+			else if ( nPageBreak == excel::XlPageBreak::XlPageBreakNone )
+			    pViewShell->DeletePageBreak( bColumn, TRUE, &aAddr);
+		}
+	}
+}
+
+uno::Any SAL_CALL 
+ScVbaRange::getHeight() throw (uno::RuntimeException)
+{
+	uno::Reference< table::XColumnRowRange > xColRowRange( mxRange, uno::UNO_QUERY_THROW );			
+	uno::Reference< container::XIndexAccess > xIndexAccess( xColRowRange->getRows(), uno::UNO_QUERY_THROW ); 
+	sal_Int32 nElems = xIndexAccess->getCount();
+	double nHeight = 0;
+	for ( sal_Int32 index=0; index<nElems; ++index )
+	{
+        	uno::Reference< sheet::XCellRangeAddressable > xAddressable( xIndexAccess->getByIndex( index ), uno::UNO_QUERY_THROW ); 
+		nHeight += getCalcRowHeight(xAddressable->getRangeAddress() );
+	}
+	return uno::makeAny( nHeight );
+}
+
+uno::Reference< excel::XWorksheet >
+ScVbaRange::getWorksheet() throw (uno::RuntimeException)
+{
+	ScDocShell* pDocShell =  getDocShellFromRange(mxRange);
+	RangeHelper* rHelper = new RangeHelper(mxRange);
+        return new ScVbaWorksheet(m_xContext,rHelper->getSpreadSheet(),pDocShell->GetModel());
+}
+
+ScCellRangesBase*
+ScVbaRange::getCellRangesBase() throw( uno::RuntimeException )
+{
+	ScCellRangesBase* pUnoRangesBase = NULL;
+	if ( mxRanges.is() )
+	{
+		uno::Reference< uno::XInterface > xIf( mxRanges, uno::UNO_QUERY_THROW );
+		pUnoRangesBase = dynamic_cast< ScCellRangesBase* >( xIf.get() );
+	}
+	else if ( mxRange.is() )
+	{
+		uno::Reference< uno::XInterface > xIf( mxRange, uno::UNO_QUERY_THROW );
+		pUnoRangesBase = dynamic_cast< ScCellRangesBase* >( xIf.get() );
+	}
+	else
+		throw uno::RuntimeException( rtl::OUString::createFromAscii("General Error creating range - Unknown" ), uno::Reference< uno::XInterface >() );
+	return pUnoRangesBase;
+}
+
+// #TODO remove this ugly application processing
+// Process an application Range request e.g. 'Range("a1,b2,a4:b6")
+uno::Reference< excel::XRange >
+ScVbaRange::ApplicationRange( const uno::Reference< uno::XComponentContext >& xContext, const css::uno::Any &Cell1, const css::uno::Any &Cell2 ) throw (css::uno::RuntimeException)
+{
+	// Althought the documentation seems clear that Range without a 
+	// qualifier then its a shortcut for ActiveSheet.Range
+	// however, similarly Application.Range is apparently also a 
+	// shortcut for ActiveSheet.Range
+	// The is however a subtle behavioural difference I've come across 
+	// wrt to named ranges.
+	// If a named range "test" exists { Sheet1!$A1 } and the active sheet
+	// is Sheet2 then the following will fail
+	// msgbox ActiveSheet.Range("test").Address ' failes
+	// msgbox WorkSheets("Sheet2").Range("test").Address
+	// but !!!
+	// msgbox Range("test").Address ' works
+	// msgbox Application.Range("test").Address ' works
+
+	// Single param Range 
+	rtl::OUString sRangeName;
+	Cell1 >>= sRangeName;
+	if ( Cell1.hasValue() && !Cell2.hasValue() && sRangeName.getLength() )
+	{
+		const static rtl::OUString sNamedRanges( RTL_CONSTASCII_USTRINGPARAM("NamedRanges"));
+		uno::Reference< beans::XPropertySet > xPropSet( getCurrentDocument(), uno::UNO_QUERY_THROW );
+		
+		uno::Reference< container::XNameAccess > xNamed( xPropSet->getPropertyValue( sNamedRanges ), uno::UNO_QUERY_THROW );
+		uno::Reference< sheet::XCellRangeReferrer > xReferrer;
+		try
+		{
+			xReferrer.set ( xNamed->getByName( sRangeName ), uno::UNO_QUERY );
+		}
+		catch( uno::Exception& /*e*/ )
+		{
+			// do nothing
+		}
+		if ( xReferrer.is() )
+		{
+			uno::Reference< table::XCellRange > xRange = xReferrer->getReferredCells();
+			if ( xRange.is() )
+			{
+				uno::Reference< excel::XRange > xVbRange =  new  ScVbaRange( xContext, xRange );
+				return xVbRange;
+			}
+		}
+	}
+	uno::Reference< sheet::XSpreadsheetView > xView( getCurrentDocument()->getCurrentController(), uno::UNO_QUERY );
+	uno::Reference< table::XCellRange > xSheetRange( xView->getActiveSheet(), uno::UNO_QUERY_THROW ); 
+	ScVbaRange* pRange = new ScVbaRange( xContext, xSheetRange );
+	uno::Reference< excel::XRange > xVbSheetRange( pRange );
+	return pRange->Range( Cell1, Cell2, true ); 
+}
+
+
+void SAL_CALL 
+ScVbaRange::AutoFilter( const uno::Any& Field, const uno::Any& Criteria1, const uno::Any& Operator, const uno::Any& /*Criteria2*/, const uno::Any& VisibleDropDown ) throw (uno::RuntimeException)
+{
+	// #TODO We could probably hook into the autofilter stuff better
+	// or at least seperate the code in dbfunc so it could be shared
+	// currently a cut'n'paste fest exists below :-(
+
+	ScDocument* pDoc =  getDocumentFromRange( mxRange );
+	ScDocShell* pDocSh = getDocShellFromRange( mxRange );	
+	ScDocShellModificator aModificator( *pDocSh );
+	sal_Bool bHasAuto = sal_True;	
+	RangeHelper thisRange( mxRange );	
+	table::CellRangeAddress thisAddress = thisRange.getCellRangeAddressable()->getRangeAddress();
+
+	ScRange aRange;	
+	ScUnoConversion::FillScRange( aRange, thisAddress );
+	ScDBData* pDBData = pDocSh->GetDBData( aRange, SC_DB_MAKE, TRUE );
+	ScQueryParam aParam;
+	pDBData->GetQueryParam( aParam );
+	SCROW  nRow = aParam.nRow1;
+	SCTAB  nTab = aRange.aStart.Tab();
+	INT16   nFlag;
+
+	for (SCCOL nCol=aParam.nCol1; nCol<=aParam.nCol2 && ( bHasAuto == sal_True ); nCol++)
+	{
+		nFlag = ((ScMergeFlagAttr*) pDoc->GetAttr( nCol, nRow, nTab, ATTR_MERGE_FLAG ))->GetValue();
+
+		if ( (nFlag & SC_MF_AUTO) == 0 )
+			bHasAuto = sal_False;
+	}	
+
+	OSL_TRACE("Auto is set ? %s", bHasAuto ? "true" : "false" );
+
+	// for the moment we only process first Criteria1	
+		
+	sal_Int32 nField = 0; // *IS* 1 based
+	rtl::OUString sCriteria1;
+	sal_Int32 nOperator = excel::XlAutoFilterOperator::xlAnd; 
+
+
+	
+	sal_Bool bVisible = sal_True;
+	bool  bChangeDropDown = false;
+	VisibleDropDown >>= bVisible;
+
+	if ( bVisible == bHasAuto ) // dropdown is displayed/notdisplayed as
+								// required
+		bVisible = sal_False;
+	else
+		bChangeDropDown = true;	
+
+	sheet::FilterOperator nOp = sheet::FilterOperator_EQUAL;		
+	sheet::FilterConnection nConn = sheet::FilterConnection_AND;		
+	double nCriteria1 = 0;
+
+	bool bHasCritValue = Criteria1.hasValue();
+	bool bCritHasNumericValue = sal_False;
+	if ( bHasCritValue )
+		bCritHasNumericValue = ( Criteria1 >>= nCriteria1 );
+
+	if ( ( Field >>= nField ) 
+	||   Criteria1.hasValue()
+	||   ( Operator >>= nOperator )
+	||   VisibleDropDown.hasValue()
+	)
+	{
+		Criteria1 >>= sCriteria1;
+		uno::Reference< sheet::XSheetFilterable > xFilt( mxRange, uno::UNO_QUERY_THROW );
+		uno::Reference< sheet::XSheetFilterDescriptor > xDesc = xFilt->createFilterDescriptor( sal_True );
+		uno::Sequence< sheet::TableFilterField > sTabFilts = xDesc->getFilterFields();
+		sTabFilts.realloc( 1 );
+		sTabFilts[0].IsNumeric = bCritHasNumericValue;
+		OSL_TRACE("No filt fields is %d", sTabFilts.getLength() );
+
+		if ( bHasCritValue && sCriteria1.getLength() )
+		{
+			if ( sCriteria1.equals( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("=") ) ) )
+				nOp = sheet::FilterOperator_EMPTY;
+			else if ( sCriteria1.equals( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("<>") ) ) )
+				nOp = sheet::FilterOperator_NOT_EMPTY;	
+			else
+				nOp = sheet::FilterOperator_EQUAL;
+		}
+
+		if ( Operator.hasValue() )
+		{
+			// if its a bottom/top Ten(Percent/Value) and there
+			// is no value specified for critera1 set it to 10
+			if ( !bCritHasNumericValue && !sCriteria1.getLength() && ( nOperator != excel::XlAutoFilterOperator::xlOr ) && ( nOperator != excel::XlAutoFilterOperator::xlAnd ) )
+			{
+				nCriteria1 = 10;
+				sTabFilts[0].IsNumeric = sal_True;	
+			}
+			switch ( nOperator )
+			{
+				case excel::XlAutoFilterOperator::xlBottom10Items:
+					nOp = sheet::FilterOperator_BOTTOM_VALUES;
+					break;
+				case excel::XlAutoFilterOperator::xlBottom10Percent:
+					nOp = sheet::FilterOperator_BOTTOM_PERCENT;
+					break;
+				case excel::XlAutoFilterOperator::xlTop10Items:
+					nOp = sheet::FilterOperator_TOP_VALUES;
+					break;
+				case excel::XlAutoFilterOperator::xlTop10Percent:
+					nOp = sheet::FilterOperator_TOP_PERCENT;
+					break;
+				case excel::XlAutoFilterOperator::xlOr:
+					nConn = sheet::FilterConnection_OR;		
+				case excel::XlAutoFilterOperator::xlAnd:
+					nConn = sheet::FilterConnection_AND;		
+				default:
+					throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("UnknownOption") ), uno::Reference< uno::XInterface >() );
+					
+			}	
+
+		}		
+		sTabFilts[0].Connection = nConn;	
+		if ( nField > 0 )
+			sTabFilts[0].Field = (nField - 1);	
+		else
+			sTabFilts[0].Field = 0;	
+		sTabFilts[0].Operator = nOp;	
+		if(	sTabFilts[0].IsNumeric )
+			sTabFilts[0].NumericValue = nCriteria1;	
+		else
+			sTabFilts[0].StringValue = sCriteria1;	
+
+		xDesc->setFilterFields( sTabFilts );
+		uno::Reference< beans::XPropertySet > xProps( xDesc, uno::UNO_QUERY_THROW );
+		xProps->setPropertyValue( CONTS_HEADER, uno::makeAny( sal_True ) );
+		xFilt->filter( xDesc );
+	
+	}
+	else 
+		bChangeDropDown = true;	
+	// enable drop down
+	if ( bChangeDropDown )
+	{
+		ScRange aTmpRange;
+		pDBData->GetArea( aTmpRange );
+		for (SCCOL nCol=aParam.nCol1; nCol<=aParam.nCol2; nCol++)
+		{
+			nFlag = ((ScMergeFlagAttr*) pDoc->GetAttr( nCol, nRow, nTab, ATTR_MERGE_FLAG ))->GetValue();
+			if ( bVisible )
+				pDoc->ApplyAttr( nCol, nRow, nTab, ScMergeFlagAttr( nFlag | SC_MF_AUTO ) );
+			else
+				pDoc->ApplyAttr( nCol, nRow, nTab, ScMergeFlagAttr( nFlag &~ SC_MF_AUTO ) );
+		}
+		if ( !bVisible )
+		{
+			SCSIZE nEC = aParam.GetEntryCount();
+			for (SCSIZE i=0; i<nEC; i++)
+				aParam.GetEntry(i).bDoQuery = FALSE;
+			aParam.bDuplicate = TRUE;
+			ScDBDocFunc aDBDocFunc( *pDocSh );
+			aDBDocFunc.Query( nTab, aParam, &aTmpRange, TRUE, FALSE );
+		}
+		pDocSh->PostPaint( aParam.nCol1, nRow, nTab, aParam.nCol2, nRow, nTab, PAINT_GRID );	
+	}		
+}
+void SAL_CALL 
+ScVbaRange::Insert( const uno::Any& Shift, const uno::Any& /*CopyOrigin*/ ) throw (uno::RuntimeException)
+{
+	// It appears ( from the web ) that the undocumented CopyOrigin
+	// param should contain member of enum XlInsertFormatOrigin
+	// which can have values xlFormatFromLeftOrAbove or xlFormatFromRightOrBelow
+	// #TODO investigate resultant behaviour using these constants
+	// currently just processing Shift
+
+	sheet::CellInsertMode mode = sheet::CellInsertMode_NONE; 
+	if ( Shift.hasValue() )
+	{
+		sal_Int32 nShift;
+		Shift >>= nShift;
+		switch ( nShift )
+		{
+			case excel::XlInsertShiftDirection::xlShiftToRight:
+				mode = sheet::CellInsertMode_RIGHT;
+				break;
+			case excel::XlInsertShiftDirection::xlShiftDown:
+				mode = sheet::CellInsertMode_DOWN;
+				break;
+			default:
+				throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM ("Illegal paramater ") ), uno::Reference< uno::XInterface >() );
+		}
+	}
+	else 
+	{
+		if ( getRow() >=  getColumn() )
+			mode = sheet::CellInsertMode_DOWN;
+		else
+			mode = sheet::CellInsertMode_RIGHT;
+	}
+	RangeHelper thisRange( mxRange );
+	uno::Reference< sheet::XCellRangeMovement > xCellRangeMove( thisRange.getSpreadSheet(), uno::UNO_QUERY_THROW );	
+	xCellRangeMove->insertCells( thisRange.getCellRangeAddressable()->getRangeAddress(), mode );
+}
+
+void SAL_CALL
+ScVbaRange::Autofit() throw (uno::RuntimeException)
+{
+        ScDocShell* pDocShell = getDocShellFromRange( mxRange );
+        if ( pDocShell )
+        {
+			RangeHelper thisRange( mxRange );	
+			table::CellRangeAddress thisAddress = thisRange.getCellRangeAddressable()->getRangeAddress();
+			
+			ScDocFunc aFunc(*pDocShell);
+			SCCOLROW nColArr[2];
+			nColArr[0] = thisAddress.StartColumn;
+			nColArr[1] = thisAddress.EndColumn;
+			aFunc.SetWidthOrHeight( TRUE, 1, nColArr, thisAddress.Sheet, SC_SIZE_OPTIMAL,
+		                                                                        0, TRUE, TRUE );		
+			
+	}	
+}
+
+/***************************************************************************************
+ * interface for text: 
+ * com.sun.star.text.XText, com.sun.star.table.XCell, com.sun.star.container.XEnumerationAccess
+ * com.sun.star.text.XTextRange, 
+ * the main problem is to recognize the numeric and date, which assosiate with DecimalSeparator, ThousandsSeparator, 
+ * TrailingMinusNumbers and FieldInfo.
+***************************************************************************************/
+void SAL_CALL
+ScVbaRange::TextToColumns( const css::uno::Any& Destination, const css::uno::Any& DataType, const css::uno::Any& TextQualifier,
+        const css::uno::Any& ConsecutinveDelimiter, const css::uno::Any& Tab, const css::uno::Any& Semicolon, const css::uno::Any& Comma,
+        const css::uno::Any& Space, const css::uno::Any& Other, const css::uno::Any& OtherChar, const css::uno::Any& /*FieldInfo*/,
+        const css::uno::Any& DecimalSeparator, const css::uno::Any& ThousandsSeparator, const css::uno::Any& /*TrailingMinusNumbers*/  ) throw (css::uno::RuntimeException)
+{
+    OSL_TRACE("nJust for test\n");
+    uno::Reference< excel::XRange > xRange;
+    if( Destination.hasValue() )
+    {
+        if( !( Destination >>= xRange ) )
+            throw uno::RuntimeException( rtl::OUString::createFromAscii( "Destination parameter should be a range" ),
+                    uno::Reference< uno::XInterface >() );
+        OSL_TRACE("set range\n");
+    }
+    else
+    {
+        //set as current
+        xRange = this;
+        OSL_TRACE("set range as himself\n");
+    }
+
+   sal_Int16 xlTextParsingType = excel::XlTextParsingType::xlDelimited;
+    if ( DataType.hasValue() )
+    {
+        if( !( DataType >>= xlTextParsingType ) )
+            throw uno::RuntimeException( rtl::OUString::createFromAscii( "DataType parameter should be a short" ),
+                    uno::Reference< uno::XInterface >() );
+        OSL_TRACE("set Datatype\n" );
+    }
+    sal_Bool bDilimited = ( xlTextParsingType == excel::XlTextParsingType::xlDelimited );
+
+    sal_Int16 xlTextQualifier = excel::XlTextQualifier::xlTextQualifierDoubleQuote; 
+    if( TextQualifier.hasValue() )
+    {
+        if( !( TextQualifier >>= xlTextQualifier ))
+             throw uno::RuntimeException( rtl::OUString::createFromAscii( "TextQualifier parameter should be a short" ),
+                    uno::Reference< uno::XInterface >() );
+        OSL_TRACE("set TextQualifier\n");
+    }
+
+    sal_Bool bConsecutinveDelimiter = sal_False;
+    if( ConsecutinveDelimiter.hasValue() )
+    {
+        if( !( ConsecutinveDelimiter >>= bConsecutinveDelimiter ) )
+            throw uno::RuntimeException( rtl::OUString::createFromAscii( "ConsecutinveDelimiter parameter should be a boolean" ),
+                    uno::Reference< uno::XInterface >() );
+        OSL_TRACE("set ConsecutinveDelimiter\n");
+    }
+
+    sal_Bool bTab = sal_False;
+    if( Tab.hasValue() && bDilimited )
+    {
+        if( !( Tab >>= bTab ) )
+            throw uno::RuntimeException( rtl::OUString::createFromAscii( "Tab parameter should be a boolean" ),
+                    uno::Reference< uno::XInterface >() );
+        OSL_TRACE("set Tab\n");
+    }
+
+    sal_Bool bSemicolon = sal_False;
+    if( Semicolon.hasValue() && bDilimited )
+    {
+        if( !( Semicolon >>= bSemicolon ) )
+            throw uno::RuntimeException( rtl::OUString::createFromAscii( "Semicolon parameter should be a boolean" ),
+                    uno::Reference< uno::XInterface >() );
+        OSL_TRACE("set Semicolon\n");
+    }
+    sal_Bool bComma = sal_False;
+    if( Comma.hasValue() && bDilimited )
+    {
+        if( !( Comma >>= bComma ) )
+            throw uno::RuntimeException( rtl::OUString::createFromAscii( "Comma parameter should be a boolean" ),
+                    uno::Reference< uno::XInterface >() );
+        OSL_TRACE("set Comma\n");
+    }
+    sal_Bool bSpace = sal_False;
+    if( Space.hasValue() && bDilimited )
+    {
+        if( !( Space >>= bSpace ) )
+            throw uno::RuntimeException( rtl::OUString::createFromAscii( "Space parameter should be a boolean" ),
+                    uno::Reference< uno::XInterface >() );
+        OSL_TRACE("set Space\n");
+    }
+    sal_Bool bOther = sal_False;
+    rtl::OUString sOtherChar;
+    if( Other.hasValue() && bDilimited )
+    {
+        if( Other >>= bOther )
+        {
+            if( OtherChar.hasValue() )
+                if( !( OtherChar >>= sOtherChar ) )
+                    throw uno::RuntimeException( rtl::OUString::createFromAscii( "OtherChar parameter should be a String" ),
+                        uno::Reference< uno::XInterface >() );
+        OSL_TRACE("set OtherChar\n" );
+        }
+     else if( bOther )
+            throw uno::RuntimeException( rtl::OUString::createFromAscii( "Other parameter should be a True" ),
+                    uno::Reference< uno::XInterface >() );
+    }
+ //TODO* FieldInfo   Optional Variant. An array containing parse information for the individual columns of data. The interpretation depends on the value of DataType. When the data is delimited, this argument is an array of two-element arrays, with each two-element array specifying the conversion options for a particular column. The first element is the column number (1-based), and the second element is one of the xlColumnDataType  constants specifying how the column is parsed.
+
+    rtl::OUString sDecimalSeparator;
+    if( DecimalSeparator.hasValue() )
+    {
+        if( !( DecimalSeparator >>= sDecimalSeparator ) )
+            throw uno::RuntimeException( rtl::OUString::createFromAscii( "DecimalSeparator parameter should be a String" ),
+                uno::Reference< uno::XInterface >() );
+        OSL_TRACE("set DecimalSeparator\n" );
+    }
+    rtl::OUString sThousandsSeparator;
+    if( ThousandsSeparator.hasValue() )
+    {
+        if( !( ThousandsSeparator >>= sThousandsSeparator ) )
+            throw uno::RuntimeException( rtl::OUString::createFromAscii( "ThousandsSeparator parameter should be a String" ),
+                uno::Reference< uno::XInterface >() );
+        OSL_TRACE("set ThousandsSpeparator\n" );
+    }
+ //TODO* TrailingMinusNumbers  Optional Variant. Numbers that begin with a minus character.
+}
+
+css::uno::Reference< excel::XValidation > SAL_CALL 
+ScVbaRange::getValidation() throw (css::uno::RuntimeException)
+{
+	if ( !m_xValidation.is() )	
+		m_xValidation = new ScVbaValidation( m_xContext, mxRange );
+	return m_xValidation;
+}
+
+void SAL_CALL 
+ScVbaRange::PrintOut( const uno::Any& From, const uno::Any& To, const uno::Any& Copies, const uno::Any& Preview, const uno::Any& ActivePrinter, const uno::Any& PrintToFile, const uno::Any& Collate, const uno::Any& PrToFileName ) throw (uno::RuntimeException)
+{
+	ScDocShell* pShell = NULL;
+
+	sal_Int32 nItems = m_Areas->getCount();
+	uno::Sequence< 	table::CellRangeAddress > printAreas( nItems );
+	uno::Reference< sheet::XPrintAreas > xPrintAreas;
+	for ( sal_Int32 index=1; index <= nItems; ++index )
+	{
+		uno::Reference< excel::XRange > xRange( m_Areas->Item( uno::makeAny(index) ), uno::UNO_QUERY_THROW );
+
+		RangeHelper thisRange( xRange->getCellRange() );
+		table::CellRangeAddress rangeAddress = thisRange.getCellRangeAddressable()->getRangeAddress();
+		if ( index == 1 )
+		{
+			ScVbaRange* pRange = dynamic_cast< ScVbaRange* >( xRange.get() ); 
+			// initialise the doc shell and the printareas
+			pShell = getDocShellFromRange( pRange->mxRange );
+			xPrintAreas.set( thisRange.getSpreadSheet(), uno::UNO_QUERY_THROW );
+		}
+		printAreas[ index - 1 ] = rangeAddress;
+	}
+	if ( pShell )
+	{
+		if ( xPrintAreas.is() )
+		{
+			xPrintAreas->setPrintAreas( printAreas );
+			uno::Reference< frame::XModel > xModel = pShell->GetModel();
+			PrintOutHelper( From, To, Copies, Preview, ActivePrinter, PrintToFile, Collate, PrToFileName, xModel, sal_True );
+		}
+	}
+}
+
+void SAL_CALL
+ScVbaRange::AutoFill(  const uno::Reference< excel::XRange >& Destination, const uno::Any& Type ) throw (uno::RuntimeException) 
+{
+	uno::Reference< excel::XRange > xDest( Destination, uno::UNO_QUERY_THROW );
+	ScVbaRange* pRange = dynamic_cast< ScVbaRange* >( xDest.get() );
+	RangeHelper destRangeHelper( pRange->mxRange );
+	table::CellRangeAddress destAddress = destRangeHelper.getCellRangeAddressable()->getRangeAddress();	
+	
+	RangeHelper thisRange( mxRange );
+	table::CellRangeAddress thisAddress = thisRange.getCellRangeAddressable()->getRangeAddress();	
+	ScRange sourceRange;
+	ScRange destRange;
+
+	ScUnoConversion::FillScRange( destRange, destAddress );	
+	ScUnoConversion::FillScRange( sourceRange, thisAddress );
+	
+	
+	// source is valid
+//	if (  !sourceRange.In( destRange ) )
+//		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "source not in destination" ) ), uno::Reference< uno::XInterface >() );
+
+	FillDir eDir = FILL_TO_BOTTOM;
+	double fStep = 1.0;
+
+	ScRange aRange( destRange );
+	ScRange aSourceRange( destRange );
+
+	// default to include the number of Rows in the source range;
+	SCCOLROW nSourceCount = ( sourceRange.aEnd.Row() - sourceRange.aStart.Row() ) + 1;
+	SCCOLROW nCount = 0;	
+
+	if ( sourceRange != destRange )
+	{
+		// Find direction of fill, vertical or horizontal
+		if ( sourceRange.aStart == destRange.aStart )
+		{
+			if ( sourceRange.aEnd.Row() == destRange.aEnd.Row() )
+			{
+				nSourceCount = ( sourceRange.aEnd.Col() - sourceRange.aStart.Col() + 1 );
+				aSourceRange.aEnd.SetCol( static_cast<SCCOL>( aSourceRange.aStart.Col() + nSourceCount - 1 ) );
+				eDir = FILL_TO_RIGHT;			
+				nCount = aRange.aEnd.Col() - aSourceRange.aEnd.Col();
+			}
+			else if ( sourceRange.aEnd.Col() == destRange.aEnd.Col() )
+			{
+				aSourceRange.aEnd.SetRow( static_cast<SCROW>( aSourceRange.aStart.Row() + nSourceCount ) - 1 );
+				nCount = aRange.aEnd.Row() - aSourceRange.aEnd.Row();
+				eDir = FILL_TO_BOTTOM;
+			}
+		}
+
+		else if ( aSourceRange.aEnd == destRange.aEnd ) 
+		{
+			if ( sourceRange.aStart.Col() == destRange.aStart.Col() )
+			{
+				aSourceRange.aStart.SetRow( static_cast<SCROW>( aSourceRange.aEnd.Row() - nSourceCount + 1 ) );
+				nCount = aSourceRange.aStart.Row() - aRange.aStart.Row();
+				eDir = FILL_TO_TOP;			
+				fStep = -fStep;
+			}
+			else if ( sourceRange.aStart.Row() == destRange.aStart.Row() )
+			{
+				nSourceCount = ( sourceRange.aEnd.Col() - sourceRange.aStart.Col() ) + 1;
+				aSourceRange.aStart.SetCol( static_cast<SCCOL>( aSourceRange.aEnd.Col() - nSourceCount + 1 ) );
+				nCount = aSourceRange.aStart.Col() - aRange.aStart.Col();
+				eDir = FILL_TO_LEFT;			
+				fStep = -fStep;
+			}
+		}
+	}	
+	ScDocShell* pDocSh= getDocShellFromRange( mxRange );
+
+	FillCmd eCmd = FILL_AUTO;
+	FillDateCmd eDateCmd = FILL_DAY;	
+
+	//double fEndValue =  MAXDOUBLE;
+
+	if ( Type.hasValue() )
+	{
+		sal_Int16 nFillType = excel::XlAutoFillType::xlFillDefault; 	
+		Type >>= nFillType;
+		switch ( nFillType )
+		{
+			case excel::XlAutoFillType::xlFillCopy:
+				eCmd = 	FILL_SIMPLE;
+				fStep = 0.0;
+				break;
+			case excel::XlAutoFillType::xlFillDays:
+				eCmd = FILL_DATE;
+				break;
+			case excel::XlAutoFillType::xlFillMonths:
+				eCmd = FILL_DATE;
+				eDateCmd = FILL_MONTH;
+				break;
+			case excel::XlAutoFillType::xlFillWeekdays:
+				eCmd = FILL_DATE;
+				eDateCmd = FILL_WEEKDAY;
+				break;
+			case excel::XlAutoFillType::xlFillYears:
+				eCmd = FILL_DATE;
+				eDateCmd = FILL_YEAR;
+				break;
+			case excel::XlAutoFillType::xlGrowthTrend:
+				eCmd = FILL_GROWTH;
+				break;
+			case excel::XlAutoFillType::xlFillFormats:
+				throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "xlFillFormat not supported for AutoFill" ) ), uno::Reference< uno::XInterface >() );
+				break;
+			case excel::XlAutoFillType::xlFillValues:
+			case excel::XlAutoFillType::xlFillSeries:
+			case excel::XlAutoFillType::xlLinearTrend:
+				eCmd = FILL_LINEAR;
+				break;
+			case excel::XlAutoFillType::xlFillDefault:
+			default:
+				eCmd = 	FILL_AUTO;
+				break;
+		}	
+	}
+	ScDocFunc aFunc(*pDocSh);
+	// FOR_UPSTREAM_BUILD
+	/*aFunc.FillAuto( aSourceRange, NULL, eDir, eCmd, eDateCmd,
+								nCount, fStep, fEndValue, TRUE, TRUE );
+	*/
+}
Index: sc/source/ui/vba/vbarange.hxx
===================================================================
RCS file: sc/source/ui/vba/vbarange.hxx
diff -N sc/source/ui/vba/vbarange.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbarange.hxx	5 Mar 2007 13:52:58 -0000	1.1.2.3
@@ -0,0 +1,247 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_RANGE_HXX
+#define SC_VBA_RANGE_HXX
+
+#include <cppuhelper/implbase4.hxx>
+#include <com/sun/star/container/XEnumerationAccess.hpp>
+
+#include <org/openoffice/excel/XRange.hpp>
+#include <com/sun/star/table/XCellRange.hpp>
+#include <org/openoffice/excel/XFont.hpp>
+#include <org/openoffice/excel/XComment.hpp>
+#include <org/openoffice/vba/XCollection.hpp>
+#include <org/openoffice/excel/XlPasteType.hdl>
+#include <org/openoffice/excel/XlPasteSpecialOperation.hdl>
+
+#include <comphelper/proparrhlp.hxx>
+#include <comphelper/propertycontainer.hxx>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/beans/PropertyAttribute.hpp>
+#include <com/sun/star/script/XTypeConverter.hpp>
+#include <com/sun/star/script/XDefaultMethod.hpp>
+#include <com/sun/star/script/XDefaultProperty.hpp>
+#include <com/sun/star/sheet/FillDateMode.hpp>
+#include <com/sun/star/sheet/FillMode.hpp>
+#include <com/sun/star/sheet/FillDirection.hpp>
+#include <com/sun/star/sheet/XSpreadsheet.hpp>
+#include <com/sun/star/sheet/XSheetCellRangeContainer.hpp>
+
+#include "vbahelper.hxx"
+
+class ScTableSheetsObj;
+class ScCellRangesBase;
+typedef ::cppu::WeakImplHelper4< oo::excel::XRange, css::container::XEnumerationAccess, css::script::XDefaultMethod, css::script::XDefaultProperty > ScVbaRange_BASE;
+class ArrayVisitor
+{
+public:
+	virtual void visitNode( sal_Int32 x, sal_Int32 y, const css::uno::Reference< css::table::XCell >& xCell ) = 0;
+	virtual	~ArrayVisitor(){}
+};
+
+class ValueSetter : public ArrayVisitor
+{
+public:
+	virtual bool processValue( const css::uno::Any& aValue, const css::uno::Reference< css::table::XCell >& xCell ) = 0;
+
+
+};
+
+class ValueGetter : public ArrayVisitor
+{
+	
+public:
+	virtual void processValue( sal_Int32 x, sal_Int32 y, const css::uno::Any& aValue ) = 0;
+	virtual const css::uno::Any& getValue() const = 0;
+};
+
+
+
+class ScVbaRange : public ScVbaRange_BASE
+{
+	css::uno::Reference< oo::vba::XCollection > m_Areas;
+	css::uno::Reference< oo::vba::XCollection > m_Borders;
+	css::uno::Reference< css::table::XCellRange > mxRange;
+	css::uno::Reference< css::uno::XComponentContext > m_xContext;
+	css::uno::Reference< css::sheet::XSheetCellRangeContainer > mxRanges;
+	sal_Bool mbIsRows;
+	sal_Bool mbIsColumns;
+	css::uno::Reference< oo::excel::XValidation > m_xValidation;
+	double getCalcColWidth( const css::table::CellRangeAddress& ) throw (css::uno::RuntimeException);
+	double getCalcRowHeight( const css::table::CellRangeAddress& ) throw (css::uno::RuntimeException);
+	void visitArray( ArrayVisitor& vistor );
+	css::uno::Reference< css::script::XTypeConverter > getTypeConverter() throw (css::uno::RuntimeException);
+
+	css::uno::Reference< oo::excel::XRange > getEntireColumnOrRow( bool bColumn = true ) throw( css::uno::RuntimeException );
+
+	void fillSeries(  css::sheet::FillDirection nFillDirection, css::sheet::FillMode nFillMode, css::sheet::FillDateMode nFillDateMode, double fStep, double fEndValue ) throw( css::uno::RuntimeException );	 
+
+	void ClearContents( sal_Int32 nFlags ) throw (css::uno::RuntimeException);
+	virtual void   setValue( const css::uno::Any& aValue, ValueSetter& setter) throw ( css::uno::RuntimeException);
+	virtual css::uno::Any getValue( ValueGetter& rValueGetter ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any getFormulaValue( ScAddress::Convention ) throw (css::uno::RuntimeException);
+	virtual void   setFormulaValue( const css::uno::Any& aValue, ScAddress::Convention ) throw ( css::uno::RuntimeException);
+	css::uno::Reference< oo::excel::XRange > getArea( sal_Int32 nIndex  ) throw( css::uno::RuntimeException );
+	ScCellRangesBase* getCellRangesBase() throw ( css::uno::RuntimeException );
+	SfxItemSet* getCurrentDataSet( )  throw ( css::uno::RuntimeException );
+
+public:
+	ScVbaRange( const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::table::XCellRange >& xRange, sal_Bool bIsRows = false, sal_Bool bIsColumns = false ) throw ( css::lang::IllegalArgumentException );
+	ScVbaRange( const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::sheet::XSheetCellRangeContainer >& xRanges, sal_Bool bIsRows = false, sal_Bool bIsColumns = false ) throw ( css::lang::IllegalArgumentException );
+
+	virtual ~ScVbaRange();
+
+	bool isSingleCellRange(); 
+
+        static css::uno::Reference< css::table::XCellRange > getCellRangeForName( const rtl::OUString& sRangeName, const css::uno::Reference< css::sheet::XSpreadsheet >& xDoc, ScAddress::Convention eConv = ScAddress::CONV_XL_A1 );
+    // Attributes
+	virtual css::uno::Any SAL_CALL getValue() throw (css::uno::RuntimeException);
+	virtual void   SAL_CALL setValue( const css::uno::Any& aValue ) throw ( css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL getFormula() throw (css::uno::RuntimeException);
+	virtual void   SAL_CALL setFormula( const css::uno::Any& rFormula ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL getFormulaArray() throw (css::uno::RuntimeException);
+	virtual void   SAL_CALL setFormulaArray(const css::uno::Any& rFormula) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL getFormulaR1C1() throw (css::uno::RuntimeException);
+	virtual void   SAL_CALL setFormulaR1C1( const css::uno::Any &rFormula ) throw (css::uno::RuntimeException);
+	virtual double SAL_CALL getCount() throw (css::uno::RuntimeException);
+	virtual ::sal_Int32 SAL_CALL getRow() throw (css::uno::RuntimeException);
+	virtual ::sal_Int32 SAL_CALL getColumn() throw (css::uno::RuntimeException);
+	virtual ::rtl::OUString SAL_CALL getText() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setNumberFormat( const css::uno::Any& rNumberFormat ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL getNumberFormat() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setMergeCells( sal_Bool bMerge ) throw (css::uno::RuntimeException);
+	virtual sal_Bool SAL_CALL getMergeCells() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setWrapText( const css::uno::Any& bIsWrapped ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL getWrapText() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< oo::excel::XRange > SAL_CALL getEntireRow() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< oo::excel::XRange > SAL_CALL getEntireColumn() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< oo::excel::XComment > SAL_CALL getComment() throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL getHidden() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setHidden( const css::uno::Any& _hidden ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL getColumnWidth() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setColumnWidth( const css::uno::Any& _columnwidth ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL getRowHeight() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setRowHeight( const css::uno::Any& _rowheight ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL getWidth() throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL getHeight() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< oo::excel::XWorksheet > SAL_CALL getWorksheet() throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL getPageBreak() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setPageBreak( const css::uno::Any& _pagebreak ) throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< oo::excel::XValidation > SAL_CALL getValidation() throw (css::uno::RuntimeException);
+
+	// Methods
+	sal_Bool IsRows() { return mbIsRows; }
+	sal_Bool IsColumns() { return mbIsColumns; }
+	virtual css::uno::Reference< oo::excel::XComment > SAL_CALL AddComment( const css::uno::Any& Text ) throw (css::uno::RuntimeException);
+	virtual void SAL_CALL Clear() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL ClearComments() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL ClearContents() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL ClearFormats() throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL HasFormula() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL FillLeft() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL FillRight() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL FillUp() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL FillDown() throw (css::uno::RuntimeException);
+	virtual	css::uno::Reference< oo::excel::XRange > SAL_CALL Offset( const css::uno::Any &nRowOffset, const css::uno::Any &nColOffset )
+														   throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< oo::excel::XRange > SAL_CALL CurrentRegion() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< oo::excel::XRange > SAL_CALL CurrentArray() throw (css::uno::RuntimeException);
+	virtual ::rtl::OUString SAL_CALL Characters( const css::uno::Any& nIndex, const css::uno::Any& nCount ) 
+												 throw (css::uno::RuntimeException);
+
+	virtual ::rtl::OUString SAL_CALL Address( const css::uno::Any& RowAbsolute, const css::uno::Any& ColumnAbsolute, const css::uno::Any& ReferenceStyle, const css::uno::Any& External, const css::uno::Any& RelativeTo ) throw (css::uno::RuntimeException);
+
+	virtual css::uno::Reference< oo::excel::XRange > SAL_CALL Cells( const css::uno::Any &nRow, const css::uno::Any &nCol ) 
+														  throw (css::uno::RuntimeException);
+	virtual void SAL_CALL Select() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL Activate() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< oo::excel::XRange >  SAL_CALL Rows( const css::uno::Any& nIndex ) throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< oo::excel::XRange >  SAL_CALL Columns( const css::uno::Any &nIndex ) throw (css::uno::RuntimeException);
+	virtual void SAL_CALL Copy( const css::uno::Any& Destination ) throw (css::uno::RuntimeException);
+	virtual void SAL_CALL Cut( const css::uno::Any& Destination ) throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< oo::excel::XRange > SAL_CALL Resize( const css::uno::Any& RowSize, const css::uno::Any& ColumnSize ) 
+														   throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< oo::excel::XFont > SAL_CALL Font() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< oo::excel::XInterior > SAL_CALL Interior(  ) throw (css::uno::RuntimeException) ;
+	virtual css::uno::Reference< oo::excel::XRange > SAL_CALL Range( const css::uno::Any &Cell1, const css::uno::Any &Cell2 ) throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< oo::excel::XRange > Range( const css::uno::Any &Cell1, const css::uno::Any &Cell2, bool bForceUseInpuRangeTab ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL getCellRange(  ) throw (css::uno::RuntimeException);
+	virtual void SAL_CALL PasteSpecial( const css::uno::Any& Paste, const css::uno::Any& Operation, const css::uno::Any& SkipBlanks, const css::uno::Any& Transpose ) throw (css::uno::RuntimeException);
+	virtual ::sal_Bool SAL_CALL Replace( const ::rtl::OUString& What, const ::rtl::OUString& Replacement, const css::uno::Any& LookAt, const css::uno::Any& SearchOrder, const css::uno::Any& MatchCase, const css::uno::Any& MatchByte, const css::uno::Any& SearchFormat, const css::uno::Any& ReplaceFormat ) throw (css::uno::RuntimeException);
+	virtual void SAL_CALL Sort( const css::uno::Any& Key1, const css::uno::Any& Order1, const css::uno::Any& Key2, const css::uno::Any& Type, const css::uno::Any& Order2, const css::uno::Any& Key3, const css::uno::Any& Order3, const css::uno::Any& Header, const css::uno::Any& OrderCustom, const css::uno::Any& MatchCase, const css::uno::Any& Orientation, const css::uno::Any& SortMethod,  const css::uno::Any& DataOption1, const css::uno::Any& DataOption2, const css::uno::Any& DataOption3 ) throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< oo::excel::XRange > SAL_CALL End( ::sal_Int32 Direction )  throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< oo::excel::XCharacters > SAL_CALL characters( const css::uno::Any& Start, const css::uno::Any& Length ) throw (css::uno::RuntimeException);
+	virtual void SAL_CALL Delete( const css::uno::Any& Shift ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL Areas( const css::uno::Any& ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL Borders( const css::uno::Any& ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL BorderAround( const css::uno::Any& LineStyle, 
+                const css::uno::Any& Weight, const css::uno::Any& ColorIndex, const css::uno::Any& Color ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL TextToColumns( const css::uno::Any& Destination, const css::uno::Any& DataType, const css::uno::Any& TextQualifier,
+                const css::uno::Any& ConsecutinveDelimiter, const css::uno::Any& Tab, const css::uno::Any& Semicolon, const css::uno::Any& Comma, 
+                const css::uno::Any& Space, const css::uno::Any& Other, const css::uno::Any& OtherChar, const css::uno::Any& FieldInfo,
+                const css::uno::Any& DecimalSeparator, const css::uno::Any& ThousandsSeparator, const css::uno::Any& TrailingMinusNumbers ) throw (css::uno::RuntimeException);
+
+	virtual void SAL_CALL AutoFilter( const css::uno::Any& Field, const css::uno::Any& Criteria1, const css::uno::Any& Operator, const css::uno::Any& Criteria2, const css::uno::Any& VisibleDropDown ) throw (css::uno::RuntimeException);
+	virtual void SAL_CALL Insert( const css::uno::Any& Shift, const css::uno::Any& CopyOrigin ) throw (css::uno::RuntimeException);
+	virtual void SAL_CALL Autofit() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL PrintOut( const css::uno::Any& From, const css::uno::Any& To, const css::uno::Any& Copies, const css::uno::Any& Preview, const css::uno::Any& ActivePrinter, const css::uno::Any& PrintToFile, const css::uno::Any& Collate, const css::uno::Any& PrToFileName ) throw (css::uno::RuntimeException);
+	virtual void SAL_CALL AutoFill( const css::uno::Reference< oo::excel::XRange >& Destination, const css::uno::Any& Type ) throw (css::uno::RuntimeException) ;
+	// XEnumerationAccess
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+	// XElementAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException)
+	{
+		return oo::excel::XRange::static_type(0);
+
+	}
+	virtual sal_Bool SAL_CALL hasElements() throw (css::uno::RuntimeException);
+	// XDefaultMethod
+	::rtl::OUString SAL_CALL getDefaultMethodName(  ) throw (css::uno::RuntimeException);
+        // XDefaultProperty
+        ::rtl::OUString SAL_CALL getDefaultPropertyName(  ) throw (css::uno::RuntimeException) { return ::rtl::OUString::createFromAscii("Value"); }
+
+
+// #TODO completely rewrite ScVbaRange, its become a hackfest
+// it needs to be closer to ScCellRangeBase in that the underlying
+// object model should probably be a ScRangelst. 
+//     * would be nice to be able to construct a range from an addres only
+//     * or a list of address ( multi-area )
+//     * object should be a lightweight as possible
+//     * we shouldn't need hacks like this below
+	static css::uno::Reference< oo::excel::XRange > ApplicationRange( const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Any &Cell1, const css::uno::Any &Cell2 ) throw (css::uno::RuntimeException);
+};
+#endif /* SC_VBA_RANGE_HXX */
+
Index: sc/source/ui/vba/vbaseriescollection.cxx
===================================================================
RCS file: sc/source/ui/vba/vbaseriescollection.cxx
diff -N sc/source/ui/vba/vbaseriescollection.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbaseriescollection.cxx	21 Feb 2007 17:29:22 -0000	1.1.2.2
@@ -0,0 +1,108 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbaseriescollection.hxx"
+#include <org/openoffice/excel/XSeries.hpp>
+
+#include "vbaglobals.hxx"
+
+using namespace ::com::sun::star;
+using namespace ::org::openoffice;
+
+uno::Reference< oo::excel::XApplication > 
+ScVbaSeriesCollection::getApplication() throw (uno::RuntimeException)
+{
+	return ScVbaGlobals::getGlobalsImpl( m_xContext )->getApplication();
+}
+::sal_Int32
+ScVbaSeriesCollection::getCount() throw (uno::RuntimeException)
+{
+	return 0;
+}
+
+uno::Any
+ScVbaSeriesCollection::Item( const uno::Any& /*aIndex*/ ) throw (uno::RuntimeException)
+{
+	// #TODO #FIXME some implementation would be nice !!
+	return uno::Any();
+}
+
+// XEnumerationAccess
+
+uno::Reference< container::XEnumeration >
+ScVbaSeriesCollection::createEnumeration() throw (uno::RuntimeException)
+{
+	uno::Reference< container::XEnumeration > xEnum;
+	return xEnum;
+}
+
+// XElementAccess
+
+uno::Type 
+ScVbaSeriesCollection::getElementType() throw (uno::RuntimeException)
+{
+	return excel::XSeries::static_type(0);
+}
+::sal_Bool
+ScVbaSeriesCollection::hasElements() throw (uno::RuntimeException)
+{
+	// #TODO #TOFIX Really?, how can we say that!
+	// needs to delegate to xIndex
+	return sal_True;
+}
+
+uno::Any SAL_CALL 
+ScVbaSeriesCollection::getParent() throw (uno::RuntimeException)
+{
+	uno::Reference< excel::XApplication > xApplication =
+		getApplication();
+	uno::Reference< excel::XWorkbook > xWorkbook;
+	if ( xApplication.is() )
+	{
+		xWorkbook = xApplication->getActiveWorkbook();
+	}
+	return uno::Any( xWorkbook );
+}
+
+sal_Int32 SAL_CALL 
+ScVbaSeriesCollection::getCreator() throw (uno::RuntimeException)
+{
+	// #TODO# #FIXME# implementation?
+	return 0;
+}
+
+
+
+
+
Index: sc/source/ui/vba/vbaseriescollection.hxx
===================================================================
RCS file: sc/source/ui/vba/vbaseriescollection.hxx
diff -N sc/source/ui/vba/vbaseriescollection.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbaseriescollection.hxx	21 Feb 2007 17:29:22 -0000	1.1.2.2
@@ -0,0 +1,67 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_SERIESCOLLECTION_HXX
+#define SC_VBA_SERIESCOLLECTION_HXX
+#include <org/openoffice/excel/XSeriesCollection.hpp>
+#include <cppuhelper/implbase2.hxx>
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <com/sun/star/container/XEnumerationAccess.hpp>
+
+#include "vbahelper.hxx"
+
+typedef ::cppu::WeakImplHelper2<oo::excel::XSeriesCollection,
+css::container::XEnumerationAccess > SeriesCollectionImpl_BASE;
+
+class ScVbaSeriesCollection : public SeriesCollectionImpl_BASE
+{		
+
+	css::uno::Reference< css::uno::XComponentContext > m_xContext;
+public:
+	ScVbaSeriesCollection( const css::uno::Reference< css::uno::XComponentContext >& xContext ) : m_xContext(xContext) {}
+	//XCollection
+	virtual ::sal_Int32 SAL_CALL getCount() throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL getParent() throw (css::uno::RuntimeException);
+	virtual ::sal_Int32 SAL_CALL getCreator() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< oo::excel::XApplication > SAL_CALL getApplication() throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL Item( const css::uno::Any& Index ) throw (css::uno::RuntimeException);
+
+	// XEnumerationAccess
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);	
+	// XElementAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	virtual ::sal_Bool SAL_CALL hasElements() throw (css::uno::RuntimeException);
+};
+
+#endif //SC_VBA_WINDOW_HXX
Index: sc/source/ui/vba/vbavalidation.cxx
===================================================================
RCS file: sc/source/ui/vba/vbavalidation.cxx
diff -N sc/source/ui/vba/vbavalidation.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbavalidation.cxx	27 Feb 2007 22:37:53 -0000	1.1.2.3
@@ -0,0 +1,319 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbavalidation.hxx"
+#include <com/sun/star/sheet/XSheetCondition.hpp>
+#include <com/sun/star/sheet/ValidationType.hpp>
+#include <com/sun/star/sheet/ValidationAlertStyle.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <org/openoffice/excel/XlDVType.hpp>
+#include <org/openoffice/excel/XlFormatConditionOperator.hpp>
+#include <org/openoffice/excel/XlDVAlertStyle.hpp>
+
+#include "unonames.hxx"
+
+using namespace ::org::openoffice;
+using namespace ::com::sun::star;
+
+const static rtl::OUString VALIDATION( RTL_CONSTASCII_USTRINGPARAM( SC_UNONAME_VALIDAT ) );
+const static rtl::OUString IGNOREBLANK( RTL_CONSTASCII_USTRINGPARAM( SC_UNONAME_IGNOREBL ) );
+const static rtl::OUString SHOWINPUT( RTL_CONSTASCII_USTRINGPARAM( SC_UNONAME_SHOWINP  ) );
+const static rtl::OUString SHOWERROR( RTL_CONSTASCII_USTRINGPARAM( SC_UNONAME_SHOWERR  ) );
+const static rtl::OUString ERRORTITLE( RTL_CONSTASCII_USTRINGPARAM(  SC_UNONAME_ERRTITLE  ) );
+const static rtl::OUString INPUTTITLE( RTL_CONSTASCII_USTRINGPARAM(  SC_UNONAME_INPTITLE  ) );
+const static rtl::OUString INPUTMESS( RTL_CONSTASCII_USTRINGPARAM(  SC_UNONAME_INPMESS  ) );
+const static rtl::OUString ERRORMESS( RTL_CONSTASCII_USTRINGPARAM(  SC_UNONAME_ERRMESS  ) );
+const static rtl::OUString STYPE( RTL_CONSTASCII_USTRINGPARAM(  SC_UNONAME_TYPE  ) );
+const static rtl::OUString SHOWLIST( RTL_CONSTASCII_USTRINGPARAM(  SC_UNONAME_SHOWLIST  ) );
+const static rtl::OUString ALERTSTYLE( RTL_CONSTASCII_USTRINGPARAM(  SC_UNONAME_ERRALSTY  ) );
+
+void
+lcl_setValidationProps( const uno::Reference< table::XCellRange >& xRange, const uno::Reference< beans::XPropertySet >& xProps )
+{
+	uno::Reference< beans::XPropertySet > xRangeProps( xRange, uno::UNO_QUERY_THROW );
+	xRangeProps->setPropertyValue( VALIDATION , uno::makeAny( xProps ) );
+}
+
+uno::Reference< beans::XPropertySet >
+lcl_getValidationProps( const uno::Reference< table::XCellRange >& xRange )
+{
+	uno::Reference< beans::XPropertySet > xProps( xRange, uno::UNO_QUERY_THROW );
+	uno::Reference< beans::XPropertySet > xValProps;
+	xValProps.set( xProps->getPropertyValue( VALIDATION ), uno::UNO_QUERY_THROW );
+	return xValProps;
+}
+
+::sal_Bool SAL_CALL 
+ScVbaValidation::getIgnoreBlank() throw (uno::RuntimeException)
+{
+	uno::Reference< beans::XPropertySet > xProps( lcl_getValidationProps( m_xRange ) );
+	sal_Bool bBlank = sal_False;
+	xProps->getPropertyValue( IGNOREBLANK )  >>= bBlank;
+	return bBlank;
+}
+
+void SAL_CALL 
+ScVbaValidation::setIgnoreBlank( ::sal_Bool _ignoreblank ) throw (uno::RuntimeException)
+{
+	uno::Reference< beans::XPropertySet > xProps( lcl_getValidationProps( m_xRange ) );
+	xProps->setPropertyValue( IGNOREBLANK, uno::makeAny( _ignoreblank ) ); 
+	lcl_setValidationProps( m_xRange, xProps );	
+}
+
+::sal_Bool SAL_CALL 
+ScVbaValidation::getInCellDropdown() throw (uno::RuntimeException)
+{
+	uno::Reference< beans::XPropertySet > xProps = lcl_getValidationProps( m_xRange );
+	sal_Int32 nShowList = 0;
+	xProps->getPropertyValue( SHOWLIST )  >>= nShowList;	
+	return ( nShowList ? sal_True : sal_False );
+}
+
+void SAL_CALL 
+ScVbaValidation::setInCellDropdown( ::sal_Bool  _incelldropdown  ) throw (uno::RuntimeException)
+{
+	sal_Int32 nDropDown = sal_False;
+	if ( _incelldropdown )
+		nDropDown = 1;
+	uno::Reference< beans::XPropertySet > xProps( lcl_getValidationProps(m_xRange) );
+	xProps->setPropertyValue( SHOWLIST, uno::makeAny( nDropDown ) ); 
+	lcl_setValidationProps( m_xRange, xProps );
+}
+
+::sal_Bool SAL_CALL 
+ScVbaValidation::getShowInput() throw (uno::RuntimeException)
+{
+	uno::Reference< beans::XPropertySet > xProps = lcl_getValidationProps( m_xRange );
+	sal_Bool bShowInput = sal_False;
+	xProps->getPropertyValue( SHOWINPUT )  >>= bShowInput;	
+	return bShowInput;
+}
+
+void SAL_CALL 
+ScVbaValidation:: setShowInput( ::sal_Bool _showinput ) throw (uno::RuntimeException)
+{
+	uno::Reference< beans::XPropertySet > xProps( lcl_getValidationProps(m_xRange) );
+	xProps->setPropertyValue( IGNOREBLANK, uno::makeAny( _showinput ) ); 
+	lcl_setValidationProps( m_xRange, xProps );
+}
+
+::sal_Bool SAL_CALL 
+ScVbaValidation::getShowError() throw (uno::RuntimeException)
+{
+	uno::Reference< beans::XPropertySet > xProps = lcl_getValidationProps( m_xRange );
+	sal_Bool bShowError = sal_False;
+	xProps->getPropertyValue( SHOWERROR )  >>= bShowError;	
+	return bShowError;
+}
+
+void SAL_CALL 
+ScVbaValidation::setShowError( ::sal_Bool _showerror ) throw (uno::RuntimeException)
+{
+	uno::Reference< beans::XPropertySet > xProps( lcl_getValidationProps( m_xRange ) );
+	xProps->setPropertyValue( SHOWERROR, uno::makeAny( _showerror ) ); 
+	lcl_setValidationProps( m_xRange, xProps );
+}
+
+::rtl::OUString SAL_CALL 
+ScVbaValidation::getErrorTitle() throw (uno::RuntimeException)
+{
+	uno::Reference< beans::XPropertySet > xProps = lcl_getValidationProps( m_xRange );
+	rtl::OUString sErrorTitle;
+	xProps->getPropertyValue( ERRORTITLE )  >>= sErrorTitle;		
+	return sErrorTitle;
+}
+
+void
+ScVbaValidation::setErrorTitle( const rtl::OUString& _errormessage ) throw (uno::RuntimeException)
+{
+	uno::Reference< beans::XPropertySet > xProps( lcl_getValidationProps( m_xRange ) );
+	xProps->setPropertyValue( ERRORTITLE, uno::makeAny( _errormessage ) ); 
+	lcl_setValidationProps( m_xRange, xProps );
+}
+
+::rtl::OUString SAL_CALL 
+ScVbaValidation::getInputMessage() throw (uno::RuntimeException)
+{
+	uno::Reference< beans::XPropertySet > xProps = lcl_getValidationProps( m_xRange );
+	rtl::OUString sMsg;
+	xProps->getPropertyValue( INPUTMESS )  >>= sMsg;		
+	return sMsg;
+}
+
+void SAL_CALL 
+ScVbaValidation::setInputMessage( const ::rtl::OUString& _inputmessage ) throw (uno::RuntimeException)
+{
+	uno::Reference< beans::XPropertySet > xProps( lcl_getValidationProps( m_xRange ) );
+	xProps->setPropertyValue( INPUTMESS, uno::makeAny( _inputmessage ) ); 
+	lcl_setValidationProps( m_xRange, xProps );
+}
+
+::rtl::OUString SAL_CALL 
+ScVbaValidation::getInputTitle() throw (uno::RuntimeException)
+{
+	uno::Reference< beans::XPropertySet > xProps = lcl_getValidationProps( m_xRange );
+	rtl::OUString sString;
+	xProps->getPropertyValue( INPUTTITLE )  >>= sString;		
+	return sString;
+}
+
+void SAL_CALL 
+ScVbaValidation::setInputTitle( const ::rtl::OUString& _inputtitle ) throw (uno::RuntimeException)
+{
+	uno::Reference< beans::XPropertySet > xProps( lcl_getValidationProps( m_xRange ) );
+	xProps->setPropertyValue( INPUTTITLE, uno::makeAny( _inputtitle ) ); 
+	lcl_setValidationProps( m_xRange, xProps );
+}
+
+::rtl::OUString SAL_CALL 
+ScVbaValidation::getErrorMessage() throw (uno::RuntimeException)
+{
+	uno::Reference< beans::XPropertySet > xProps = lcl_getValidationProps( m_xRange );
+	rtl::OUString sString;
+	xProps->getPropertyValue( ERRORMESS )  >>= sString;		
+	return sString;
+}
+
+void SAL_CALL 
+ScVbaValidation::setErrorMessage( const ::rtl::OUString& _errormessage ) throw (uno::RuntimeException)
+{
+	uno::Reference< beans::XPropertySet > xProps( lcl_getValidationProps( m_xRange ) );
+	xProps->setPropertyValue( ERRORMESS, uno::makeAny( _errormessage ) ); 
+	lcl_setValidationProps( m_xRange, xProps );
+}
+
+
+void SAL_CALL 
+ScVbaValidation::Delete(  ) throw (uno::RuntimeException)
+{
+	rtl::OUString sBlank;
+	uno::Reference< beans::XPropertySet > xProps( lcl_getValidationProps( m_xRange ) );
+	uno::Reference< sheet::XSheetCondition > xCond( xProps, uno::UNO_QUERY_THROW );
+	xProps->setPropertyValue( IGNOREBLANK, uno::makeAny( sal_True ) );
+	xProps->setPropertyValue( SHOWINPUT, uno::makeAny( sal_True ) );
+	xProps->setPropertyValue( SHOWERROR, uno::makeAny( sal_True ) );
+	xProps->setPropertyValue( ERRORTITLE, uno::makeAny( sBlank ) );
+	xProps->setPropertyValue( INPUTMESS, uno::makeAny( sBlank) );
+	xProps->setPropertyValue( ALERTSTYLE, uno::makeAny( sheet::ValidationAlertStyle_STOP) );
+	xProps->setPropertyValue( STYPE, uno::makeAny( sheet::ValidationType_ANY ) ); 
+	xCond->setFormula1( sBlank );
+	xCond->setFormula2( sBlank );
+	xCond->setOperator( sheet::ConditionOperator_NONE );
+
+	lcl_setValidationProps( m_xRange, xProps );
+}
+void SAL_CALL 
+ScVbaValidation::Add( const uno::Any& Type, const uno::Any& AlertStyle, const uno::Any& /*Operator*/, const uno::Any& Formula1, const uno::Any& Formula2 ) throw (uno::RuntimeException)
+{
+	uno::Reference< beans::XPropertySet > xProps( lcl_getValidationProps( m_xRange ) );
+	uno::Reference< sheet::XSheetCondition > xCond( xProps, uno::UNO_QUERY_THROW );
+	
+	sheet::ValidationType nValType = sheet::ValidationType_ANY;
+	xProps->getPropertyValue( STYPE )  >>= nValType;
+	if ( nValType  != sheet::ValidationType_ANY  )
+		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "validation object already exists" ) ), uno::Reference< uno::XInterface >() );
+	sal_Int32 nType = -1;
+	if ( !Type.hasValue()  || !( Type >>= nType ) )
+		throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "missing required param" ) ), uno::Reference< uno::XInterface >() );
+
+	Delete(); // set up defaults	
+	rtl::OUString sFormula1;
+	Formula1 >>= sFormula1;
+	rtl::OUString sFormula2;
+	Formula2 >>= sFormula2;
+	switch ( nType )
+	{
+		case excel::XlDVType::xlValidateList:
+			{
+				// for validate list 
+				// at least formula1 is required
+				if ( !Formula1.hasValue() )
+					throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "missing param" ) ), uno::Reference< uno::XInterface >() );
+				nValType = sheet::ValidationType_LIST;
+				xProps->setPropertyValue( STYPE, uno::makeAny(nValType ));	
+				// #TODO validate required params
+				// #TODO need to correct the ';' delimited formula on get/set
+				break;
+			}
+		default:
+			throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "unsupported operation..." ) ), uno::Reference< uno::XInterface >() );
+	}
+
+	sheet::ValidationAlertStyle eStyle = sheet::ValidationAlertStyle_STOP;	
+	sal_Int32 nVbaAlertStyle = excel::XlDVAlertStyle::xlValidAlertStop;
+	if ( AlertStyle.hasValue() && ( AlertStyle >>= nVbaAlertStyle ) )
+	{
+		switch( nVbaAlertStyle )
+		{
+			case excel::XlDVAlertStyle::xlValidAlertStop:
+				// yes I know it's already defaulted but safer to assume
+				// someone propbably could change the code above
+				eStyle = sheet::ValidationAlertStyle_STOP; 
+				break;	
+			case excel::XlDVAlertStyle::xlValidAlertWarning:
+				eStyle = sheet::ValidationAlertStyle_WARNING; 
+				break;	
+			case excel::XlDVAlertStyle::xlValidAlertInformation:
+				eStyle = sheet::ValidationAlertStyle_INFO; 
+				break;	
+			default:
+			throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "bad param..." ) ), uno::Reference< uno::XInterface >() );
+
+		}		
+	}
+
+	xProps->setPropertyValue( ALERTSTYLE, uno::makeAny( eStyle ) );
+
+	if ( sFormula1.getLength() )
+		xCond->setFormula1( sFormula1 );
+	if ( sFormula2.getLength() )
+		xCond->setFormula2( sFormula2 );
+		
+	lcl_setValidationProps( m_xRange, xProps );	
+}
+
+::rtl::OUString SAL_CALL 
+ScVbaValidation::getFormula1() throw (uno::RuntimeException)
+{
+	uno::Reference< sheet::XSheetCondition > xCond( lcl_getValidationProps( m_xRange ), uno::UNO_QUERY_THROW );
+	return xCond->getFormula1();
+}
+
+::rtl::OUString SAL_CALL 
+ScVbaValidation::getFormula2() throw (uno::RuntimeException)
+{
+		uno::Reference< sheet::XSheetCondition > xCond( lcl_getValidationProps( m_xRange ), uno::UNO_QUERY_THROW );
+	return xCond->getFormula2();
+}
+
Index: sc/source/ui/vba/vbavalidation.hxx
===================================================================
RCS file: sc/source/ui/vba/vbavalidation.hxx
diff -N sc/source/ui/vba/vbavalidation.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbavalidation.hxx	21 Feb 2007 17:29:23 -0000	1.1.2.2
@@ -0,0 +1,77 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_VALIDATION_HXX
+#define SC_VBA_VALIDATION_HXX
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <org/openoffice/excel/XValidation.hpp>
+#include <com/sun/star/table/XCellRange.hpp>
+#include "vbahelper.hxx"
+
+typedef ::cppu::WeakImplHelper1<oo::excel::XValidation > ValidationImpl_BASE;
+
+class ScVbaValidation : public ValidationImpl_BASE
+{		
+	css::uno::Reference< css::uno::XComponentContext > m_xContext;
+	css::uno::Reference< css::table::XCellRange > m_xRange;
+	
+public:
+	ScVbaValidation( const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::table::XCellRange >& xRange ) : m_xContext(xContext), m_xRange( xRange) {}
+    // Attributes
+    virtual ::sal_Bool SAL_CALL getIgnoreBlank() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setIgnoreBlank( ::sal_Bool _ignoreblank ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getInCellDropdown() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setInCellDropdown( ::sal_Bool _incelldropdown ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getShowInput() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setShowInput( ::sal_Bool _showinput ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL getShowError() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setShowError( ::sal_Bool _showerror ) throw (css::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getInputTitle() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setInputTitle( const ::rtl::OUString& _inputtitle ) throw (css::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getErrorTitle() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setErrorTitle( const ::rtl::OUString& _errortitle ) throw (css::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getInputMessage() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setInputMessage( const ::rtl::OUString& _inputmessage ) throw (css::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getErrorMessage() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setErrorMessage( const ::rtl::OUString& _errormessage ) throw (css::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getFormula1() throw (css::uno::RuntimeException) ;
+    virtual ::rtl::OUString SAL_CALL getFormula2() throw (css::uno::RuntimeException);
+    // Methods
+    virtual void SAL_CALL Delete(  ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL Add( const css::uno::Any& Type, const css::uno::Any& AlertStyle, const css::uno::Any& Operator, const css::uno::Any& Formula1, const css::uno::Any& Formula2 ) throw (css::uno::RuntimeException);
+
+};
+
+#endif 
Index: sc/source/ui/vba/vbawindow.cxx
===================================================================
RCS file: sc/source/ui/vba/vbawindow.cxx
diff -N sc/source/ui/vba/vbawindow.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbawindow.cxx	21 Feb 2007 17:29:23 -0000	1.1.2.2
@@ -0,0 +1,463 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbawindow.hxx"
+#include "vbaworksheets.hxx"
+#include "vbaworksheet.hxx"
+#include <com/sun/star/sheet/XSpreadsheetDocument.hpp>
+#include <com/sun/star/sheet/XSpreadsheet.hpp>
+#include <com/sun/star/container/XNamed.hpp>
+#include <org/openoffice/excel/XlWindowState.hpp>
+#include <org/openoffice/excel/Constants.hpp>
+
+#include <docsh.hxx>
+#include <tabvwsh.hxx>
+#include <docuno.hxx>
+#include <sc.hrc>
+#include <hash_map>
+#include <sfx2/viewfrm.hxx>
+#include <sfx2/topfrm.hxx>
+
+using namespace ::com::sun::star;
+using namespace ::org::openoffice;
+using namespace ::org::openoffice::excel::XlWindowState;
+
+typedef  std::hash_map< rtl::OUString,
+SCTAB, ::rtl::OUStringHash,
+::std::equal_to< ::rtl::OUString > > NameIndexHash;
+
+typedef std::vector < uno::Reference< sheet::XSpreadsheet > > Sheets;
+
+typedef ::cppu::WeakImplHelper1< container::XEnumeration
+
+> Enumeration_BASE;
+
+typedef ::cppu::WeakImplHelper3< container::XEnumerationAccess 
+	, com::sun::star::container::XIndexAccess
+	, com::sun::star::container::XNameAccess
+	> SelectedSheets_BASE;
+
+
+class SelectedSheetsEnum : public Enumeration_BASE
+{
+public:
+	uno::Reference< uno::XComponentContext > m_xContext;
+	Sheets m_sheets;
+	uno::Reference< frame::XModel > m_xModel;
+	Sheets::const_iterator m_it;
+
+	SelectedSheetsEnum( const uno::Reference< uno::XComponentContext >& xContext, const Sheets& sheets, const uno::Reference< frame::XModel >& xModel ) throw ( uno::RuntimeException ) :  m_xContext( xContext ), m_sheets( sheets ), m_xModel( xModel )
+	{
+		m_it = m_sheets.begin();
+	}
+	// XEnumeration
+	virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException) 
+	{ 
+		return m_it != m_sheets.end();
+	}
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException) 
+	{ 
+		if ( !hasMoreElements() )
+		{
+			throw container::NoSuchElementException();
+		}
+		return uno::makeAny( uno::Reference< excel::XWorksheet > ( new ScVbaWorksheet( m_xContext, *(m_it++), m_xModel ) ) );
+	}
+
+
+};
+
+class SelectedSheetsEnumAccess : public SelectedSheets_BASE
+{
+	uno::Reference< uno::XComponentContext > m_xContext;
+	NameIndexHash namesToIndices;
+	Sheets sheets;
+	uno::Reference< frame::XModel > m_xModel; 
+public:
+	SelectedSheetsEnumAccess( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< frame::XModel >& xModel ):m_xContext( xContext ), m_xModel( xModel )
+	{
+		ScModelObj* pModel = static_cast< ScModelObj* >( m_xModel.get() );
+		if ( !pModel )
+			throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Cannot obtain current document" ) ), uno::Reference< uno::XInterface >() );
+		ScDocShell* pDocShell = (ScDocShell*)pModel->GetEmbeddedObject();
+		if ( !pDocShell )
+			throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Cannot obtain docshell" ) ), uno::Reference< uno::XInterface >() );
+		ScTabViewShell* pViewShell = getBestViewShell( m_xModel );
+		if ( !pViewShell )
+			throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Cannot obtain view shell" ) ), uno::Reference< uno::XInterface >() );
+			
+		SCTAB nTabCount = pDocShell->GetDocument()->GetTableCount();
+		uno::Sequence<sal_Int32> aSheets( nTabCount );
+		SCTAB nIndex = 0;
+		const ScMarkData& rMarkData = pViewShell->GetViewData()->GetMarkData();
+		sheets.reserve( nTabCount );
+		uno::Reference <sheet::XSpreadsheetDocument> xSpreadSheet( m_xModel, uno::UNO_QUERY_THROW );
+		uno::Reference <container::XIndexAccess> xIndex( xSpreadSheet->getSheets(), uno::UNO_QUERY_THROW );
+		for ( SCTAB nTab=0; nTab<nTabCount; nTab++ )
+		{
+			if ( rMarkData.GetTableSelect(nTab) )
+			{
+				uno::Reference< sheet::XSpreadsheet > xSheet( xIndex->getByIndex( nTab ), uno::UNO_QUERY_THROW );
+				uno::Reference< container::XNamed > xNamed( xSheet, uno::UNO_QUERY_THROW );
+				sheets.push_back( xSheet );
+				namesToIndices[ xNamed->getName() ] = nIndex++;
+			}
+		}
+
+	}
+	
+	//XEnumerationAccess
+	virtual uno::Reference< container::XEnumeration > SAL_CALL createEnumeration(  ) throw (uno::RuntimeException)
+	{
+		return new SelectedSheetsEnum( m_xContext, sheets, m_xModel  ); 
+	}
+	// XIndexAccess
+	virtual ::sal_Int32 SAL_CALL getCount(  ) throw (uno::RuntimeException) 
+	{ 
+		return sheets.size();
+	}
+	virtual uno::Any SAL_CALL getByIndex( ::sal_Int32 Index ) throw ( lang::IndexOutOfBoundsException, lang::WrappedTargetException, uno::RuntimeException) 
+	{ 
+		if ( Index < 0
+		|| static_cast< Sheets::size_type >( Index ) >= sheets.size() ) 
+			throw lang::IndexOutOfBoundsException();
+		
+		return uno::makeAny( sheets[ Index ] );
+	}
+
+	//XElementAccess
+	virtual uno::Type SAL_CALL getElementType(  ) throw (uno::RuntimeException)
+	{ 
+		return excel::XWorksheet::static_type(0); 
+	}
+
+	virtual ::sal_Bool SAL_CALL hasElements(  ) throw (uno::RuntimeException) 
+	{ 
+		return (sheets.size() > 0);
+	}
+
+	//XNameAccess
+	virtual uno::Any SAL_CALL getByName( const ::rtl::OUString& aName ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException) 
+	{ 
+		NameIndexHash::const_iterator it = namesToIndices.find( aName );
+		if ( it == namesToIndices.end() )
+			throw container::NoSuchElementException();
+		return uno::makeAny( sheets[ it->second ] );
+		
+	}
+
+	virtual uno::Sequence< ::rtl::OUString > SAL_CALL getElementNames(  ) throw (uno::RuntimeException) 
+	{ 
+		uno::Sequence< ::rtl::OUString > names( namesToIndices.size() );
+		::rtl::OUString* pString = names.getArray();
+		NameIndexHash::const_iterator it = namesToIndices.begin();
+		NameIndexHash::const_iterator it_end = namesToIndices.end();
+		for ( ; it != it_end; ++it, ++pString )
+			*pString = it->first;	
+		return names;	
+	}
+
+	virtual ::sal_Bool SAL_CALL hasByName( const ::rtl::OUString& aName ) throw (uno::RuntimeException) 
+	{ 
+		NameIndexHash::const_iterator it = namesToIndices.find( aName );
+		return (it != namesToIndices.end());
+	}
+
+
+};
+
+
+void  
+ScVbaWindow::Scroll( const uno::Any& Down, const uno::Any& Up, const uno::Any& ToRight, const uno::Any& ToLeft, bool bLargeScroll ) throw (uno::RuntimeException)
+{
+	ScTabViewShell* pViewShell = getBestViewShell( m_xModel );	
+	if ( !pViewShell )
+	    return;
+	
+	sal_Int16 down = 0;	
+	sal_Int16 up = 0;	
+	sal_Int16 toRight = 0;	
+	sal_Int16 toLeft = 0;	
+	Down >>= down;
+	Up >>= up;
+	ToRight >>= toRight;
+	ToLeft >>= toLeft;
+	uno::Sequence< beans::PropertyValue > args1(2);
+	args1[0].Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "By" ) );
+	args1[1].Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Sel" ) );
+	args1[1].Value <<= false;
+	
+	SCROW totalUp = up - down;
+	SCCOL totalLeft = toLeft - toRight;
+	
+	if ( totalUp != 0 )
+	{
+		if (bLargeScroll)
+		    totalUp = totalUp * pViewShell->GetViewData()->VisibleCellsY( SC_SPLIT_BOTTOM );
+		pViewShell->ScrollLines(0, -totalUp);
+	}
+	
+	if ( totalLeft != 0 )
+	{
+		if (bLargeScroll)
+		    totalLeft = totalLeft * pViewShell->GetViewData()->VisibleCellsX( SC_SPLIT_LEFT );
+		pViewShell->ScrollLines(-totalLeft, 0);
+	}
+
+}
+void SAL_CALL 
+ScVbaWindow::SmallScroll( const uno::Any& Down, const uno::Any& Up, const uno::Any& ToRight, const uno::Any& ToLeft ) throw (uno::RuntimeException)
+{
+	Scroll( Down, Up, ToRight, ToLeft );
+}
+void SAL_CALL 
+ScVbaWindow::LargeScroll( const uno::Any& Down, const uno::Any& Up, const uno::Any& ToRight, const uno::Any& ToLeft ) throw (uno::RuntimeException)
+{
+	Scroll( Down, Up, ToRight, ToLeft, true );
+}
+
+uno::Any SAL_CALL 
+ScVbaWindow::SelectedSheets( const uno::Any& aIndex ) throw (uno::RuntimeException)
+{
+	uno::Reference< container::XEnumerationAccess > xEnumAccess( new SelectedSheetsEnumAccess( m_xContext, m_xModel  ) );
+	uno::Reference< excel::XWorksheets > xSheets(  new ScVbaWorksheets( m_xContext, xEnumAccess, m_xModel ) );
+	if ( aIndex.hasValue() )
+	{
+		uno::Reference< vba::XCollection > xColl( xSheets, uno::UNO_QUERY_THROW );
+		return xColl->Item( aIndex );	
+	}
+	return uno::makeAny( xSheets ); 	
+}
+
+void SAL_CALL 
+ScVbaWindow::ScrollWorkbookTabs( const uno::Any& /*Sheets*/, const uno::Any& /*Position*/ ) throw (uno::RuntimeException)
+{
+// #TODO #FIXME need some implementation to scroll through the tabs
+// but where is this done?
+/*
+	sal_Int32 nSheets = 0;
+	sal_Int32 nPosition = 0;
+	throw uno::RuntimeException( rtl::OUString::createFromAscii("No Implemented" ), uno::Reference< uno::XInterface >() ); 
+	sal_Bool bSheets = ( Sheets >>= nSheets );
+	sal_Bool bPosition = ( Position >>= nPosition );
+	if ( bSheets || bPosition ) // at least one param specified
+		if ( bSheets )
+			;// use sheets
+		else if ( bPosition )
+			; //use position
+*/
+
+}
+uno::Reference< beans::XPropertySet >
+getPropsFromModel( const uno::Reference< frame::XModel >& xModel )
+{
+	uno::Reference< frame::XController > xController = xModel->getCurrentController();
+	if ( !xController.is() )
+		throw uno::RuntimeException( rtl::OUString(
+			RTL_CONSTASCII_USTRINGPARAM ("No controller for model") ), uno::Reference< uno::XInterface >() );	
+	return uno::Reference< beans::XPropertySet >(  xController->getFrame(), uno::UNO_QUERY );
+}
+
+
+uno::Any SAL_CALL 
+ScVbaWindow::getCaption() throw (uno::RuntimeException)
+{
+	static rtl::OUString sCrud(RTL_CONSTASCII_USTRINGPARAM(" - OpenOffice.org Calc" ) );
+	static sal_Int32 nCrudLen = sCrud.getLength();
+
+	uno::Reference< beans::XPropertySet > xProps = getPropsFromModel( m_xModel );
+	rtl::OUString sTitle;
+	xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM ("Title") ) ) >>= sTitle;	
+	sal_Int32 nCrudIndex = sTitle.indexOf( sCrud );	
+	// adjust title ( by removing crud )
+	// sCrud string present
+	if ( nCrudIndex != -1 )
+	{
+		// and ends with sCrud
+		if ( ( nCrudLen + nCrudIndex ) == sTitle.getLength() )
+		{
+			sTitle = sTitle.copy( 0, nCrudIndex );
+			ScVbaWorkbook workbook( m_xContext, m_xModel );
+			rtl::OUString sName = workbook.getName();
+			// rather bizare hack to make sure the name behavior
+			// is like XL
+			// if the adjusted title == workbook name, use name
+			// if the adjusted title != workbook name but ...
+			// 	name == title + extension ( .csv, ,odt, .xls )
+			//	etc. then also use the name
+
+			if ( !sTitle.equals( sName ) )
+			{
+				static rtl::OUString sDot( RTL_CONSTASCII_USTRINGPARAM(".") );
+				// starts with title
+				if ( sName.indexOf( sTitle ) == 0 )
+					// extention starts immediately after
+					if ( sName.match( sDot, sTitle.getLength() ) )
+						sTitle = sName;
+			}
+		}
+	}			
+	return uno::makeAny( sTitle );
+}
+
+void SAL_CALL 
+ScVbaWindow::setCaption( const uno::Any& _caption ) throw (uno::RuntimeException)
+{
+	
+	uno::Reference< beans::XPropertySet > xProps = getPropsFromModel( m_xModel );
+	xProps->setPropertyValue( rtl::OUString(
+		RTL_CONSTASCII_USTRINGPARAM ("Title") ) , _caption );	
+}
+
+uno::Any SAL_CALL 
+ScVbaWindow::getScrollRow() throw (uno::RuntimeException)
+{	
+    sal_Int32 nValue = 0;
+    ScTabViewShell* pViewShell = getBestViewShell( m_xModel );	
+	if ( pViewShell )
+	{
+	    ScSplitPos eWhich = pViewShell->GetViewData()->GetActivePart();
+	    nValue = pViewShell->GetViewData()->GetPosY(WhichV(eWhich));
+	}
+    
+    return uno::makeAny( nValue + 1);
+}
+
+void SAL_CALL 
+ScVbaWindow::setScrollRow( const uno::Any& _scrollrow ) throw (uno::RuntimeException)
+{
+	ScTabViewShell* pViewShell = getBestViewShell( m_xModel );	
+	if ( pViewShell )
+	{
+		sal_Int32 scrollRow = 0;	
+	    _scrollrow >>= scrollRow;
+	    ScSplitPos eWhich = pViewShell->GetViewData()->GetActivePart();
+	    sal_Int32 nOldValue = pViewShell->GetViewData()->GetPosY(WhichV(eWhich)) + 1;
+		pViewShell->ScrollLines(0, scrollRow - nOldValue);
+	}
+}
+
+uno::Any SAL_CALL 
+ScVbaWindow::getScrollColumn() throw (uno::RuntimeException)
+{	
+    sal_Int32 nValue = 0;
+    ScTabViewShell* pViewShell = getBestViewShell( m_xModel );	
+	if ( pViewShell )
+	{
+	    ScSplitPos eWhich = pViewShell->GetViewData()->GetActivePart();
+	    nValue = pViewShell->GetViewData()->GetPosX(WhichH(eWhich));
+	}
+    
+    return uno::makeAny( nValue + 1);
+}
+
+void SAL_CALL 
+ScVbaWindow::setScrollColumn( const uno::Any& _scrollcolumn ) throw (uno::RuntimeException)
+{
+	ScTabViewShell* pViewShell = getBestViewShell( m_xModel );	
+	if ( pViewShell )
+	{
+		sal_Int32 scrollColumn = 0;	
+	    _scrollcolumn >>= scrollColumn;
+	    ScSplitPos eWhich = pViewShell->GetViewData()->GetActivePart();
+	    sal_Int32 nOldValue = pViewShell->GetViewData()->GetPosX(WhichH(eWhich)) + 1;
+		pViewShell->ScrollLines(scrollColumn - nOldValue, 0);
+	}
+}
+
+uno::Any SAL_CALL 
+ScVbaWindow::getWindowState() throw (uno::RuntimeException)
+{	
+    sal_Int32 nwindowState = xlNormal;
+    ScTabViewShell* pViewShell = getBestViewShell( m_xModel );	
+    SfxViewFrame* pViewFrame = pViewShell -> GetViewFrame();
+	SfxTopViewFrame *pTop= PTR_CAST( SfxTopViewFrame, pViewFrame -> GetTopViewFrame() );
+	if ( pTop )
+    {
+	// FOR_UPSTREAM_BUILD
+	/*
+        WorkWindow* pWork = (WorkWindow*) pTop->GetTopFrame_Impl()->GetTopWindow_Impl();
+        if ( pWork )
+        {
+            if ( pWork -> IsMaximized())
+                nwindowState = xlMaximized;
+            else if (pWork -> IsMinimized())
+                nwindowState = xlMinimized;
+        }
+	*/
+    }
+    return uno::makeAny( nwindowState );
+}
+
+void SAL_CALL 
+ScVbaWindow::setWindowState( const uno::Any& _windowstate ) throw (uno::RuntimeException)
+{
+	sal_Int32 nwindowState = xlMaximized;
+	_windowstate >>= nwindowState;
+	ScTabViewShell* pViewShell = getBestViewShell( m_xModel );	
+	SfxViewFrame* pViewFrame = pViewShell -> GetViewFrame();
+	SfxTopViewFrame *pTop= PTR_CAST( SfxTopViewFrame, pViewFrame -> GetTopViewFrame() );
+	if ( pTop )
+    {
+	// FOR_UPSTREAM_BUILD
+	/*
+        WorkWindow* pWork = (WorkWindow*) pTop->GetTopFrame_Impl()->GetTopWindow_Impl();
+        if ( pWork )
+        {
+            if ( nwindowState == xlMaximized)
+                pWork -> Maximize();
+            else if (nwindowState == xlMinimized)
+                pWork -> Minimize();
+            else if (nwindowState == xlNormal)
+                pWork -> Restore();
+            else
+                throw uno::RuntimeException( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "Invalid Parameter" ) ), uno::Reference< uno::XInterface >() );
+        }
+	*/
+    }
+}
+
+void
+ScVbaWindow::Activate() throw (css::uno::RuntimeException)
+{
+	ScVbaWorkbook workbook( m_xContext, m_xModel );
+	workbook.Activate();
+}
+
+void
+ScVbaWindow::Close( const uno::Any& SaveChanges, const uno::Any& FileName, const uno::Any& RouteWorkBook ) throw (uno::RuntimeException)
+{
+	ScVbaWorkbook workbook( m_xContext, m_xModel );
+	workbook.Close(SaveChanges, FileName, RouteWorkBook );
+}
Index: sc/source/ui/vba/vbawindow.hxx
===================================================================
RCS file: sc/source/ui/vba/vbawindow.hxx
diff -N sc/source/ui/vba/vbawindow.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbawindow.hxx	21 Feb 2007 17:29:23 -0000	1.1.2.2
@@ -0,0 +1,73 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_WINDOW_HXX
+#define SC_VBA_WINDOW_HXX
+#include <cppuhelper/implbase1.hxx>
+#include <org/openoffice/excel/XWindow.hpp>
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <com/sun/star/frame/XModel.hpp>
+
+#include "vbahelper.hxx"
+#include "vbaworkbook.hxx"
+
+typedef ::cppu::WeakImplHelper1<oo::excel::XWindow > WindowImpl_BASE;
+
+class ScVbaWindow : public WindowImpl_BASE
+{		
+	css::uno::Reference< css::uno::XComponentContext > m_xContext;
+	css::uno::Reference< css::frame::XModel > m_xModel;
+	void  Scroll( const css::uno::Any& Down, const css::uno::Any& Up, const css::uno::Any& ToRight, const css::uno::Any& ToLeft, bool bLargeScroll = false ) throw (css::uno::RuntimeException);	
+public:
+	ScVbaWindow( const css::uno::Reference< css::uno::XComponentContext >& xContext, const css::uno::Reference< css::frame::XModel >& xModel ) : m_xContext(xContext), m_xModel( xModel ) {}
+	// XWindow
+	virtual void SAL_CALL setCaption( const css::uno::Any& _caption ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL getCaption() throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getScrollRow() throw (css::uno::RuntimeException) ;
+    virtual void SAL_CALL setScrollRow( const css::uno::Any& _scrollrow ) throw (css::uno::RuntimeException) ;
+    virtual css::uno::Any SAL_CALL getScrollColumn() throw (css::uno::RuntimeException) ;
+    virtual void SAL_CALL setScrollColumn( const css::uno::Any& _scrollcolumn ) throw (css::uno::RuntimeException) ;
+    virtual css::uno::Any SAL_CALL getWindowState() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setWindowState( const css::uno::Any& _windowstate ) throw (css::uno::RuntimeException);
+
+	// Methods
+	virtual void SAL_CALL SmallScroll( const css::uno::Any& Down, const css::uno::Any& Up, const css::uno::Any& ToRight, const css::uno::Any& ToLeft ) throw (css::uno::RuntimeException);
+	virtual void SAL_CALL LargeScroll( const css::uno::Any& Down, const css::uno::Any& Up, const css::uno::Any& ToRight, const css::uno::Any& ToLeft ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL SelectedSheets( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException); 
+	virtual void SAL_CALL ScrollWorkbookTabs( const css::uno::Any& Sheets, const css::uno::Any& Position ) throw (css::uno::RuntimeException);
+	virtual void SAL_CALL Activate(  ) throw (css::uno::RuntimeException);
+	virtual void SAL_CALL Close( const css::uno::Any& SaveChanges, const css::uno::Any& FileName, const css::uno::Any& RouteWorkBook ) throw (css::uno::RuntimeException);
+};
+
+#endif //SC_VBA_WINDOW_HXX
Index: sc/source/ui/vba/vbawindows.cxx
===================================================================
RCS file: sc/source/ui/vba/vbawindows.cxx
diff -N sc/source/ui/vba/vbawindows.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbawindows.cxx	21 Feb 2007 17:29:23 -0000	1.1.2.2
@@ -0,0 +1,242 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbawindows.hxx"
+
+#include <com/sun/star/sheet/XSpreadsheetDocument.hpp>
+#include <com/sun/star/frame/XDesktop.hpp>
+#include <cppuhelper/implbase3.hxx>
+
+#include <tools/urlobj.hxx>
+#include "vbawindow.hxx"
+
+using namespace ::com::sun::star;
+using namespace ::org::openoffice;
+
+typedef  std::hash_map< rtl::OUString,
+sal_Int32, ::rtl::OUStringHash,
+::std::equal_to< ::rtl::OUString > > NameIndexHash;
+
+uno::Any ComponentToWindow( const uno::Any& aSource, uno::Reference< uno::XComponentContext > & xContext )
+{
+	uno::Reference< frame::XModel > xModel( aSource, uno::UNO_QUERY_THROW );
+	uno::Reference< excel::XWindow > xWin( new ScVbaWindow( xContext,xModel ) );
+	return uno::makeAny( xWin );
+}
+
+typedef std::vector < uno::Reference< sheet::XSpreadsheetDocument > > Components;
+// #TODO more or less the same as class in workwindows ( code sharing needed )
+class WindowComponentEnumImpl : public EnumerationHelper_BASE
+{
+protected:
+	uno::Reference< uno::XComponentContext > m_xContext;
+	Components m_components;
+	Components::const_iterator m_it;
+
+public:
+	WindowComponentEnumImpl( const uno::Reference< uno::XComponentContext >& xContext, const Components& components ) throw ( uno::RuntimeException ) :  m_xContext( xContext ), m_components( components )
+	{
+		m_it = m_components.begin();
+	}
+
+	WindowComponentEnumImpl( const uno::Reference< uno::XComponentContext >& xContext ) throw ( uno::RuntimeException ) :  m_xContext( xContext )
+	{
+		uno::Reference< lang::XMultiComponentFactory > xSMgr(
+			m_xContext->getServiceManager(), uno::UNO_QUERY_THROW );
+
+		uno::Reference< frame::XDesktop > xDesktop
+			(xSMgr->createInstanceWithContext(::rtl::OUString::createFromAscii("com.sun.star.frame.Desktop"), m_xContext), uno::UNO_QUERY_THROW );
+		uno::Reference< container::XEnumeration > mxComponents = xDesktop->getComponents()->createEnumeration();
+		while( mxComponents->hasMoreElements() )
+		{
+			uno::Reference< sheet::XSpreadsheetDocument > xNext( mxComponents->nextElement(), uno::UNO_QUERY );
+			if ( xNext.is() )
+				m_components.push_back( xNext );
+		}
+		m_it = m_components.begin();
+	}
+	// XEnumeration
+	virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException) 
+	{ 
+		return m_it != m_components.end();
+	}
+
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException) 
+	{ 
+		if ( !hasMoreElements() )
+		{
+			throw container::NoSuchElementException();
+		}
+		return makeAny( *(m_it++) );
+	}
+};
+
+class WindowEnumImpl : public  WindowComponentEnumImpl 
+{
+public:
+	WindowEnumImpl(const uno::Reference< uno::XComponentContext >& xContext, const Components& components ):WindowComponentEnumImpl( xContext, components ) {}
+	WindowEnumImpl( const uno::Reference< uno::XComponentContext >& xContext ): WindowComponentEnumImpl( xContext ) {}
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException)
+	{
+		return ComponentToWindow( WindowComponentEnumImpl::nextElement(), m_xContext );
+	}
+};
+
+typedef ::cppu::WeakImplHelper3< container::XEnumerationAccess 
+	, com::sun::star::container::XIndexAccess
+	, com::sun::star::container::XNameAccess
+	> WindowsAccessImpl_BASE;
+
+class WindowsAccessImpl : public WindowsAccessImpl_BASE
+{
+	uno::Reference< uno::XComponentContext > m_xContext;
+	Components m_windows;
+	NameIndexHash namesToIndices;
+public:	
+	WindowsAccessImpl( const uno::Reference< uno::XComponentContext >& xContext ):m_xContext( xContext )
+	{
+		uno::Reference< container::XEnumeration > xEnum = new WindowComponentEnumImpl( m_xContext );
+		sal_Int32 nIndex=0;
+		while( xEnum->hasMoreElements() )
+		{
+			uno::Reference< sheet::XSpreadsheetDocument > xNext( xEnum->nextElement(), uno::UNO_QUERY );
+			if ( xNext.is() )
+			{
+				m_windows.push_back( xNext );
+				uno::Reference< frame::XModel > xModel( xNext, uno::UNO_QUERY_THROW ); // that the spreadsheetdocument is a xmodel is a given
+				ScVbaWindow window( m_xContext, xModel );
+				rtl::OUString sCaption;
+				window.getCaption() >>= sCaption;
+				namesToIndices[ sCaption ] = nIndex++;
+			}
+		}
+			
+	}
+	
+	//XEnumerationAccess
+	virtual uno::Reference< container::XEnumeration > SAL_CALL createEnumeration(  ) throw (uno::RuntimeException)
+	{
+		return new WindowComponentEnumImpl( m_xContext, m_windows ); 
+	}
+	// XIndexAccess
+	virtual ::sal_Int32 SAL_CALL getCount(  ) throw (uno::RuntimeException) 
+	{ 
+		return m_windows.size();
+	}
+	virtual uno::Any SAL_CALL getByIndex( ::sal_Int32 Index ) throw ( lang::IndexOutOfBoundsException, lang::WrappedTargetException, uno::RuntimeException) 
+	{ 
+		if ( Index < 0 
+			|| static_cast< Components::size_type >( Index ) >= m_windows.size() ) 
+			throw lang::IndexOutOfBoundsException();
+		return makeAny( m_windows[ Index ] ); // returns xspreadsheetdoc
+	}
+
+	//XElementAccess
+	virtual uno::Type SAL_CALL getElementType(  ) throw (uno::RuntimeException)
+	{ 
+		return sheet::XSpreadsheetDocument::static_type(0); 
+	}
+
+	virtual ::sal_Bool SAL_CALL hasElements(  ) throw (uno::RuntimeException) 
+	{ 
+		return (m_windows.size() > 0);
+	}
+
+	//XNameAccess
+	virtual uno::Any SAL_CALL getByName( const ::rtl::OUString& aName ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException) 
+	{ 
+		NameIndexHash::const_iterator it = namesToIndices.find( aName );
+		if ( it == namesToIndices.end() )
+			throw container::NoSuchElementException();
+		return makeAny( m_windows[ it->second ] );
+		
+	}
+
+	virtual uno::Sequence< ::rtl::OUString > SAL_CALL getElementNames(  ) throw (uno::RuntimeException) 
+	{ 
+		uno::Sequence< ::rtl::OUString > names( namesToIndices.size() );
+		::rtl::OUString* pString = names.getArray();
+		NameIndexHash::const_iterator it = namesToIndices.begin();
+		NameIndexHash::const_iterator it_end = namesToIndices.end();
+		for ( ; it != it_end; ++it, ++pString )
+			*pString = it->first;	
+		return names;	
+	}
+
+	virtual ::sal_Bool SAL_CALL hasByName( const ::rtl::OUString& aName ) throw (uno::RuntimeException) 
+	{ 
+		NameIndexHash::const_iterator it = namesToIndices.find( aName );
+		return (it != namesToIndices.end());
+	}
+
+};
+
+
+ScVbaWindows::ScVbaWindows( const uno::Reference< uno::XComponentContext > & xContext, const uno::Reference< container::XIndexAccess >& xIndexAccess  ):  ScVbaWindows_BASE( xContext, xIndexAccess ) 
+{
+}
+
+uno::Reference< container::XEnumeration >
+ScVbaWindows::createEnumeration() throw (uno::RuntimeException)
+{
+	return new WindowEnumImpl( m_xContext );
+}
+
+uno::Any
+ScVbaWindows::createCollectionObject( const css::uno::Any& aSource )
+{
+	return ComponentToWindow( aSource,  m_xContext );
+}
+
+uno::Type 
+ScVbaWindows::getElementType() throw (uno::RuntimeException)
+{
+	return excel::XWindows::static_type(0);
+}
+
+uno::Reference< vba::XCollection >
+ScVbaWindows::Windows( const css::uno::Reference< css::uno::XComponentContext >& xContext )
+{
+	uno::Reference< container::XIndexAccess > xIndex( new WindowsAccessImpl( xContext ) );
+
+	return uno::Reference< vba::XCollection >( new ScVbaWindows( xContext , xIndex ) );	
+}
+
+void SAL_CALL 
+ScVbaWindows::Arrange( ::sal_Int32 /*ArrangeStyle*/, const uno::Any& /*ActiveWorkbook*/, const uno::Any& /*SyncHorizontal*/, const uno::Any& /*SyncVertical*/ ) throw (uno::RuntimeException)
+{
+	//#TODO #FIXME see what can be done for an implementation here
+}
+
+
Index: sc/source/ui/vba/vbawindows.hxx
===================================================================
RCS file: sc/source/ui/vba/vbawindows.hxx
diff -N sc/source/ui/vba/vbawindows.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbawindows.hxx	21 Feb 2007 17:29:23 -0000	1.1.2.2
@@ -0,0 +1,71 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_WINDOWS_HXX
+#define SC_VBA_WINDOWS_HXX
+
+#include <cppuhelper/implbase1.hxx>
+#include <org/openoffice/excel/XWindows.hpp>
+
+#include <com/sun/star/uno/XComponentContext.hpp>
+ 
+#include "vbahelper.hxx"
+#include "vbacollectionimpl.hxx"
+
+
+typedef ::cppu::ImplInheritanceHelper1< ScVbaCollectionBaseImpl, oo::excel::XWindows > ScVbaWindows_BASE;
+
+class ScVbaWindows : public ScVbaWindows_BASE
+{
+protected:
+public:
+	ScVbaWindows( const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::container::XIndexAccess >& xIndexAccess );
+	virtual ~ScVbaWindows() {}
+
+	// XEnumerationAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+
+	// XWindows
+	virtual void SAL_CALL Arrange( ::sal_Int32 ArrangeStyle, const css::uno::Any& ActiveWorkbook, const css::uno::Any& SyncHorizontal, const css::uno::Any& SyncVertical ) throw (::com::sun::star::uno::RuntimeException);
+	// ScVbaCollectionBaseImpl	
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ); 
+
+	static css::uno::Reference< oo::vba::XCollection > Windows(  const css::uno::Reference< css::uno::XComponentContext >& xContext );
+
+};
+
+#endif //SC_VBA_WINDOWS_HXX
+
Index: sc/source/ui/vba/vbaworkbook.cxx
===================================================================
RCS file: sc/source/ui/vba/vbaworkbook.cxx
diff -N sc/source/ui/vba/vbaworkbook.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbaworkbook.cxx	21 Feb 2007 17:29:23 -0000	1.1.2.2
@@ -0,0 +1,267 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include <tools/urlobj.hxx>
+
+#include <com/sun/star/util/XModifiable.hpp>
+#include <com/sun/star/util/XProtectable.hpp>
+#include <com/sun/star/sheet/XSpreadsheetView.hpp>
+#include <com/sun/star/sheet/XSpreadsheetDocument.hpp>
+#include <com/sun/star/frame/XStorable.hpp>
+#include <com/sun/star/frame/XFrame.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+
+#include "vbaworksheet.hxx"
+#include "vbaworksheets.hxx"
+#include "vbaworkbook.hxx"
+#include "vbawindows.hxx"
+#include "vbahelper.hxx"
+
+#include <stdio.h>
+
+// Much of the impl. for the equivalend UNO module is
+// sc/source/ui/unoobj/docuno.cxx, viewuno.cxx
+
+using namespace ::org::openoffice;
+using namespace ::com::sun::star;
+
+class ActiveSheet : public ScVbaWorksheet
+{
+protected:
+	virtual uno::Reference< frame::XModel > getModel()
+	{ 	
+		return getCurrentDocument(); 
+	}
+	virtual uno::Reference< sheet::XSpreadsheet > getSheet()
+	{ 
+		uno::Reference< frame::XModel > xModel = getModel();
+		uno::Reference< sheet::XSpreadsheet > xSheet;
+		if ( xModel.is() )
+		{
+			uno::Reference< sheet::XSpreadsheetView > xSpreadsheet(
+                        	xModel->getCurrentController(), uno::UNO_QUERY );
+			if ( xSpreadsheet.is() )
+				xSheet = xSpreadsheet->getActiveSheet(); 
+		}
+		return xSheet;
+	}
+public:
+	ActiveSheet( uno::Reference< uno::XComponentContext >& xContext ) : ScVbaWorksheet( xContext ) {}
+		
+};
+
+
+::rtl::OUString
+ScVbaWorkbook::getName() throw (uno::RuntimeException)
+{
+	rtl::OUString sName = getModel()->getURL();
+	if ( sName.getLength() )
+	{
+
+		INetURLObject aURL( getModel()->getURL() );
+		sName = aURL.GetLastName();
+	}
+	else
+	{
+		const static rtl::OUString sTitle( RTL_CONSTASCII_USTRINGPARAM("Title" ) );
+		// process "UntitledX - $(PRODUCTNAME)"
+		uno::Reference< frame::XFrame > xFrame( getModel()->getCurrentController()->getFrame(), uno::UNO_QUERY_THROW );
+		uno::Reference< beans::XPropertySet > xProps( xFrame, uno::UNO_QUERY_THROW );
+		xProps->getPropertyValue(sTitle ) >>= sName;
+		sal_Int32 pos = 0;
+		sName = sName.getToken(0,' ',pos);	
+	}
+	return sName;
+}
+::rtl::OUString
+ScVbaWorkbook::getPath() throw (uno::RuntimeException)
+{
+	INetURLObject aURL( getModel()->getURL() );
+	aURL.CutLastName();
+	return aURL.GetURLPath();
+}
+
+::rtl::OUString
+ScVbaWorkbook::getFullName() throw (uno::RuntimeException)
+{
+	INetURLObject aURL( getModel()->getURL() );
+	return aURL.GetURLPath();
+}
+uno::Reference< excel::XWorksheet >
+ScVbaWorkbook::getActiveSheet() throw (uno::RuntimeException)
+{
+	return new ActiveSheet( m_xContext );
+}
+uno::Any SAL_CALL
+ScVbaWorkbook::Sheets( const uno::Any& aIndex ) throw (uno::RuntimeException)
+{
+	return Worksheets( aIndex );
+}
+uno::Any SAL_CALL
+ScVbaWorkbook::Worksheets( const uno::Any& aIndex ) throw (uno::RuntimeException)
+{
+	uno::Reference< frame::XModel > xModel( getModel() );	
+	uno::Reference <sheet::XSpreadsheetDocument> xSpreadDoc( xModel, uno::UNO_QUERY_THROW );
+	uno::Reference<sheet::XSpreadsheets > xSheets( xSpreadDoc->getSheets(), uno::UNO_QUERY_THROW );
+	uno::Reference< vba::XCollection > xWorkSheets( uno::Reference< excel::XWorksheets >( new ScVbaWorksheets(m_xContext, xSheets, xModel ) ), uno::UNO_QUERY_THROW );
+	if (  aIndex.getValueTypeClass() == uno::TypeClass_VOID )
+	{
+		return uno::Any( xWorkSheets );	
+	}
+	return uno::Any( xWorkSheets->Item( aIndex ) );
+}
+uno::Any SAL_CALL
+ScVbaWorkbook::Windows( const uno::Any& aIndex ) throw (uno::RuntimeException)
+{
+	uno::Reference< vba::XCollection >  xWindows = ScVbaWindows::Windows( m_xContext );
+	if ( aIndex.getValueTypeClass() == uno::TypeClass_VOID )
+		return uno::Any( xWindows );
+	return uno::Any( xWindows->Item( aIndex ) );
+}
+void
+ScVbaWorkbook::Close( const uno::Any &rSaveArg, const uno::Any &rFileArg,
+					  const uno::Any &rRouteArg ) throw (uno::RuntimeException)
+{
+	sal_Bool bSaveChanges = sal_False;
+	rtl::OUString aFileName;
+	sal_Bool bRouteWorkbook = sal_True;
+
+	rSaveArg >>= bSaveChanges;
+	sal_Bool bFileName =  ( rFileArg >>= aFileName );
+	rRouteArg >>= bRouteWorkbook;
+	uno::Reference< frame::XStorable > xStorable( getModel(), uno::UNO_QUERY_THROW );
+	uno::Reference< util::XModifiable > xModifiable( getModel(), uno::UNO_QUERY_THROW );
+
+	if( bSaveChanges )
+	{
+		if( xStorable->isReadonly() )
+		{	
+			throw uno::RuntimeException(::rtl::OUString( 
+				RTL_CONSTASCII_USTRINGPARAM( "Unable to save to a read only file ") ),
+                        	uno::Reference< XInterface >() );
+		}
+		if( bFileName )
+			xStorable->storeAsURL( aFileName, uno::Sequence< beans::PropertyValue >(0) ); 
+		else
+			xStorable->store();
+	}	
+	else
+		xModifiable->setModified( false );		
+
+	uno::Reference< util::XCloseable > xCloseable( getModel(), uno::UNO_QUERY );
+
+	if( xCloseable.is() )
+		// use close(boolean DeliverOwnership)
+	
+		// The boolean parameter DeliverOwnership tells objects vetoing the close process that they may
+		// assume ownership if they object the closure by throwing a CloseVetoException
+		// Here we give up ownership. To be on the safe side, catch possible veto exception anyway.
+		xCloseable->close(sal_True);
+	// If close is not supported by this model - try to dispose it.
+	// But if the model disagree with a reset request for the modify state
+	// we shouldn't do so. Otherwhise some strange things can happen.
+	else
+	{
+		uno::Reference< lang::XComponent > xDisposable ( getCurrentDocument(), uno::UNO_QUERY );
+		if ( xDisposable.is() )
+			xDisposable->dispose();
+	}
+}
+
+void
+ScVbaWorkbook::Protect( const uno::Any &aPassword ) throw (uno::RuntimeException)
+{
+	rtl::OUString rPassword;
+	uno::Reference< util::XProtectable > xProt( getModel(), uno::UNO_QUERY_THROW );
+	SC_VBA_FIXME(("Workbook::Protect stub"));
+	if(  aPassword >>= rPassword )
+		xProt->protect( rPassword );
+	else
+		xProt->protect( rtl::OUString() );
+}
+
+void 
+ScVbaWorkbook::Unprotect( const uno::Any &aPassword ) throw (uno::RuntimeException)
+{
+	rtl::OUString rPassword;
+	uno::Reference< util::XProtectable > xProt( getModel(), uno::UNO_QUERY_THROW );
+	if( !getProtectStructure() )
+		throw uno::RuntimeException(::rtl::OUString(
+			RTL_CONSTASCII_USTRINGPARAM( "File is already unprotected" ) ),
+			uno::Reference< XInterface >() );
+	else
+	{
+		if( aPassword >>= rPassword )
+			xProt->unprotect( rPassword );
+		else
+			xProt->unprotect( rtl::OUString() );
+	}
+}
+		
+::sal_Bool
+ScVbaWorkbook::getProtectStructure() throw (uno::RuntimeException)
+{
+	uno::Reference< util::XProtectable > xProt( getModel(), uno::UNO_QUERY_THROW );
+	return xProt->isProtected();
+}
+
+void 
+ScVbaWorkbook::setSaved( sal_Bool bSave ) throw (uno::RuntimeException)
+{
+	uno::Reference< util::XModifiable > xModifiable( getModel(), uno::UNO_QUERY_THROW );
+	xModifiable->setModified( bSave );
+}
+
+sal_Bool
+ScVbaWorkbook::getSaved() throw (uno::RuntimeException)
+{
+	uno::Reference< util::XModifiable > xModifiable( getModel(), uno::UNO_QUERY_THROW );
+	return xModifiable->isModified();
+}
+
+void
+ScVbaWorkbook::Save() throw (uno::RuntimeException)
+{
+	rtl::OUString url = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(".uno:Save"));
+	uno::Reference< frame::XModel > xModel = getModel();
+	dispatchRequests(xModel,url);
+}
+
+void 
+ScVbaWorkbook::Activate() throw (uno::RuntimeException)
+{
+	uno::Reference< frame::XFrame > xFrame( getModel()->getCurrentController()->getFrame(), uno::UNO_QUERY_THROW );
+	xFrame->activate();
+}	
+
Index: sc/source/ui/vba/vbaworkbook.hxx
===================================================================
RCS file: sc/source/ui/vba/vbaworkbook.hxx
diff -N sc/source/ui/vba/vbaworkbook.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbaworkbook.hxx	21 Feb 2007 17:29:23 -0000	1.1.2.2
@@ -0,0 +1,83 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_WORKBOOK_HXX
+#define SC_VBA_WORKBOOK_HXX
+
+#include <cppuhelper/implbase1.hxx>
+
+#include <com/sun/star/frame/XModel.hpp>
+#include <org/openoffice/excel/XWorkbook.hpp>
+#include "vbahelper.hxx"
+
+class ScModelObj;
+
+typedef ::cppu::WeakImplHelper1< oo::excel::XWorkbook > ScVbaWorkbook_BASE;
+
+class ScVbaWorkbook : public ScVbaWorkbook_BASE
+{
+	css::uno::Reference< css::frame::XModel > mxModel;
+	css::uno::Reference< css::uno::XComponentContext > m_xContext;
+protected:
+	virtual css::uno::Reference< css::frame::XModel >  getModel() { return mxModel; }
+	ScVbaWorkbook( 	css::uno::Reference< css::uno::XComponentContext >& xContext) : mxModel(NULL), m_xContext( xContext ){}
+public:
+	ScVbaWorkbook( 	css::uno::Reference< css::uno::XComponentContext >& xContext,
+			css::uno::Reference< css::frame::XModel > xModel ) :
+ 			mxModel( xModel ), m_xContext( xContext ){}
+	virtual ~ScVbaWorkbook() {}
+
+    // Attributes
+	virtual ::rtl::OUString SAL_CALL getName() throw (css::uno::RuntimeException);
+	virtual ::rtl::OUString SAL_CALL getPath() throw (css::uno::RuntimeException);
+	virtual ::rtl::OUString SAL_CALL getFullName() throw (css::uno::RuntimeException);
+	virtual ::sal_Bool SAL_CALL getProtectStructure() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< oo::excel::XWorksheet > SAL_CALL getActiveSheet() throw (css::uno::RuntimeException);
+	virtual sal_Bool SAL_CALL getSaved() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setSaved( sal_Bool bSave ) throw (css::uno::RuntimeException);
+
+	// Methods
+	virtual css::uno::Any SAL_CALL Worksheets( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL Sheets( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL Windows( const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+	virtual void SAL_CALL Close( const css::uno::Any &bSaveChanges,
+								 const css::uno::Any &aFileName,
+								 const css::uno::Any &bRouteWorkbook ) throw (css::uno::RuntimeException);
+	virtual void SAL_CALL Protect( const css::uno::Any & aPassword ) throw (css::uno::RuntimeException);
+	virtual void SAL_CALL Unprotect( const css::uno::Any &aPassword ) throw (css::uno::RuntimeException);
+	virtual void SAL_CALL Save() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL Activate() throw (css::uno::RuntimeException);
+};
+
+#endif /* SC_VBA_WORKBOOK_HXX */
Index: sc/source/ui/vba/vbaworkbooks.cxx
===================================================================
RCS file: sc/source/ui/vba/vbaworkbooks.cxx
diff -N sc/source/ui/vba/vbaworkbooks.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbaworkbooks.cxx	21 Feb 2007 17:29:24 -0000	1.1.2.4
@@ -0,0 +1,408 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include <comphelper/processfactory.hxx>
+
+#include <cppuhelper/implbase1.hxx>
+#include <cppuhelper/implbase3.hxx>
+
+#include <com/sun/star/frame/XDesktop.hpp>
+#include <com/sun/star/sheet/XSpreadsheetDocument.hpp>
+#include <com/sun/star/container/XEnumerationAccess.hpp>
+#include <com/sun/star/frame/XComponentLoader.hpp>
+#include <com/sun/star/lang/XComponent.hpp>
+#include <com/sun/star/frame/XModel.hpp>
+#include <com/sun/star/frame/XFrame.hpp>
+#include <com/sun/star/frame/FrameSearchFlag.hpp>
+#include <com/sun/star/util/XModifiable.hpp>
+#include <com/sun/star/frame/XStorable.hpp>
+#include <com/sun/star/lang/DisposedException.hpp>
+#include <com/sun/star/beans/PropertyVetoException.hpp>
+#include <com/sun/star/util/XCloseable.hpp>
+#include <com/sun/star/lang/IndexOutOfBoundsException.hpp>
+#include <com/sun/star/document/XTypeDetection.hpp>
+
+#include <sfx2/objsh.hxx>
+#include <tools/urlobj.hxx>
+
+#include "vbaglobals.hxx"
+#include "vbaworkbook.hxx"
+#include "vbaworkbooks.hxx"
+#include "vbahelper.hxx"
+
+#include <hash_map>
+#include <osl/file.hxx>
+using namespace ::org::openoffice;
+using namespace ::com::sun::star;
+
+const sal_Int16 CUSTOM_CHAR = 5;
+
+typedef  std::hash_map< rtl::OUString,
+sal_Int32, ::rtl::OUStringHash,
+::std::equal_to< ::rtl::OUString > > NameIndexHash;
+
+typedef std::vector < uno::Reference< sheet::XSpreadsheetDocument > > WorkBooks;
+
+typedef ::cppu::WeakImplHelper1< container::XEnumeration > SpreadSheetDocEnumImpl_BASE;
+
+static uno::Any
+getWorkbook( uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< sheet::XSpreadsheetDocument > &xDoc )
+{
+	// FIXME: fine as long as ScVbaWorkbook is stateless ...
+	uno::Reference< frame::XModel > xModel( xDoc, uno::UNO_QUERY );
+	if( !xModel.is() )
+		return uno::Any();
+
+	ScVbaWorkbook *pWb = new ScVbaWorkbook( xContext, xModel );
+	return uno::Any( uno::Reference< excel::XWorkbook > (pWb) );
+}
+
+
+// #FIXME clearly this is a candidate for some sort of helper base class as
+// this is a copy of SelectedSheetsEnum ( vbawindow.cxx )
+
+class SpreadSheetDocEnumImpl : public SpreadSheetDocEnumImpl_BASE
+{
+	uno::Reference< uno::XComponentContext > m_xContext;
+	WorkBooks m_books;
+	WorkBooks::const_iterator m_it;
+
+public:
+	SpreadSheetDocEnumImpl( const uno::Reference< uno::XComponentContext >& xContext, const WorkBooks& books ) throw ( uno::RuntimeException ) :  m_xContext( xContext ), m_books( books )
+	{
+		m_it = m_books.begin();
+	}
+	SpreadSheetDocEnumImpl( const uno::Reference< uno::XComponentContext >& xContext ) throw ( uno::RuntimeException ) :  m_xContext( xContext )
+	{
+		uno::Reference< lang::XMultiComponentFactory > xSMgr(
+			m_xContext->getServiceManager(), uno::UNO_QUERY_THROW );
+
+		uno::Reference< frame::XDesktop > xDesktop
+			(xSMgr->createInstanceWithContext(::rtl::OUString::createFromAscii("com.sun.star.frame.Desktop"), m_xContext), uno::UNO_QUERY_THROW );
+		uno::Reference< container::XEnumeration > mxComponents = xDesktop->getComponents()->createEnumeration();
+		while( mxComponents->hasMoreElements() )
+		{
+			uno::Reference< sheet::XSpreadsheetDocument > xNext( mxComponents->nextElement(), uno::UNO_QUERY );
+			if ( xNext.is() )
+				m_books.push_back( xNext );
+		}
+		m_it = m_books.begin();
+	}
+	// XEnumeration
+	virtual ::sal_Bool SAL_CALL hasMoreElements(  ) throw (uno::RuntimeException) 
+	{ 
+		return m_it != m_books.end();
+	}
+
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException) 
+	{ 
+		if ( !hasMoreElements() )
+		{
+			throw container::NoSuchElementException();
+		}
+		return makeAny( *(m_it++) );
+	}
+};
+
+class WorkBookEnumImpl : public EnumerationHelperImpl
+{
+public:
+	WorkBookEnumImpl( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< container::XEnumeration >& xEnumeration ) throw ( uno::RuntimeException ) : EnumerationHelperImpl( xContext, xEnumeration ){}
+
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException) 
+	{ 
+		uno::Reference< sheet::XSpreadsheetDocument > xDoc( m_xEnumeration->nextElement(), uno::UNO_QUERY_THROW );
+		return getWorkbook( m_xContext, xDoc );
+	}
+
+};
+
+// #FIXME clearly this is also a candidate for some sort of helper base class as
+// a very similar one is used in vbawindow ( SelectedSheetsEnumAccess )
+// Maybe a template base class that does all of the operations on the hashmap
+// and vector only, and the sub-class does everything else
+// => ctor, createEnumeration & factory method need be defined ( to be called 
+// by getByIndex, getByName )
+typedef ::cppu::WeakImplHelper3< container::XEnumerationAccess 
+	, com::sun::star::container::XIndexAccess
+	, com::sun::star::container::XNameAccess
+	> WorkBooksAccessImpl_BASE;
+
+class WorkBooksAccessImpl : public WorkBooksAccessImpl_BASE
+{
+	uno::Reference< uno::XComponentContext > m_xContext;
+	WorkBooks m_books;
+	NameIndexHash namesToIndices;
+public:	
+	WorkBooksAccessImpl( const uno::Reference< uno::XComponentContext >& xContext ):m_xContext( xContext )
+	{
+		uno::Reference< container::XEnumeration > xEnum = new SpreadSheetDocEnumImpl( m_xContext );
+		sal_Int32 nIndex=0;
+		while( xEnum->hasMoreElements() )
+		{
+			uno::Reference< sheet::XSpreadsheetDocument > xNext( xEnum->nextElement(), uno::UNO_QUERY );
+			if ( xNext.is() )
+			{
+				m_books.push_back( xNext );
+				uno::Reference< frame::XModel > xModel( xNext, uno::UNO_QUERY_THROW ); // that the spreadsheetdocument is a xmodel is a given
+				INetURLObject aURL( xModel->getURL() );
+				namesToIndices[ aURL.GetLastName() ] = nIndex++;
+			}
+		}
+			
+	}
+	
+	//XEnumerationAccess
+	virtual uno::Reference< container::XEnumeration > SAL_CALL createEnumeration(  ) throw (uno::RuntimeException)
+	{
+		return new SpreadSheetDocEnumImpl( m_xContext, m_books ); 
+	}
+	// XIndexAccess
+	virtual ::sal_Int32 SAL_CALL getCount(  ) throw (uno::RuntimeException) 
+	{ 
+		return m_books.size();
+	}
+	virtual uno::Any SAL_CALL getByIndex( ::sal_Int32 Index ) throw ( lang::IndexOutOfBoundsException, lang::WrappedTargetException, uno::RuntimeException) 
+	{ 
+		if ( Index < 0 
+			|| static_cast< WorkBooks::size_type >(Index) >= m_books.size() ) 
+			throw lang::IndexOutOfBoundsException();
+		return makeAny( m_books[ Index ] ); // returns xspreadsheetdoc
+	}
+
+	//XElementAccess
+	virtual uno::Type SAL_CALL getElementType(  ) throw (uno::RuntimeException)
+	{ 
+		return sheet::XSpreadsheetDocument::static_type(0); 
+	}
+
+	virtual ::sal_Bool SAL_CALL hasElements(  ) throw (uno::RuntimeException) 
+	{ 
+		return (m_books.size() > 0);
+	}
+
+	//XNameAccess
+	virtual uno::Any SAL_CALL getByName( const ::rtl::OUString& aName ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException) 
+	{ 
+		NameIndexHash::const_iterator it = namesToIndices.find( aName );
+		if ( it == namesToIndices.end() )
+			throw container::NoSuchElementException();
+		return makeAny( m_books[ it->second ] );
+		
+	}
+
+	virtual uno::Sequence< ::rtl::OUString > SAL_CALL getElementNames(  ) throw (uno::RuntimeException) 
+	{ 
+		uno::Sequence< ::rtl::OUString > names( namesToIndices.size() );
+		::rtl::OUString* pString = names.getArray();
+		NameIndexHash::const_iterator it = namesToIndices.begin();
+		NameIndexHash::const_iterator it_end = namesToIndices.end();
+		for ( ; it != it_end; ++it, ++pString )
+			*pString = it->first;	
+		return names;	
+	}
+
+	virtual ::sal_Bool SAL_CALL hasByName( const ::rtl::OUString& aName ) throw (uno::RuntimeException) 
+	{ 
+		NameIndexHash::const_iterator it = namesToIndices.find( aName );
+		return (it != namesToIndices.end());
+	}
+
+};
+
+ScVbaWorkbooks::ScVbaWorkbooks( const uno::Reference< css::uno::XComponentContext >& xContext ) : ScVbaWorkbooks_BASE( xContext, uno::Reference< container::XIndexAccess >( new WorkBooksAccessImpl( xContext ) ) )
+{
+}
+// XEnumerationAccess
+uno::Type
+ScVbaWorkbooks::getElementType() throw (uno::RuntimeException)
+{
+	return excel::XWorkbook::static_type(0);
+}
+uno::Reference< container::XEnumeration >
+ScVbaWorkbooks::createEnumeration() throw (uno::RuntimeException)
+{
+	// #FIXME its possible the WorkBookEnumImpl here doens't reflect
+	// the state of this object ( although it should ) would be 
+	// safer to create an enumeration based on this objects state
+	// rather than one effectively based of the desktop component
+	return new WorkBookEnumImpl( m_xContext, uno::Reference< container::XEnumeration >( new SpreadSheetDocEnumImpl(m_xContext) ) );
+}
+
+uno::Any
+ScVbaWorkbooks::createCollectionObject( const css::uno::Any& aSource )
+{
+	uno::Reference< sheet::XSpreadsheetDocument > xDoc( aSource, uno::UNO_QUERY );
+	return getWorkbook( m_xContext, xDoc );
+}
+
+
+uno::Any SAL_CALL
+ScVbaWorkbooks::Add() throw (uno::RuntimeException)
+{
+	uno::Reference< lang::XMultiComponentFactory > xSMgr(
+        m_xContext->getServiceManager(), uno::UNO_QUERY_THROW );
+
+	 uno::Reference< frame::XComponentLoader > xLoader(
+        xSMgr->createInstanceWithContext(
+            ::rtl::OUString::createFromAscii("com.sun.star.frame.Desktop"),
+                m_xContext), uno::UNO_QUERY_THROW );
+	uno::Reference< lang::XComponent > xComponent = xLoader->loadComponentFromURL(
+									   rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("private:factory/scalc") ),
+									   rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("_blank") ), 0, 
+									   uno::Sequence< beans::PropertyValue >(0) );			   
+    uno::Reference <sheet::XSpreadsheetDocument> xSpreadDoc( xComponent, uno::UNO_QUERY_THROW );
+                                                                                                                             
+    if( xSpreadDoc.is() )
+        return getWorkbook( m_xContext, xSpreadDoc );
+    return uno::Any();
+}
+
+void
+ScVbaWorkbooks::Close() throw (uno::RuntimeException)
+{
+	uno::Reference< lang::XMultiComponentFactory > xSMgr(
+		m_xContext->getServiceManager(), uno::UNO_QUERY_THROW );
+	uno::Reference< frame::XModel > xModel( getCurrentDocument(), uno::UNO_QUERY_THROW );
+	rtl::OUString url = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:CloseDoc"));
+	dispatchRequests(xModel,url);
+}
+
+bool 
+ScVbaWorkbooks::isTextFile( const rtl::OUString& rFileName )
+{
+	uno::Reference< document::XTypeDetection > xTypeDetect( m_xContext->getServiceManager()->createInstanceWithContext(::rtl::OUString::createFromAscii("com.sun.star.document.TypeDetection"), m_xContext), uno::UNO_QUERY_THROW );
+	uno::Sequence< beans::PropertyValue > aMediaDesc(1);
+	aMediaDesc[ 0 ].Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM ("URL" ) );
+	aMediaDesc[ 0 ].Value <<= rFileName;
+	rtl::OUString sType = xTypeDetect->queryTypeByDescriptor( aMediaDesc, sal_True );
+	const static rtl::OUString txtType( RTL_CONSTASCII_USTRINGPARAM("writer_Text" ) );
+	const static rtl::OUString csvType( RTL_CONSTASCII_USTRINGPARAM("calc_Text_txt_csv_StarCalc" ) );
+	return sType.equals( txtType ) || sType.equals( csvType );
+}
+
+// #TODO# #FIXME# can any of the unused params below be used?
+uno::Any
+ScVbaWorkbooks::Open( const rtl::OUString& rFileName, const uno::Any& /*UpdateLinks*/, const uno::Any& ReadOnly, const uno::Any& Format, const uno::Any& /*Password*/, const uno::Any& /*WriteResPassword*/, const uno::Any& /*IgnoreReadOnlyRecommended*/, const uno::Any& /*Origin*/, const uno::Any& Delimiter, const uno::Any& /*Editable*/, const uno::Any& /*Notify*/, const uno::Any& /*Converter*/, const uno::Any& /*AddToMru*/ ) throw (uno::RuntimeException)
+{
+        rtl::OUString aURL;
+        osl::FileBase::getFileURLFromSystemPath( rFileName, aURL );
+	uno::Reference< lang::XMultiComponentFactory > xSMgr(
+        	m_xContext->getServiceManager(), uno::UNO_QUERY_THROW );
+
+	uno::Reference< frame::XDesktop > xDesktop
+		(xSMgr->createInstanceWithContext(::rtl::OUString::createFromAscii("com.sun.star.frame.Desktop")                    , m_xContext),
+		uno::UNO_QUERY_THROW );
+	uno::Reference< frame::XComponentLoader > xLoader(
+		xSMgr->createInstanceWithContext(
+		::rtl::OUString::createFromAscii("com.sun.star.frame.Desktop"),
+		m_xContext),
+		uno::UNO_QUERY_THROW );
+	uno::Sequence< beans::PropertyValue > sProps(0);
+	sal_Int32 nIndex = 0;
+
+	// A text file means it needs to be processed as a csv file	
+	if ( isTextFile( aURL ) ) 
+	{
+		// Values for format
+		// 1 Tabs
+		// 2 Commas
+		// 3 Spaces
+		// 4 Semicolons
+		// 5 Nothing
+		// 6 Custom character (see the Delimiter argument
+		// no format means use the current delimiter
+		sProps.realloc( 1 );
+		sProps[ nIndex ].Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("FilterOptions" ) );
+		sal_Int16 delims[] = { 0 /*default not used*/, 9/*tab*/, 44/*comma*/, 32/*space*/, 59/*semicolon*/ };	
+		static rtl::OUString sRestOfFormat( RTL_CONSTASCII_USTRINGPARAM(",34,0,1" ) );
+		
+		rtl::OUString sFormat;
+		sal_Int16 nFormat = 0; // default indicator
+
+
+		if ( Format.hasValue() )
+		{
+			Format >>= nFormat; // val of nFormat overwritten if extracted	
+			// validate param	
+			if ( nFormat < 1 || nFormat > 6 )
+				throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Illegal value for Format" ) ), uno::Reference< uno::XInterface >() );
+		}
+
+		sal_Int16 nDelim = getCurrentDelim();
+
+		if (  nFormat > 0 && nFormat < CUSTOM_CHAR ) 
+		{
+			nDelim =  delims[ nFormat ];
+		}
+		else if ( nFormat > CUSTOM_CHAR )
+		{
+			// Need to check Delimiter param
+			if ( !Delimiter.hasValue() )
+				throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Expected value for Delimiter" ) ), uno::Reference< uno::XInterface >() );
+			rtl::OUString sStr;
+			Delimiter >>= sStr;
+			String aUniStr( sStr );
+			if ( aUniStr.Len() )
+				nDelim = aUniStr.GetChar(0);
+			else
+				throw uno::RuntimeException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Incorrect value for Delimiter" ) ), uno::Reference< uno::XInterface >() );
+		}
+
+		getCurrentDelim() = nDelim; //set new current
+
+		sFormat = rtl::OUString::valueOf( (sal_Int32)nDelim ) + sRestOfFormat;
+		sProps[ nIndex++ ].Value <<= sFormat;
+	}
+	if ( ReadOnly.hasValue()  )
+	{
+		sal_Bool bIsReadOnly = sal_False; ReadOnly >>= bIsReadOnly;
+		if ( bIsReadOnly )
+		{
+			static const rtl::OUString sReadOnly( RTL_CONSTASCII_USTRINGPARAM("ReadOnly") );
+			sProps.realloc( sProps.getLength() + 1 );
+			sProps[ nIndex ].Name = sReadOnly;
+			sProps[ nIndex++ ].Value = uno::makeAny( (sal_Bool)sal_True );
+		}
+	}
+
+	uno::Reference< lang::XComponent > xComponent = xLoader->loadComponentFromURL( aURL,
+		rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("_default") ),
+		frame::FrameSearchFlag::CREATE,
+		sProps);
+	uno::Reference <sheet::XSpreadsheetDocument> xSpreadDoc( xComponent, uno::UNO_QUERY_THROW );
+	return getWorkbook( m_xContext, xSpreadDoc );
+}
+
+
Index: sc/source/ui/vba/vbaworkbooks.hxx
===================================================================
RCS file: sc/source/ui/vba/vbaworkbooks.hxx
diff -N sc/source/ui/vba/vbaworkbooks.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbaworkbooks.hxx	21 Feb 2007 17:29:24 -0000	1.1.2.2
@@ -0,0 +1,73 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_WORKBOOKS_HXX
+#define SC_VBA_WORKBOOKS_HXX
+
+
+#include "vbacollectionimpl.hxx"
+#include <org/openoffice/vba/XGlobals.hpp>
+#include <org/openoffice/excel/XWorkbooks.hpp>
+#include <com/sun/star/container/XEnumerationAccess.hpp>
+#include "vbahelper.hxx"
+
+
+class ScModelObj;
+
+typedef ::cppu::ImplInheritanceHelper1< ScVbaCollectionBaseImpl, oo::excel::XWorkbooks > ScVbaWorkbooks_BASE;
+
+class ScVbaWorkbooks : public ScVbaWorkbooks_BASE
+{
+private:
+	css::uno::Reference< oo::vba::XGlobals > getGlobals() throw (css::uno::RuntimeException);
+	bool 	isTextFile( const rtl::OUString& rString );
+	static sal_Int16& getCurrentDelim(){ static sal_Int16 nDelim = 44; return nDelim; }
+public:
+	ScVbaWorkbooks( const css::uno::Reference< css::uno::XComponentContext >& xContext );
+	virtual ~ScVbaWorkbooks() {}
+
+	// XEnumerationAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+	// ScVbaCollectionBaseImpl	
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ); 
+
+	// XWorkbooks
+	virtual css::uno::Any SAL_CALL Add() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL Close(  ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL Open( const ::rtl::OUString& Filename, const css::uno::Any& UpdateLinks, const css::uno::Any& ReadOnly, const css::uno::Any& Format, const css::uno::Any& Password, const css::uno::Any& WriteResPassword, const css::uno::Any& IgnoreReadOnlyRecommended, const css::uno::Any& Origin, const css::uno::Any& Delimiter, const css::uno::Any& Editable, const css::uno::Any& Notify, const css::uno::Any& Converter, const css::uno::Any& AddToMru ) throw (css::uno::RuntimeException);
+};
+
+#endif /* SC_VBA_WORKBOOKS_HXX */
Index: sc/source/ui/vba/vbaworksheet.cxx
===================================================================
RCS file: sc/source/ui/vba/vbaworksheet.cxx
diff -N sc/source/ui/vba/vbaworksheet.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbaworksheet.cxx	21 Feb 2007 17:29:24 -0000	1.1.2.2
@@ -0,0 +1,660 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include <cppuhelper/queryinterface.hxx>
+
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/beans/XIntrospectionAccess.hpp>
+#include <com/sun/star/container/XNamed.hpp>
+#include <com/sun/star/util/XProtectable.hpp>
+#include <com/sun/star/table/XCellRange.hpp>
+#include <com/sun/star/sheet/XSpreadsheetView.hpp>
+#include <com/sun/star/sheet/XSpreadsheetDocument.hpp>
+#include <com/sun/star/sheet/XCalculatable.hpp>
+#include <com/sun/star/sheet/XCellRangeAddressable.hpp>
+#include <com/sun/star/sheet/XSheetCellRange.hpp>
+#include <com/sun/star/sheet/XSheetCellCursor.hpp>
+#include <com/sun/star/sheet/XSheetAnnotationsSupplier.hpp>
+#include <com/sun/star/sheet/XUsedAreaCursor.hpp>
+#include <com/sun/star/sheet/XSpreadsheets.hpp>
+#include <com/sun/star/sheet/XSheetPastable.hpp>
+#include <com/sun/star/sheet/XCellAddressable.hpp>
+#include <com/sun/star/sheet/XSheetOutline.hpp>
+#include <com/sun/star/sheet/XDataPilotTablesSupplier.hpp>
+#include <cppuhelper/bootstrap.hxx>
+#include <com/sun/star/util/XURLTransformer.hpp>
+#include <com/sun/star/frame/XDispatchProvider.hpp>
+#include <com/sun/star/frame/XComponentLoader.hpp>
+#include <com/sun/star/table/XColumnRowRange.hpp>
+#include <com/sun/star/table/XTableChartsSupplier.hpp>
+#include <com/sun/star/drawing/XDrawPageSupplier.hpp>
+#include <com/sun/star/drawing/XControlShape.hpp>
+#include <com/sun/star/form/FormComponentType.hpp>
+#include <tools/string.hxx>
+
+#include <svx/svdouno.hxx>
+
+#include "cellsuno.hxx"
+#include "drwlayer.hxx"
+
+#include "vbaoutline.hxx"
+#include "vbarange.hxx"
+#include "vbacomments.hxx"
+#include "vbaworksheet.hxx"
+#include "vbachartobjects.hxx"
+#include "vbapivottables.hxx"
+#include "vbacombobox.hxx"
+
+#define STANDARDWIDTH 2267 
+#define STANDARDHEIGHT 427
+#define DOESNOTEXIST -1
+using namespace com::sun::star;
+using namespace org::openoffice;
+static bool 
+nameExists( uno::Reference <sheet::XSpreadsheetDocument>& xSpreadDoc, ::rtl::OUString & name, SCTAB& nTab ) throw ( lang::IllegalArgumentException )
+{
+	if (!xSpreadDoc.is())
+		throw lang::IllegalArgumentException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "nameExists() xSpreadDoc is null" ) ), uno::Reference< uno::XInterface  >(), 1 );	
+	uno::Reference <sheet::XSpreadsheets> xSheets = xSpreadDoc->getSheets();
+	uno::Reference <container::XIndexAccess> xIndex( xSheets, uno::UNO_QUERY );
+	if ( xIndex.is() )
+	{
+		SCTAB  nCount = static_cast< SCTAB >( xIndex->getCount() );
+		for (SCTAB i=0; i < nCount; i++)
+		{
+			uno::Reference< sheet::XSpreadsheet > xSheet(xIndex->getByIndex(i), uno::UNO_QUERY);
+			uno::Reference< container::XNamed > xNamed( xSheet, uno::UNO_QUERY_THROW );
+			if (xNamed->getName() == name)
+			{
+				nTab = i;
+				return true;
+			}
+		}
+	}
+	return false;
+}
+
+static void getNewSpreadsheetName (rtl::OUString &aNewName, rtl::OUString aOldName, uno::Reference <sheet::XSpreadsheetDocument>& xSpreadDoc )
+{
+	if (!xSpreadDoc.is())
+		throw lang::IllegalArgumentException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "getNewSpreadsheetName() xSpreadDoc is null" ) ), uno::Reference< uno::XInterface  >(), 1 );	
+	static rtl::OUString aUnderScre( RTL_CONSTASCII_USTRINGPARAM( "_" ) );
+	int currentNum =2;
+	aNewName = aOldName + aUnderScre+ String::CreateFromInt32(currentNum) ;
+	SCTAB nTab = 0;
+	while ( nameExists(xSpreadDoc,aNewName, nTab ) )
+	{
+		aNewName = aOldName + aUnderScre +
+		String::CreateFromInt32(++currentNum) ;
+	}
+}
+
+static void removeAllSheets( uno::Reference <sheet::XSpreadsheetDocument>& xSpreadDoc, rtl::OUString aSheetName)
+{
+	if (!xSpreadDoc.is())
+		throw lang::IllegalArgumentException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "removeAllSheets() xSpreadDoc is null" ) ), uno::Reference< uno::XInterface  >(), 1 );	
+	uno::Reference<sheet::XSpreadsheets> xSheets = xSpreadDoc->getSheets();
+	uno::Reference <container::XIndexAccess> xIndex( xSheets, uno::UNO_QUERY );
+
+	if ( xIndex.is() )
+	{
+		uno::Reference<container::XNameContainer> xNameContainer(xSheets,uno::UNO_QUERY_THROW);
+		for (sal_Int32 i = xIndex->getCount() -1; i>= 1; i--)
+		{
+			uno::Reference< sheet::XSpreadsheet > xSheet(xIndex->getByIndex(i), uno::UNO_QUERY);
+			uno::Reference< container::XNamed > xNamed( xSheet, uno::UNO_QUERY_THROW );
+			if (xNamed.is())
+			{
+				xNameContainer->removeByName(xNamed->getName());
+			}
+		}
+
+		uno::Reference< sheet::XSpreadsheet > xSheet(xIndex->getByIndex(0), uno::UNO_QUERY);                uno::Reference< container::XNamed > xNamed( xSheet, uno::UNO_QUERY_THROW );
+		if (xNamed.is())
+		{
+			xNamed->setName(aSheetName);
+		}
+	}
+}
+
+static uno::Reference<frame::XModel>
+openNewDoc(rtl::OUString aSheetName )
+{
+	uno::Reference<frame::XModel> xModel;
+	try
+	{
+		uno::Reference<uno::XComponentContext > xContext(  ::cppu::defaultBootstrap_InitialComponentContext(), uno::UNO_QUERY_THROW );
+		uno::Reference<lang::XMultiComponentFactory > xServiceManager(
+										xContext->getServiceManager(), uno::UNO_QUERY_THROW );
+
+		uno::Reference <frame::XComponentLoader > xComponentLoader(
+						xServiceManager->createInstanceWithContext(
+						rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.frame.Desktop" ) ),
+						xContext ), uno::UNO_QUERY_THROW );
+
+		uno::Reference<lang::XComponent > xComponent( xComponentLoader->loadComponentFromURL(
+				rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "private:factory/scalc" ) ),
+				rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "_blank" ) ), 0,
+				uno::Sequence < ::com::sun::star::beans::PropertyValue >() ) );
+		uno::Reference <sheet::XSpreadsheetDocument> xSpreadDoc( xComponent, uno::UNO_QUERY_THROW );
+		if ( xSpreadDoc.is() )
+		{
+			removeAllSheets(xSpreadDoc,aSheetName);
+		}
+		xModel.set(xSpreadDoc,uno::UNO_QUERY_THROW);
+	}
+	catch ( ::cppu::BootstrapException & /*e*/ )    
+	{
+	}
+	catch ( uno::Exception & /*e*/ )
+	{
+	}
+	return xModel;
+}
+
+
+ScVbaWorksheet::ScVbaWorksheet( const uno::Reference< uno::XComponentContext >& xContext ): m_xContext( xContext ) 
+{
+}
+ScVbaWorksheet::ScVbaWorksheet(const uno::Reference< uno::XComponentContext >& xContext,
+		const uno::Reference< sheet::XSpreadsheet >& xSheet, 
+		const uno::Reference< frame::XModel >& xModel ) throw (uno::RuntimeException) : m_xContext(xContext), mxSheet( xSheet ), mxModel(xModel)
+{
+}
+
+::rtl::OUString
+ScVbaWorksheet::getName() throw (uno::RuntimeException)
+{
+	uno::Reference< container::XNamed > xNamed( getSheet(), uno::UNO_QUERY_THROW );
+	return xNamed->getName();
+}
+
+void
+ScVbaWorksheet::setName(const ::rtl::OUString &rName ) throw (uno::RuntimeException)
+{
+	uno::Reference< container::XNamed > xNamed( getSheet(), uno::UNO_QUERY_THROW );
+	xNamed->setName( rName );
+}
+
+sal_Bool
+ScVbaWorksheet::getVisible() throw (uno::RuntimeException)
+{
+	uno::Reference< beans::XPropertySet > xProps( getSheet(), uno::UNO_QUERY_THROW );
+	uno::Any aValue = xProps->getPropertyValue
+			(rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "IsVisible" ) ) );
+	sal_Bool bRet = false;
+	aValue >>= bRet;
+	return bRet;
+}
+
+void
+ScVbaWorksheet::setVisible( sal_Bool bVisible ) throw (uno::RuntimeException)
+{
+	uno::Reference< beans::XPropertySet > xProps( getSheet(), uno::UNO_QUERY_THROW );
+	uno::Any aValue( bVisible );
+	xProps->setPropertyValue
+			(rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "IsVisible" ) ), aValue);
+}
+
+uno::Reference< excel::XRange > 
+ScVbaWorksheet::getUsedRange() throw (uno::RuntimeException)
+{
+ 	uno::Reference< sheet::XSheetCellRange > xSheetCellRange(getSheet(), uno::UNO_QUERY_THROW );
+	uno::Reference< sheet::XSheetCellCursor > xSheetCellCursor( getSheet()->createCursorByRange( xSheetCellRange ), uno::UNO_QUERY_THROW );
+	uno::Reference<sheet::XUsedAreaCursor> xUsedCursor(xSheetCellCursor,uno::UNO_QUERY_THROW);
+	xUsedCursor->gotoStartOfUsedArea( false );
+	xUsedCursor->gotoEndOfUsedArea( true );
+	uno::Reference< table::XCellRange > xRange( xSheetCellCursor, uno::UNO_QUERY);
+	return new ScVbaRange(m_xContext, xRange);
+}
+
+uno::Reference< excel::XOutline >
+ScVbaWorksheet::Outline( ) throw (uno::RuntimeException)
+{
+	uno::Reference<sheet::XSheetOutline> xOutline(getSheet(),uno::UNO_QUERY_THROW);
+	return uno::Reference<excel::XOutline> (new ScVbaOutline(m_xContext, xOutline));
+}
+
+sal_Int32 
+ScVbaWorksheet::getStandardWidth() throw (uno::RuntimeException)
+{
+	return STANDARDWIDTH ;
+}
+
+sal_Int32 
+ScVbaWorksheet::getStandardHeight() throw (uno::RuntimeException)
+{
+	return STANDARDHEIGHT;
+}
+
+sal_Bool 
+ScVbaWorksheet::getProtectionMode() throw (uno::RuntimeException) 
+{
+	return false;
+}
+
+sal_Bool
+ScVbaWorksheet::getProtectContents()throw (uno::RuntimeException) 
+{
+	uno::Reference<util::XProtectable > xProtectable(getSheet(), uno::UNO_QUERY_THROW);
+	return xProtectable->isProtected();
+}
+
+sal_Bool 
+ScVbaWorksheet::getProtectDrawingObjects() throw (uno::RuntimeException) 
+{
+	return false;
+}
+
+void
+ScVbaWorksheet::Activate() throw (uno::RuntimeException)
+{
+	uno::Reference< sheet::XSpreadsheetView > xSpreadsheet(
+        	getModel()->getCurrentController(), uno::UNO_QUERY_THROW );
+	xSpreadsheet->setActiveSheet(getSheet());	
+}
+
+void
+ScVbaWorksheet::Select() throw (uno::RuntimeException)
+{
+	Activate();
+}
+
+void 
+ScVbaWorksheet::Move( const uno::Any& Before, const uno::Any& After ) throw (uno::RuntimeException) 
+{
+	rtl::OUString aSheetName;
+	uno::Reference<excel::XWorksheet> xSheet;
+	rtl::OUString aCurrSheetName =getName();
+
+	if (!(Before >>= xSheet) && !(After >>=xSheet)&& !(Before.hasValue()) && !(After.hasValue()))
+	{
+		uno::Reference< sheet::XSheetCellCursor > xSheetCellCursor = getSheet()->createCursor( );
+		uno::Reference<sheet::XUsedAreaCursor> xUsedCursor(xSheetCellCursor,uno::UNO_QUERY_THROW);
+        	uno::Reference< table::XCellRange > xRange1( xSheetCellCursor, uno::UNO_QUERY);
+		uno::Reference<excel::XRange> xRange =  new ScVbaRange(m_xContext, xRange1);
+		if (xRange.is())
+			xRange->Select();
+		implnCopy();
+		uno::Reference<frame::XModel> xModel = openNewDoc(aCurrSheetName);
+		if (xModel.is()) 
+		{
+			implnPaste();
+			Delete();
+		}
+		return ;
+	}
+
+	uno::Reference <sheet::XSpreadsheetDocument> xSpreadDoc( getModel(), uno::UNO_QUERY_THROW );
+	SCTAB nDest = 0;
+	aSheetName = xSheet->getName();
+	bool bSheetExists = nameExists (xSpreadDoc, aSheetName, nDest);
+	if ( bSheetExists )
+	{
+		sal_Bool bAfter = After.hasValue();
+		if (bAfter)  
+			nDest++;
+		uno::Reference<sheet::XSpreadsheets> xSheets = xSpreadDoc->getSheets();
+		xSheets->moveByName(aCurrSheetName,nDest);
+	}
+}
+
+void 
+ScVbaWorksheet::Copy( const uno::Any& Before, const uno::Any& After ) throw (uno::RuntimeException) 
+{
+	rtl::OUString aSheetName;
+	uno::Reference<excel::XWorksheet> xSheet;
+	rtl::OUString aCurrSheetName =getName();
+	if (!(Before >>= xSheet) && !(After >>=xSheet)&& !(Before.hasValue()) && !(After.hasValue()))
+	{
+		uno::Reference< sheet::XSheetCellCursor > xSheetCellCursor = getSheet()->createCursor( );
+		uno::Reference<sheet::XUsedAreaCursor> xUsedCursor(xSheetCellCursor,uno::UNO_QUERY_THROW);
+        	uno::Reference< table::XCellRange > xRange1( xSheetCellCursor, uno::UNO_QUERY);
+		uno::Reference<excel::XRange> xRange =  new ScVbaRange(m_xContext, xRange1);
+		if (xRange.is())
+			xRange->Select();
+		implnCopy();
+		uno::Reference<frame::XModel> xModel = openNewDoc(aCurrSheetName);
+		if (xModel.is())
+		{
+			implnPaste();
+		}
+		return;
+	}
+
+	uno::Reference <sheet::XSpreadsheetDocument> xSpreadDoc( getModel(), uno::UNO_QUERY );
+	SCTAB nDest = 0;
+	aSheetName = xSheet->getName();
+	bool bSheetExists = nameExists (xSpreadDoc, aSheetName, nDest );
+
+	if ( bSheetExists )
+	{
+		sal_Bool bAfter = After.hasValue();
+		if(bAfter)
+			  nDest++;
+		uno::Reference<sheet::XSpreadsheets> xSheets = xSpreadDoc->getSheets();
+		getNewSpreadsheetName(aSheetName,aCurrSheetName,xSpreadDoc);
+		xSheets->copyByName(aCurrSheetName,aSheetName,nDest);
+	}
+}
+
+
+void 
+ScVbaWorksheet::Paste( const uno::Any& Destination, const uno::Any& /*Link*/ ) throw (uno::RuntimeException)
+{
+	// #TODO# #FIXME# Link is not used
+	uno::Reference<excel::XRange> xRange( Destination, uno::UNO_QUERY );
+	if ( xRange.is() )
+		xRange->Select();
+	implnPaste();
+}
+
+void 
+ScVbaWorksheet::Delete() throw (uno::RuntimeException)
+{
+	uno::Reference <sheet::XSpreadsheetDocument> xSpreadDoc( getModel(), uno::UNO_QUERY_THROW );
+	rtl::OUString aSheetName = getName();
+	if ( xSpreadDoc.is() )
+	{
+		SCTAB nTab = 0;
+		if (!nameExists(xSpreadDoc, aSheetName, nTab )) 
+		{
+			return;
+		}
+		uno::Reference<sheet::XSpreadsheets> xSheets = xSpreadDoc->getSheets();
+		uno::Reference<container::XNameContainer> xNameContainer(xSheets,uno::UNO_QUERY_THROW);
+		xNameContainer->removeByName(aSheetName);
+	}
+}
+
+uno::Reference< excel::XWorksheet >
+ScVbaWorksheet::getSheetAtOffset(SCTAB offset) throw (uno::RuntimeException)
+{
+	uno::Reference <sheet::XSpreadsheetDocument> xSpreadDoc( getModel(), uno::UNO_QUERY_THROW );
+	uno::Reference <sheet::XSpreadsheets> xSheets( xSpreadDoc->getSheets(), uno::UNO_QUERY_THROW );
+	uno::Reference <container::XIndexAccess> xIndex( xSheets, uno::UNO_QUERY_THROW );
+
+	rtl::OUString aName = getName();
+	SCTAB nIdx = 0;
+	bool bSheetExists = nameExists (xSpreadDoc, aName, nIdx );
+
+	if ( !bSheetExists )
+		return uno::Reference< excel::XWorksheet >(); 
+	nIdx = nIdx + offset;
+	uno::Reference< sheet::XSpreadsheet > xSheet(xIndex->getByIndex(nIdx), uno::UNO_QUERY_THROW);
+	return new ScVbaWorksheet (m_xContext, xSheet, getModel());
+}
+
+uno::Reference< excel::XWorksheet >
+ScVbaWorksheet::getNext() throw (uno::RuntimeException)
+{
+	return getSheetAtOffset(static_cast<SCTAB>(1));
+}
+
+uno::Reference< excel::XWorksheet >
+ScVbaWorksheet::getPrevious() throw (uno::RuntimeException)
+{
+	return getSheetAtOffset(-1);
+}
+
+
+void
+ScVbaWorksheet::Protect( const uno::Any& Password, const uno::Any& /*DrawingObjects*/, const uno::Any& /*Contents*/, const uno::Any& /*Scenarios*/, const uno::Any& /*UserInterfaceOnly*/ ) throw (uno::RuntimeException)
+{
+	// #TODO# #FIXME# is there anything we can do witht the unused param
+	// can the implementation use anything else here
+	uno::Reference<util::XProtectable > xProtectable(getSheet(), uno::UNO_QUERY_THROW);
+	::rtl::OUString aPasswd;
+	Password >>= aPasswd;
+	xProtectable->protect( aPasswd );
+}
+
+void 
+ScVbaWorksheet::Unprotect( const uno::Any& Password ) throw (uno::RuntimeException)
+{
+	uno::Reference<util::XProtectable > xProtectable(getSheet(), uno::UNO_QUERY_THROW);
+	::rtl::OUString aPasswd;
+	Password >>= aPasswd;
+	xProtectable->unprotect( aPasswd );
+}
+
+void 
+ScVbaWorksheet::Calculate() throw (uno::RuntimeException)
+{
+	uno::Reference <sheet::XCalculatable> xReCalculate(getModel(), uno::UNO_QUERY_THROW);
+	xReCalculate->calculate();
+}
+
+uno::Reference< excel::XRange >
+ScVbaWorksheet::Range( const ::uno::Any& Cell1, const ::uno::Any& Cell2 ) throw (uno::RuntimeException)
+{
+	uno::Reference< excel::XRange > xSheetRange( new ScVbaRange( m_xContext 
+, uno::Reference< table::XCellRange >( getSheet(), uno::UNO_QUERY_THROW ) ) );
+	return xSheetRange->Range( Cell1, Cell2 );
+}
+
+void
+ScVbaWorksheet::CheckSpelling( const uno::Any& /*CustomDictionary*/,const uno::Any& /*IgnoreUppercase*/,const uno::Any& /*AlwaysSuggest*/, const uno::Any& /*SpellingLang*/ ) throw (uno::RuntimeException)
+{
+	// #TODO# #FIXME# unused params above, can we do anything with those
+	rtl::OUString url = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ".uno:SpellDialog"));
+	uno::Reference< frame::XModel > xModel( getModel() );
+	dispatchRequests(xModel,url);
+}
+
+uno::Reference< excel::XRange > 
+ScVbaWorksheet::getSheetRange() throw (uno::RuntimeException)
+{
+	uno::Reference< table::XCellRange > xRange( getSheet(),uno::UNO_QUERY_THROW );
+	return uno::Reference< excel::XRange >( new ScVbaRange( m_xContext, xRange ) );
+}
+
+// These are hacks - we prolly (somehow) need to inherit
+// the vbarange functionality here ...
+uno::Reference< excel::XRange > 
+ScVbaWorksheet::Cells( const ::uno::Any &nRow, const ::uno::Any &nCol )
+		throw (uno::RuntimeException)
+{
+	return getSheetRange()->Cells( nRow, nCol );
+}
+
+uno::Reference< excel::XRange >
+ScVbaWorksheet::Rows(const uno::Any& aIndex ) throw (uno::RuntimeException)
+{
+	return getSheetRange()->Rows( aIndex );
+}
+
+uno::Reference< excel::XRange >
+ScVbaWorksheet::Columns( const uno::Any& aIndex ) throw (uno::RuntimeException)
+{
+	return getSheetRange()->Columns( aIndex );
+}
+
+uno::Any SAL_CALL 
+ScVbaWorksheet::ChartObjects( const uno::Any& Index ) throw (uno::RuntimeException)
+{
+	if ( !mxCharts.is() )
+	{
+		uno::Reference< table::XTableChartsSupplier > xChartSupplier( getSheet(), uno::UNO_QUERY_THROW );
+		uno::Reference< table::XTableCharts > xTableCharts = xChartSupplier->getCharts();
+		
+		mxCharts = new ScVbaChartObjects( m_xContext, xTableCharts );
+	}
+	if ( Index.hasValue() )
+	{
+		uno::Reference< vba::XCollection > xColl( mxCharts, uno::UNO_QUERY_THROW );
+		return xColl->Item( Index );
+	}
+	else
+		return makeAny( mxCharts );
+	
+}
+
+uno::Any SAL_CALL 
+ScVbaWorksheet::PivotTables( const uno::Any& Index ) throw (uno::RuntimeException)
+{
+	uno::Reference< css::sheet::XSpreadsheet > xSheet = getSheet();
+	uno::Reference< sheet::XDataPilotTablesSupplier > xTables(xSheet, uno::UNO_QUERY_THROW ) ;
+	uno::Reference< container::XIndexAccess > xIndexAccess( xTables->getDataPilotTables(), uno::UNO_QUERY_THROW );
+
+	uno::Reference< vba::XCollection > xColl( uno::Reference< excel::XPivotTables > ( new ScVbaPivotTables( m_xContext, xIndexAccess ) ), uno::UNO_QUERY_THROW );
+	if ( Index.hasValue() )
+		return xColl->Item( Index );
+	return makeAny( xColl );
+}
+
+uno::Any SAL_CALL
+ScVbaWorksheet::Comments( const uno::Any& Index ) throw (uno::RuntimeException)
+{
+	uno::Reference< css::sheet::XSpreadsheet > xSheet = getSheet();
+	uno::Reference< sheet::XSheetAnnotationsSupplier > xAnnosSupp( xSheet, uno::UNO_QUERY_THROW );
+	uno::Reference< sheet::XSheetAnnotations > xAnnos( xAnnosSupp->getAnnotations(), uno::UNO_QUERY_THROW );
+	uno::Reference< container::XIndexAccess > xIndexAccess( xAnnos, uno::UNO_QUERY_THROW );
+
+	uno::Reference< vba::XCollection > xColl( uno::Reference< excel::XComments > ( new ScVbaComments( m_xContext, xIndexAccess ) ), uno::UNO_QUERY_THROW );
+	if ( Index.hasValue() )
+		return xColl->Item( Index );
+	return makeAny( xColl );
+}
+
+uno::Any SAL_CALL 
+ScVbaWorksheet::Evaluate( const ::rtl::OUString& Name ) throw (uno::RuntimeException)
+{
+	// #TODO Evaluate allows other things to be evaluated, e.g. functions
+	// I think ( like SIN(3) etc. ) need to investigate that
+	// named Ranges also? e.g. [MyRange] if so need a list of named ranges
+	uno::Any aVoid;
+	return uno::Any( Range( uno::Any( Name ), aVoid ) );		
+}
+
+
+uno::Reference< beans::XIntrospectionAccess > SAL_CALL 
+ScVbaWorksheet::getIntrospection(  ) throw (uno::RuntimeException)
+{
+	return uno::Reference< beans::XIntrospectionAccess >();
+}
+
+uno::Any SAL_CALL 
+ScVbaWorksheet::invoke( const ::rtl::OUString& aFunctionName, const uno::Sequence< uno::Any >& /*aParams*/, uno::Sequence< ::sal_Int16 >& /*aOutParamIndex*/, uno::Sequence< uno::Any >& /*aOutParam*/ ) throw (lang::IllegalArgumentException, script::CannotConvertException, reflection::InvocationTargetException, uno::RuntimeException)
+{
+	OSL_TRACE("** ScVbaWorksheet::invoke( %s ), will barf",
+		rtl::OUStringToOString( aFunctionName, RTL_TEXTENCODING_UTF8 ).getStr() );
+	
+	throw uno::RuntimeException(); // unsupported operation
+}
+
+void SAL_CALL 
+ScVbaWorksheet::setValue( const ::rtl::OUString& /*aPropertyName*/, const uno::Any& /*aValue*/ ) throw (beans::UnknownPropertyException, script::CannotConvertException, reflection::InvocationTargetException, uno::RuntimeException)
+{
+	throw uno::RuntimeException(); // unsupported operation
+}
+uno::Any SAL_CALL 
+ScVbaWorksheet::getValue( const ::rtl::OUString& aPropertyName ) throw (beans::UnknownPropertyException, uno::RuntimeException)
+{
+	uno::Any aProp = getControl( aPropertyName );
+	if ( !aProp.hasValue() )
+		throw beans::UnknownPropertyException(); // unsupported operation
+	// #TODO we need a factory here when we support
+	// more control types
+	sal_Int32 nClassId = -1;	
+	uno::Reference< beans::XPropertySet > xProps( aProp, uno::UNO_QUERY_THROW );	
+	const static rtl::OUString sClassId( RTL_CONSTASCII_USTRINGPARAM("ClassId") );
+	xProps->getPropertyValue( sClassId ) >>= nClassId;
+	if ( nClassId == form::FormComponentType::COMBOBOX )
+	{
+		uno::Reference< msforms::XComboBox > xCbx( new ScVbaComboBox( m_xContext, xProps ) ); 
+		return uno::makeAny( xCbx );
+	}
+
+	return aProp;
+}
+
+::sal_Bool SAL_CALL 
+ScVbaWorksheet::hasMethod( const ::rtl::OUString& /*aName*/ ) throw (uno::RuntimeException)
+{
+	return sal_False;
+}
+::sal_Bool SAL_CALL 
+ScVbaWorksheet::hasProperty( const ::rtl::OUString& aName ) throw (uno::RuntimeException)
+{
+	if ( getControl( aName ).hasValue() )
+		return sal_True;
+	return sal_False;
+}
+uno::Any 
+ScVbaWorksheet::getControl( const ::rtl::OUString& sName )
+{
+	uno::Reference< sheet::XScenarioEnhanced > xIf( getSheet(), uno::UNO_QUERY_THROW );
+	ScTableSheetObj* pTab= static_cast< ScTableSheetObj* >( xIf.get() );
+	ScDocShell* pShell = NULL;
+	if ( pTab ) 
+		pShell = pTab->GetDocShell();
+	if ( pShell )
+	{
+		ScDrawLayer* pDrawLayer = pShell->MakeDrawLayer();
+		SCTAB nTab = 0;
+		// make GetTab_Impl() public or this class a friend
+		const ScRangeList& rRanges = pTab->GetRangeList();
+		const ScRange* pFirst = rRanges.GetObject(0);
+		if (pFirst)
+			nTab = pFirst->aStart.Tab();
+
+		SdrPage* pPage = pDrawLayer->GetPage(static_cast<sal_uInt16>(nTab));
+		if ( pPage )
+		{
+			ULONG nCount = pPage->GetObjCount(); 
+			for ( ULONG index=0; index<nCount; ++index )
+			{
+				SdrObject* pObj = pPage->GetObj( index );
+				if ( pObj )
+				{
+					
+					SdrUnoObj* pUnoObj = PTR_CAST(SdrUnoObj, pObj);
+					if ( pUnoObj )
+					{
+						uno::Reference< container::XNamed > xNamed( pUnoObj->GetUnoControlModel(), uno::UNO_QUERY_THROW );
+						if ( sName.equals( xNamed->getName() ) )
+							return uno::makeAny( xNamed );
+					}
+				}
+			}
+		}
+	}
+
+	return uno::Any();
+}
+
+
+
+
Index: sc/source/ui/vba/vbaworksheet.hxx
===================================================================
RCS file: sc/source/ui/vba/vbaworksheet.hxx
diff -N sc/source/ui/vba/vbaworksheet.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbaworksheet.hxx	21 Feb 2007 17:29:24 -0000	1.1.2.2
@@ -0,0 +1,127 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_WORKSHEET_HXX
+#define SC_VBA_WORKSHEET_HXX
+
+#include <cppuhelper/implbase2.hxx>
+#include <com/sun/star/sheet/XSpreadsheet.hpp>
+#include <com/sun/star/script/XInvocation.hpp>
+#include <org/openoffice/excel/XWorksheet.hpp>
+#include <org/openoffice/excel/XComments.hpp>
+#include <org/openoffice/excel/XRange.hpp>
+#include <com/sun/star/lang/XEventListener.hpp>
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <com/sun/star/frame/XModel.hpp>
+#include <org/openoffice/excel/XOutline.hpp>
+#include <org/openoffice/excel/XChartObjects.hpp>
+
+#include "vbahelper.hxx"
+
+class ScVbaWorksheet : public ::cppu::WeakImplHelper2<oo::excel::XWorksheet, css::script::XInvocation > 
+{
+	css::uno::Reference< css::uno::XComponentContext > m_xContext;
+	css::uno::Reference< css::sheet::XSpreadsheet > mxSheet;
+	css::uno::Reference< css::frame::XModel > mxModel;
+	css::uno::Reference< oo::excel::XChartObjects > mxCharts;
+		
+	css::uno::Reference< oo::excel::XWorksheet > getSheetAtOffset(SCTAB offset) throw (css::uno::RuntimeException);
+	css::uno::Reference< oo::excel::XRange > getSheetRange() throw (css::uno::RuntimeException);
+
+	css::uno::Any getControl( const rtl::OUString& sName );
+protected:
+
+	virtual css::uno::Reference< css::frame::XModel > getModel()
+	{ return mxModel; }
+	virtual css::uno::Reference< css::sheet::XSpreadsheet > getSheet()
+	{ return mxSheet; }
+	ScVbaWorksheet( const css::uno::Reference< css::uno::XComponentContext >& xContext );
+public:
+	ScVbaWorksheet( 
+		const css::uno::Reference< css::uno::XComponentContext >& xContext,
+		const css::uno::Reference< css::sheet::XSpreadsheet >& xSheet, 
+		const css::uno::Reference< css::frame::XModel >& xModel )throw (css::uno::RuntimeException)  ;
+
+	virtual ~ScVbaWorksheet() {}
+
+
+    // Attributes
+	virtual ::rtl::OUString SAL_CALL getName() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setName( const ::rtl::OUString &rName ) throw (css::uno::RuntimeException);
+	virtual sal_Bool SAL_CALL getVisible() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setVisible( sal_Bool bVisible ) throw (css::uno::RuntimeException);
+	virtual ::sal_Int32 SAL_CALL getStandardWidth() throw (css::uno::RuntimeException);
+	virtual ::sal_Int32 SAL_CALL getStandardHeight() throw (css::uno::RuntimeException);
+	virtual ::sal_Bool SAL_CALL getProtectionMode() throw (css::uno::RuntimeException);
+	virtual ::sal_Bool SAL_CALL getProtectContents() throw (css::uno::RuntimeException);
+	virtual ::sal_Bool SAL_CALL getProtectDrawingObjects() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< oo::excel::XRange > SAL_CALL getUsedRange() throw (css::uno::RuntimeException) ;
+	virtual css::uno::Any SAL_CALL ChartObjects( const css::uno::Any& Index ) throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< oo::excel::XOutline > SAL_CALL Outline( ) throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< oo::excel::XWorksheet > SAL_CALL getNext() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< oo::excel::XWorksheet > SAL_CALL getPrevious() throw (css::uno::RuntimeException);
+
+    // Methods
+	virtual void SAL_CALL Activate() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL Select() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< oo::excel::XRange > SAL_CALL Range( const css::uno::Any& Cell1, const css::uno::Any& Cell2 ) throw (css::uno::RuntimeException);
+	virtual void SAL_CALL Move( const css::uno::Any& Before, const css::uno::Any& After ) throw (css::uno::RuntimeException) ;
+ 	virtual void SAL_CALL Copy( const css::uno::Any& Before, const css::uno::Any& After ) throw (css::uno::RuntimeException);
+	virtual void SAL_CALL Paste( const css::uno::Any& Destination, const css::uno::Any& Link ) throw (css::uno::RuntimeException);
+	virtual void SAL_CALL Delete(  ) throw (css::uno::RuntimeException);
+	virtual void SAL_CALL Protect( const css::uno::Any& Password, const css::uno::Any& DrawingObjects, const css::uno::Any& Contents, const css::uno::Any& Scenarios, const css::uno::Any& UserInterfaceOnly ) throw (css::uno::RuntimeException);
+	virtual void SAL_CALL Unprotect( const css::uno::Any& Password ) throw (css::uno::RuntimeException);
+
+	virtual void SAL_CALL Calculate(  ) throw (css::uno::RuntimeException);
+	virtual void SAL_CALL CheckSpelling( const css::uno::Any& CustomDictionary,const css::uno::Any& IgnoreUppercase,const css::uno::Any& AlwaysSuggest, const css::uno::Any& SpellingLang ) throw (css::uno::RuntimeException);
+	// Hacks (?)
+	virtual css::uno::Reference< oo::excel::XRange > SAL_CALL Cells( const css::uno::Any &nRow, const css::uno::Any &nCol ) throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< oo::excel::XRange > SAL_CALL Rows(const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< oo::excel::XRange > SAL_CALL Columns(const css::uno::Any& aIndex ) throw (css::uno::RuntimeException);
+
+	virtual css::uno::Any SAL_CALL Evaluate( const ::rtl::OUString& Name ) throw (css::uno::RuntimeException); 
+	virtual css::uno::Any SAL_CALL PivotTables( const css::uno::Any& Index ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL Comments( const css::uno::Any& Index ) throw (css::uno::RuntimeException);
+
+	// XInvocation
+	virtual css::uno::Reference< css::beans::XIntrospectionAccess > SAL_CALL getIntrospection(  ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL invoke( const ::rtl::OUString& aFunctionName, const css::uno::Sequence< css::uno::Any >& aParams, css::uno::Sequence< ::sal_Int16 >& aOutParamIndex, css::uno::Sequence< css::uno::Any >& aOutParam ) throw (css::lang::IllegalArgumentException, css::script::CannotConvertException, css::reflection::InvocationTargetException, css::uno::RuntimeException);
+	virtual void SAL_CALL setValue( const ::rtl::OUString& aPropertyName, const css::uno::Any& aValue ) throw (css::beans::UnknownPropertyException, css::script::CannotConvertException, css::reflection::InvocationTargetException, css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL getValue( const ::rtl::OUString& aPropertyName ) throw (css::beans::UnknownPropertyException, css::uno::RuntimeException);
+	virtual ::sal_Bool SAL_CALL hasMethod( const ::rtl::OUString& aName ) throw (css::uno::RuntimeException);
+	virtual ::sal_Bool SAL_CALL hasProperty( const ::rtl::OUString& aName ) throw (css::uno::RuntimeException);
+};
+
+#endif /* SC_VBA_WORKSHEET_HXX */
+
Index: sc/source/ui/vba/vbaworksheets.cxx
===================================================================
RCS file: sc/source/ui/vba/vbaworksheets.cxx
diff -N sc/source/ui/vba/vbaworksheets.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbaworksheets.cxx	21 Feb 2007 17:29:24 -0000	1.1.2.2
@@ -0,0 +1,253 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "vbaworksheets.hxx"
+
+#include <sfx2/dispatch.hxx>
+#include <sfx2/app.hxx>
+#include <sfx2/bindings.hxx>
+#include <sfx2/request.hxx>
+#include <sfx2/viewfrm.hxx>
+#include <sfx2/itemwrapper.hxx>
+#include <svtools/itemset.hxx>
+#include <svtools/eitem.hxx>
+
+#include <comphelper/processfactory.hxx>
+#include <cppuhelper/implbase3.hxx>
+
+#include <com/sun/star/sheet/XSpreadsheetDocument.hpp>
+#include <com/sun/star/container/XEnumerationAccess.hpp>
+#include <com/sun/star/sheet/XSpreadsheetView.hpp>
+#include <com/sun/star/container/XNamed.hpp>
+#include <com/sun/star/lang/IndexOutOfBoundsException.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+
+#include <org/openoffice/excel/XApplication.hpp>
+#include <tools/string.hxx>
+
+#include "vbaglobals.hxx"
+#include "vbaworksheet.hxx"
+#include "vbaworkbook.hxx"
+
+using namespace ::org::openoffice;
+using namespace ::com::sun::star;
+
+
+class SheetsEnumeration : public EnumerationHelperImpl
+{
+	uno::Reference< frame::XModel > m_xModel;
+public:
+	SheetsEnumeration( const uno::Reference< uno::XComponentContext >& xContext, const uno::Reference< container::XEnumeration >& xEnumeration,  const uno::Reference< frame::XModel >& xModel  ) throw ( uno::RuntimeException ) : EnumerationHelperImpl( xContext, xEnumeration ), m_xModel( xModel ) {}
+
+	virtual uno::Any SAL_CALL nextElement(  ) throw (container::NoSuchElementException, lang::WrappedTargetException, uno::RuntimeException) 
+	{ 
+		uno::Reference< sheet::XSpreadsheet > xSheet( m_xEnumeration->nextElement(), uno::UNO_QUERY_THROW );
+		return uno::makeAny( uno::Reference< excel::XWorksheet > ( new ScVbaWorksheet( m_xContext, xSheet, m_xModel ) ) );
+	}
+
+};
+
+ScVbaWorksheets::ScVbaWorksheets( const uno::Reference< ::com::sun::star::uno::XComponentContext > & xContext, const uno::Reference< sheet::XSpreadsheets >& xSheets, const uno::Reference< frame::XModel >& xModel ): ScVbaWorksheets_BASE( xContext, uno::Reference< container::XIndexAccess >( xSheets, uno::UNO_QUERY ) ), mxModel( xModel ), m_xSheets( xSheets ) 
+{
+}
+
+ScVbaWorksheets::ScVbaWorksheets( const uno::Reference< ::com::sun::star::uno::XComponentContext > & xContext, const uno::Reference< container::XEnumerationAccess >& xEnumAccess, const uno::Reference< frame::XModel >& xModel  ):  ScVbaWorksheets_BASE( xContext, uno::Reference< container::XIndexAccess >( xEnumAccess, uno::UNO_QUERY ) ), mxModel(xModel) 
+{
+}
+
+// XEnumerationAccess
+uno::Type 
+ScVbaWorksheets::getElementType() throw (uno::RuntimeException)
+{
+	return excel::XWorksheet::static_type(0);
+}
+
+uno::Reference< container::XEnumeration >
+ScVbaWorksheets::createEnumeration() throw (uno::RuntimeException)
+{
+	if ( !m_xSheets.is() )
+	{
+		uno::Reference< container::XEnumerationAccess > xAccess( m_xIndexAccess, uno::UNO_QUERY_THROW );
+		return xAccess->createEnumeration(); 
+	}
+	uno::Reference< container::XEnumerationAccess > xEnumAccess( m_xSheets, uno::UNO_QUERY_THROW );
+	return new SheetsEnumeration( m_xContext, xEnumAccess->createEnumeration(), mxModel );
+}
+
+uno::Any
+ScVbaWorksheets::createCollectionObject( const uno::Any& aSource )
+{
+	uno::Reference< sheet::XSpreadsheet > xSheet( aSource, uno::UNO_QUERY );
+	return uno::makeAny( uno::Reference< excel::XWorksheet > ( new ScVbaWorksheet( m_xContext, xSheet, mxModel ) ) ); 
+}
+
+// XWorksheets
+uno::Any
+ScVbaWorksheets::Add( const uno::Any& Before, const uno::Any& After,
+					 const uno::Any& Count, const uno::Any& Type ) throw (uno::RuntimeException)
+{
+	if ( isSelectedSheets() )
+		return uno::Any(); // or should we throw?
+	
+	rtl::OUString aStringSheet;
+	sal_Bool bBefore(sal_True);
+	SCTAB nSheetIndex = 0;
+	SCTAB nNewSheets = 1, nType = 0;
+	Count >>= nNewSheets;
+	Type >>= nType;
+	SCTAB nCount = 0;
+	Before >>= aStringSheet;
+	if (!aStringSheet.getLength())
+	{
+		After >>= aStringSheet;
+		bBefore = sal_False;
+	}
+	if (!aStringSheet.getLength())
+	{
+		aStringSheet = ScVbaGlobals::getGlobalsImpl( 
+			m_xContext )->getApplication()->getActiveWorkbook()->getActiveSheet()->getName();
+		bBefore = sal_True;
+	}
+		nCount = static_cast< SCTAB >( m_xIndexAccess->getCount() );
+		for (SCTAB i=0; i < nCount; i++)
+		{
+			uno::Reference< sheet::XSpreadsheet > xSheet(m_xIndexAccess->getByIndex(i), uno::UNO_QUERY);
+			uno::Reference< container::XNamed > xNamed( xSheet, uno::UNO_QUERY_THROW );
+			if (xNamed->getName() == aStringSheet)
+			{
+				nSheetIndex = i;
+				break;
+			}
+		}
+
+	if(!bBefore)
+		nSheetIndex++;
+
+	SCTAB nSheetName = nCount + 1L;
+	String aStringBase( RTL_CONSTASCII_USTRINGPARAM("Sheet") );				
+	uno::Any result;
+	for (SCTAB i=0; i < nNewSheets; i++, nSheetName++)
+	{
+		String aStringName = aStringBase;
+		aStringName += String::CreateFromInt32(nSheetName);
+		while (m_xNameAccess->hasByName(aStringName))
+		{
+			nSheetName++;
+			aStringName = aStringBase;
+			aStringName += String::CreateFromInt32(nSheetName);
+		}
+		m_xSheets->insertNewByName(aStringName, nSheetIndex + i);
+		result = getItemByStringIndex( aStringName );
+	}
+	
+	return  result;
+}
+
+void
+ScVbaWorksheets::Delete() throw (uno::RuntimeException)
+{
+	//SC_VBA_STUB();
+}
+
+bool
+ScVbaWorksheets::isSelectedSheets()
+{
+	return !m_xSheets.is();
+}
+
+void SAL_CALL 
+ScVbaWorksheets::PrintOut( const uno::Any& From, const uno::Any& To, const uno::Any& Copies, const uno::Any& Preview, const uno::Any& ActivePrinter, const uno::Any& PrintToFile, const uno::Any& Collate, const uno::Any& PrToFileName ) throw (uno::RuntimeException)
+{
+	sal_Int32 nTo = 0;
+	sal_Int32 nFrom = 0;
+	sal_Int16 nCopies = 1;
+	sal_Bool bCollate = sal_False;
+	sal_Bool bSelection = sal_False;
+	From >>= nFrom;
+	To >>= nTo;
+	Copies >>= nCopies;
+	if ( nCopies > 1 ) // Collate only useful when more that 1 copy
+		Collate >>= bCollate;
+
+	if ( !( nFrom || nTo ) )
+		if ( isSelectedSheets() )
+			bSelection = sal_True;
+
+	PrintOutHelper( From, To, Copies, Preview, ActivePrinter, PrintToFile, Collate, PrToFileName, mxModel, bSelection );
+}
+
+uno::Any SAL_CALL 
+ScVbaWorksheets::getVisible() throw (uno::RuntimeException)
+{
+	sal_Bool bVisible = sal_True;
+	uno::Reference< container::XEnumeration > xEnum( createEnumeration(), uno::UNO_QUERY_THROW );
+	while ( xEnum->hasMoreElements() )
+	{
+		uno::Reference< excel::XWorksheet > xSheet( xEnum->nextElement(), uno::UNO_QUERY_THROW );
+		if ( xSheet->getVisible() == sal_False )
+		{
+				bVisible = sal_False;
+				break;
+		}
+	}
+	return uno::makeAny( bVisible );
+}
+
+void SAL_CALL 
+ScVbaWorksheets::setVisible( const uno::Any& _visible ) throw (uno::RuntimeException)
+{
+	sal_Bool bState;
+	if ( _visible >>= bState )
+	{
+		uno::Reference< container::XEnumeration > xEnum( createEnumeration(), uno::UNO_QUERY_THROW );
+		while ( xEnum->hasMoreElements() )
+		{
+			uno::Reference< excel::XWorksheet > xSheet( xEnum->nextElement(), uno::UNO_QUERY_THROW );
+			xSheet->setVisible( bState );
+		}
+	}
+	else
+		throw uno::RuntimeException( rtl::OUString( 
+			RTL_CONSTASCII_USTRINGPARAM( "Visible property doesn't support non boolean #FIXME" ) ), uno::Reference< uno::XInterface >() );
+}
+//ScVbaCollectionBaseImpl
+uno::Any 
+ScVbaWorksheets::getItemByStringIndex( const rtl::OUString& sIndex ) throw (uno::RuntimeException)
+{
+	String sScIndex = sIndex;
+	ScDocument::ConvertToValidTabName( sScIndex, '_' );
+	return ScVbaCollectionBaseImpl::getItemByStringIndex( sScIndex );
+}
+
+
Index: sc/source/ui/vba/vbaworksheets.hxx
===================================================================
RCS file: sc/source/ui/vba/vbaworksheets.hxx
diff -N sc/source/ui/vba/vbaworksheets.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbaworksheets.hxx	21 Feb 2007 17:29:24 -0000	1.1.2.2
@@ -0,0 +1,85 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_WORKSHEETS_HXX
+#define SC_VBA_WORKSHEETS_HXX
+
+#include <cppuhelper/implbase1.hxx>
+
+#include <org/openoffice/excel/XWorksheets.hpp>
+#include <com/sun/star/sheet/XSpreadsheets.hpp>
+#include <com/sun/star/container/XEnumerationAccess.hpp>
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <org/openoffice/vba/XGlobals.hpp>
+ 
+#include "vbahelper.hxx"
+#include "vbacollectionimpl.hxx"
+
+class ScModelObj;
+
+
+typedef ::cppu::ImplInheritanceHelper1< ScVbaCollectionBaseImpl, oo::excel::XWorksheets > ScVbaWorksheets_BASE;
+
+class ScVbaWorksheets : public ScVbaWorksheets_BASE
+{
+	css::uno::Reference< css::frame::XModel > mxModel;
+	css::uno::Reference< css::sheet::XSpreadsheets > m_xSheets;
+protected:
+	//ScVbaCollectionBaseImpl
+	virtual css::uno::Any getItemByStringIndex( const rtl::OUString& sIndex ) throw (css::uno::RuntimeException);
+
+public:
+	ScVbaWorksheets( const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::sheet::XSpreadsheets >& xSheets, const css::uno::Reference< css::frame::XModel >& xModel );
+	ScVbaWorksheets( const css::uno::Reference< css::uno::XComponentContext > & xContext, const css::uno::Reference< css::container::XEnumerationAccess >& xEnum,  const css::uno::Reference< css::frame::XModel >& xModel );
+	virtual ~ScVbaWorksheets() {}
+
+	bool isSelectedSheets();
+
+	// XEnumerationAccess
+	virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+	virtual css::uno::Reference< css::container::XEnumeration > SAL_CALL createEnumeration() throw (css::uno::RuntimeException);
+
+
+	// XWorksheets
+	virtual css::uno::Any SAL_CALL getVisible() throw (css::uno::RuntimeException);
+	virtual void SAL_CALL setVisible( const css::uno::Any& _visible ) throw (css::uno::RuntimeException);
+	virtual css::uno::Any SAL_CALL Add( const css::uno::Any& Before, const css::uno::Any& After, const css::uno::Any& Count, const css::uno::Any& Type ) throw (css::uno::RuntimeException);
+	virtual void SAL_CALL Delete(  ) throw (css::uno::RuntimeException);
+	virtual void SAL_CALL PrintOut( const css::uno::Any& From, const css::uno::Any& To, const css::uno::Any& Copies, const css::uno::Any& Preview, const css::uno::Any& ActivePrinter, const css::uno::Any& PrintToFile, const css::uno::Any& Collate, const css::uno::Any& PrToFileName ) throw (css::uno::RuntimeException);
+	// ScVbaCollectionBaseImpl	
+	virtual css::uno::Any createCollectionObject( const css::uno::Any& aSource ); 
+
+};
+
+#endif /* SC_VBA_WORKSHEETS_HXX */
Index: sc/source/ui/vba/vbawsfunction.cxx
===================================================================
RCS file: sc/source/ui/vba/vbawsfunction.cxx
diff -N sc/source/ui/vba/vbawsfunction.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbawsfunction.cxx	27 Feb 2007 23:29:39 -0000	1.1.2.3
@@ -0,0 +1,138 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/table/XCell.hpp>
+#include <com/sun/star/table/XColumnRowRange.hpp>
+#include <com/sun/star/beans/XIntrospection.hpp>
+#include <com/sun/star/beans/XIntrospectionAccess.hpp>
+#include <com/sun/star/sheet/XFunctionAccess.hpp>
+#include <com/sun/star/sheet/XCellRangesQuery.hpp>
+#include <com/sun/star/sheet/CellFlags.hpp>
+#include <com/sun/star/reflection/XIdlMethod.hpp>
+#include <com/sun/star/beans/MethodConcept.hpp>
+#include <comphelper/processfactory.hxx>
+#include <cppuhelper/queryinterface.hxx>
+#include <comphelper/anytostring.hxx>
+
+#include "vbawsfunction.hxx"
+
+using namespace com::sun::star;
+using namespace org::openoffice;
+
+ScVbaWSFunction::ScVbaWSFunction( css::uno::Reference< css::uno::XComponentContext >& xContext):m_xContext(xContext)
+{
+	m_xNameAccess.set(  m_xContext->getServiceManager()->createInstanceWithContext( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.sheet.FunctionDescriptions") ), m_xContext ), uno::UNO_QUERY_THROW );
+}
+
+
+uno::Reference< beans::XIntrospectionAccess >
+ScVbaWSFunction::getIntrospection(void)  throw(uno::RuntimeException)
+{
+	return uno::Reference<beans::XIntrospectionAccess>();
+}
+
+uno::Any SAL_CALL
+ScVbaWSFunction::invoke(const rtl::OUString& FunctionName, const uno::Sequence< uno::Any >& Params, uno::Sequence< sal_Int16 >& /*OutParamIndex*/, uno::Sequence< uno::Any >& /*OutParam*/) throw(lang::IllegalArgumentException, script::CannotConvertException, reflection::InvocationTargetException, uno::RuntimeException)
+{
+	uno::Reference< lang::XMultiComponentFactory > xSMgr( m_xContext->getServiceManager(), uno::UNO_QUERY_THROW );
+	uno::Reference< sheet::XFunctionAccess > xFunctionAccess(
+                        xSMgr->createInstanceWithContext(::rtl::OUString::createFromAscii(
+                        "com.sun.star.sheet.FunctionAccess"), m_xContext),
+                        ::uno::UNO_QUERY_THROW);
+	uno::Sequence< uno::Any > aParamTemp;
+	sal_Int32 nParamCount = Params.getLength();
+	aParamTemp.realloc(nParamCount);
+	const uno::Any* aArray = Params.getConstArray();
+	uno::Any* aArrayTemp = aParamTemp.getArray();
+
+	for (int i=0; i < Params.getLength();i++) 
+	{
+		uno::Reference<excel::XRange> myRange( aArray[ i ], uno::UNO_QUERY );
+		if ( myRange.is() ) 
+		{
+			aArrayTemp[i] = myRange->getCellRange();
+			continue;
+		}
+		aArrayTemp[i]= aArray[i];
+	}
+
+	for ( int count=0; count < aParamTemp.getLength(); ++count )
+		OSL_TRACE("Param[%d] is %s",
+			count, rtl::OUStringToOString( comphelper::anyToString( aParamTemp[count] ), RTL_TEXTENCODING_UTF8 ).getStr()  );
+	return xFunctionAccess->callFunction(FunctionName,aParamTemp);
+}
+
+void SAL_CALL
+ScVbaWSFunction::setValue(const rtl::OUString& /*PropertyName*/, const uno::Any& /*Value*/) throw(beans::UnknownPropertyException, script::CannotConvertException, reflection::InvocationTargetException, uno::RuntimeException)
+{
+	throw beans::UnknownPropertyException();
+}
+
+uno::Any SAL_CALL
+ScVbaWSFunction::getValue(const rtl::OUString& /*PropertyName*/) throw(beans::UnknownPropertyException, uno::RuntimeException)
+{
+	throw beans::UnknownPropertyException();
+}
+
+sal_Bool SAL_CALL
+ScVbaWSFunction::hasMethod(const rtl::OUString& Name)  throw(uno::RuntimeException)
+{
+	sal_Bool bIsFound = sal_False;
+	try 
+	{
+		if ( m_xNameAccess->hasByName( Name ) )
+			bIsFound = sal_True;
+	}
+	catch( uno::Exception& /*e*/ )
+	{
+		// failed to find name
+	}
+	return bIsFound;
+}
+
+sal_Bool SAL_CALL
+ScVbaWSFunction::hasProperty(const rtl::OUString& /*Name*/)  throw(uno::RuntimeException)
+{
+	 return sal_False;
+}
+
+::rtl::OUString SAL_CALL 
+ScVbaWSFunction::getExactName( const ::rtl::OUString& aApproximateName ) throw (css::uno::RuntimeException)
+{
+	rtl::OUString sName = aApproximateName.toAsciiUpperCase();
+	if ( !hasMethod( sName ) )
+		return rtl::OUString();
+	return sName; 
+}
Index: sc/source/ui/vba/vbawsfunction.hxx
===================================================================
RCS file: sc/source/ui/vba/vbawsfunction.hxx
diff -N sc/source/ui/vba/vbawsfunction.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/vba/vbawsfunction.hxx	21 Feb 2007 17:29:25 -0000	1.1.2.2
@@ -0,0 +1,67 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SC_VBA_INTERIOR_HXX
+#define SC_VBA_INTERIOR_HXX
+
+#include <cppuhelper/implbase2.hxx>
+#include <org/openoffice/excel/XWorksheetFunction.hpp>
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include "vbarange.hxx"
+
+#include <com/sun/star/script/XInvocation.hpp>
+#include <com/sun/star/beans/XExactName.hpp>
+#include <com/sun/star/container/XNameAccess.hpp>
+
+typedef ::cppu::WeakImplHelper2< css::beans::XExactName, css::script::XInvocation > ScVbaWSFunction_BASE;
+
+class ScVbaWSFunction :  public ScVbaWSFunction_BASE
+{
+	css::uno::Reference< css::uno::XComponentContext > m_xContext;
+	css::uno::Reference< css::container::XNameAccess > m_xNameAccess;
+public:
+	ScVbaWSFunction( css::uno::Reference< css::uno::XComponentContext >& xContext);
+	virtual ~ScVbaWSFunction(){}
+
+	virtual css::uno::Reference< css::beans::XIntrospectionAccess >  SAL_CALL getIntrospection(void)  throw(css::uno::RuntimeException);
+	virtual css::uno::Any  SAL_CALL invoke(const rtl::OUString& FunctionName, const css::uno::Sequence< css::uno::Any >& Params, css::uno::Sequence< sal_Int16 >& OutParamIndex, css::uno::Sequence< css::uno::Any >& OutParam) throw(css::lang::IllegalArgumentException, css::script::CannotConvertException, css::reflection::InvocationTargetException, css::uno::RuntimeException);
+	virtual void  SAL_CALL setValue(const rtl::OUString& PropertyName, const css::uno::Any& Value) throw(css::beans::UnknownPropertyException, css::script::CannotConvertException, css::reflection::InvocationTargetException, css::uno::RuntimeException);
+	virtual css::uno::Any  SAL_CALL getValue(const rtl::OUString& PropertyName) throw(css::beans::UnknownPropertyException, css::uno::RuntimeException);
+	virtual sal_Bool  SAL_CALL hasMethod(const rtl::OUString& Name)  throw(css::uno::RuntimeException);
+	virtual sal_Bool  SAL_CALL hasProperty(const rtl::OUString& Name)  throw(css::uno::RuntimeException);
+	virtual ::rtl::OUString SAL_CALL getExactName( const ::rtl::OUString& aApproximateName ) throw (css::uno::RuntimeException);	
+
+};
+#endif
+
Index: sc/util/createExtPackage.pl
===================================================================
RCS file: sc/util/createExtPackage.pl
diff -N sc/util/createExtPackage.pl
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/util/createExtPackage.pl	21 Feb 2007 17:32:22 -0000	1.1.2.3
@@ -0,0 +1,75 @@
+#*************************************************************************
+#
+#   OpenOffice.org - a multi-platform office productivity suite
+#
+#   $RCSfile$
+#
+#   $Revision$
+#
+#   last change: $Author$ $Date$
+#
+#   The Contents of this file are made available subject to
+#   the terms of GNU Lesser General Public License Version 2.1.
+#
+#
+#     GNU Lesser General Public License Version 2.1
+#     =============================================
+#     Copyright 2005 by Sun Microsystems, Inc.
+#     901 San Antonio Road, Palo Alto, CA 94303, USA
+#
+#     This library is free software; you can redistribute it and/or
+#     modify it under the terms of the GNU Lesser General Public
+#     License version 2.1, as published by the Free Software Foundation.
+#
+#     This library is distributed in the hope that it will be useful,
+#     but WITHOUT ANY WARRANTY; without even the implied warranty of
+#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#     Lesser General Public License for more details.
+#
+#     You should have received a copy of the GNU Lesser General Public
+#     License along with this library; if not, write to the Free Software
+#     Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+#     MA  02111-1307  USA
+#
+#*************************************************************************
+
+use Archive::Zip qw(:ERROR_CODES);
+use File::Basename;
+
+my $zipName = shift || die 'must provide a ext name';
+my $rdbName = shift || die 'must provide a types library';
+my $libName = shift || die 'must provide a component library';
+
+die "can't access type library $rdbName" unless -f $rdbName; 
+die "can't access component library $libName" unless -f $libName; 
+
+# Read the zip
+my $zip = Archive::Zip->new();
+
+if ( -f $zipName )
+{
+    # be stupid and recreate zip every time 
+    # in another iteration lets try to overwrite it instead
+    my $result = 0;
+    $result = unlink($zipName);
+    if ( result != 0 ) 
+    {
+        die 'can not delete old extension';
+    }
+}
+my $rdb = basename( $rdbName );
+my $lib = basename( $libName );
+
+my $content2 = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
+$content2 .= "<!DOCTYPE manifest:manifest PUBLIC \"-//OpenOffice.org//DTD Manifest 1.0//EN\" \"Manifest.dtd\">\n";
+$content2 .= "<manifest:manifest xmlns:manifest=\"http://openoffice.org/2001/manifest\">\n";
+$content2 .= "  <manifest:file-entry manifest:media-type=\"application/vnd.sun.star.uno-typelibrary;type=RDB\" manifest:full-path=\"$rdb\"/>\n";
+$content2 .= "  <manifest:file-entry manifest:media-type=\"application/vnd.sun.star.uno-component;type=native\"  manifest:full-path=\"$lib\"/>\n";
+$content2 .= "</manifest:manifest>\n";
+
+$zip->addFile( $rdbName, $rdb );
+$zip->addFile( $libName, $lib );
+$zip->addDirectory( "META-INF" );
+$zip->addFile( "META-INF/manifest.xml", "manifest.xml" );
+$zip->addString( $content2, "META-INF/manifest.xml" );
+exit( $zip->writeToFileNamed($zipName) );
Index: sc/util/makefile.mk
===================================================================
RCS file: /cvs/sc/sc/util/makefile.mk,v
retrieving revision 1.37
retrieving revision 1.37.76.5
diff -u -p -u -p -r1.37 -r1.37.76.5
--- sc/util/makefile.mk	14 Nov 2006 16:01:11 -0000	1.37
+++ sc/util/makefile.mk	27 Feb 2007 11:03:46 -0000	1.37.76.5
@@ -264,11 +264,46 @@ LIB8OBJFILES = \
 	    $(SLO)$/dpgroupdlg.obj	\
 		$(SLO)$/editfield.obj
 
+.IF "$(ENABLE_VBA)"=="YES"
+
+TARGET_VBA=vbaobj
+SHL9TARGET=$(TARGET_VBA)$(UPD)$(DLLPOSTFIX).uno
+SHL9IMPLIB=	i$(TARGET_VBA)
+
+SHL9VERSIONMAP=$(TARGET_VBA).map
+SHL9DEF=$(MISC)$/$(SHL9TARGET).def
+DEF9NAME=$(SHL9TARGET)
+
+SHL9STDLIBS= \
+		$(CPPUHELPERLIB) \
+		$(CPPULIB) \
+		$(COMPHELPERLIB) \
+		$(SVLIB) \
+		$(TOOLSLIB) \
+		$(SALLIB)\
+		$(BASICLIB)	\
+		$(SFXLIB)	\
+		$(SVXLIB)	\
+		$(SVTOOLLIB)    \
+		$(SVLLIB) \
+		$(ISCLIB) \
+
+
+SHL9DEPN=$(SHL1TARGETN) $(SHL8TARGETN)
+SHL9LIBS=$(SLB)$/$(TARGET_VBA).lib
+
+.ENDIF
+ 
+
 # --- Targets -------------------------------------------------------------
 
 .INCLUDE :  target.mk
 
-ALLTAR:	$(MISC)$/linkinc.ls
-
+.IF "$(VBA_EXTENSION)"=="YES"
+    COMP=build_extn
+.ENDIF
 
+ALLTAR:	$(MISC)$/linkinc.ls  $(COMP)
 
+build_extn : $(SLB)$/$(TARGET_VBA).lib
+	$(PERL) createExtPackage.pl $(COMMONBIN)$/vbaapi.oxt  $(SOLARBINDIR)$/oovbaapi.rdb $(LIBCOMPNAME)
Index: sc/util/vbaobj.map
===================================================================
RCS file: sc/util/vbaobj.map
diff -N sc/util/vbaobj.map
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/util/vbaobj.map	7 Feb 2007 21:24:44 -0000	1.1.2.1
@@ -0,0 +1,10 @@
+OOO_1.1 {
+	global:
+		component_getDescriptionFunc;
+		component_getImplementationEnvironment;
+		component_getFactory;
+		component_writeInfo;
+
+	local:
+		*;
+};
Index: svx/source/msfilter/svxmsbas.cxx
===================================================================
RCS file: /cvs/graphics/svx/source/msfilter/svxmsbas.cxx,v
retrieving revision 1.19
retrieving revision 1.19.210.2
diff -u -p -u -p -r1.19 -r1.19.210.2
--- svx/source/msfilter/svxmsbas.cxx	12 Oct 2006 12:59:33 -0000	1.19
+++ svx/source/msfilter/svxmsbas.cxx	27 Feb 2007 11:26:56 -0000	1.19.210.2
@@ -96,10 +96,26 @@ using namespace com::sun::star;
 
 using rtl::OUString;
 
+bool lcl_hasVBAEnabled()
+{
+	try
+	{
+		Reference< XPropertySet > xProps( ::comphelper::getProcessServiceFactory(), UNO_QUERY_THROW );
+		// test if vba service is present
+		Reference< XComponentContext > xCtx( xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))), UNO_QUERY_THROW );
+		Reference< XInterface > xGlobals( xCtx->getValueByName( ::rtl::OUString::createFromAscii( "/singletons/org.openoffice.vba.theGlobals") ), UNO_QUERY_THROW );
+		return true;
+	}
+	catch( Exception& ) {}
+	return false;
+}
+
 int SvxImportMSVBasic::Import( const String& rStorageName,
 								const String &rSubStorageName,
 								BOOL bAsComment, BOOL bStripped )
 {
+	if ( lcl_hasVBAEnabled() )
+		bAsComment = FALSE;	
 	int nRet = 0;
 	if( bImport && ImportCode_Impl( rStorageName, rSubStorageName,
 									bAsComment, bStripped ))
@@ -352,7 +368,8 @@ BOOL SvxImportMSVBasic::ImportCode_Impl(
                         break;
                 }
 				static ::rtl::OUString sVBAOption( RTL_CONSTASCII_USTRINGPARAM( "Option VBASupport 1\n" ) ); 
-				modeTypeComment = modeTypeComment + sVBAOption;
+				if ( !bAsComment )
+					modeTypeComment = modeTypeComment + sVBAOption;
 
 				String sModule(sBasicModule); //#i52606# no need to split Macros in 64KB blocks any more!
 				String sTemp;
@@ -411,15 +428,17 @@ BOOL SvxImportMSVBasic::ImportCode_Impl(
 						aSource += rtl::OUString::createFromAscii("\nEnd Sub");
 				}
 				::rtl::OUString aModName( sModule );
+				if ( aSource.getLength() )
+				{
+					aSource = modeTypeComment + aSource;
 
-				aSource = modeTypeComment + aSource;
-
-				Any aSourceAny;
-				aSourceAny <<= aSource;
-				if( xLib->hasByName( aModName ) )
-					xLib->replaceByName( aModName, aSourceAny );
-				else
-					xLib->insertByName( aModName, aSourceAny );
+					Any aSourceAny;
+					aSourceAny <<= aSource;
+					if( xLib->hasByName( aModName ) )
+						xLib->replaceByName( aModName, aSourceAny );
+					else
+						xLib->insertByName( aModName, aSourceAny );
+				}                                
 
 				bRet = true;
 			}
Index: scp2/source/ooo/file_library_ooo.scp
===================================================================
RCS file: /cvs/installation/scp2/source/ooo/file_library_ooo.scp,v
retrieving revision 1.222
retrieving revision 1.222.52.2
diff -u -p -u -p -r1.222 -r1.222.52.2
--- scp2/source/ooo/file_library_ooo.scp	2 Jan 2007 15:55:30 -0000	1.222
+++ scp2/source/ooo/file_library_ooo.scp	8 Feb 2007 14:43:17 -0000	1.222.52.2
@@ -697,6 +697,25 @@ File gid_File_Lib_Stringresource
   #endif
 End
 
+#ifdef ENABLE_VBA
+#ifndef VBA_EXTENSION
+
+File gid_File_Lib_Vbaobj
+    TXT_FILE_BODY;
+    Styles = (PACKED,UNO_COMPONENT,PATCH);
+    RegistryID = gid_Starregistry_Services_Rdb;
+    Dir = gid_Dir_Program;
+  #ifdef UNX
+    Name = STRING(CONCAT5(libvbaobj,OFFICEUPD,DLLPOSTFIX,.uno,UNXSUFFIX));
+  #else
+    Name = STRING(CONCAT5(vbaobj,OFFICEUPD,DLLPOSTFIX,.uno,.dll));
+  #endif
+End
+
+#endif // VBA_EXTENSION
+#endif // ENABLE_VBA
+
+
 #ifdef WNT
 
 File gid_File_Lib_Dnd
Index: scp2/source/ooo/file_ooo.scp
===================================================================
RCS file: /cvs/installation/scp2/source/ooo/file_ooo.scp,v
retrieving revision 1.183
retrieving revision 1.183.14.1
diff -u -p -u -p -r1.183 -r1.183.14.1
--- scp2/source/ooo/file_ooo.scp	23 Jan 2007 12:30:11 -0000	1.183
+++ scp2/source/ooo/file_ooo.scp	7 Feb 2007 16:33:27 -0000	1.183.14.1
@@ -1815,6 +1815,17 @@ File gid_File_Rdb_Types
     Name = "types.rdb";
 End
 
+#ifdef ENABLE_VBA 
+#ifndef VBA_EXTENSION
+File gid_File_Rdb_TypesVba
+    TXT_FILE_BODY;
+    Dir = gid_Dir_Program;
+    Styles = (PACKED, OVERWRITE, PATCH);
+    Name = "oovbaapi.rdb";
+End
+#endif
+#endif
+
 File gid_File_Registry_Lang
     Dir = gid_Dir_Share_Registry_Res_Lang;
     ARCHIVE_TXT_FILE_BODY_PATCH;
Index: scp2/source/ooo/makefile.mk
===================================================================
RCS file: /cvs/installation/scp2/source/ooo/makefile.mk,v
retrieving revision 1.49
retrieving revision 1.49.24.1
diff -u -p -u -p -r1.49 -r1.49.24.1
--- scp2/source/ooo/makefile.mk	10 Jan 2007 11:28:13 -0000	1.49
+++ scp2/source/ooo/makefile.mk	7 Feb 2007 16:33:27 -0000	1.49.24.1
@@ -199,6 +199,13 @@ SCPDEFS+=-DISOLANG_MAJOR=$(ISOLANG_MAJOR
 SCPDEFS+=-DDISABLE_NEON
 .ENDIF
 
+.IF "$(ENABLE_VBA)" == "YES"
+    .IF "$(VBA_EXTENSION)" == "YES"
+        SCPDEFS+=-DVBA_EXTENSION
+    .ENDIF
+SCPDEFS+=-DENABLE_VBA
+.ENDIF
+
 SCP_PRODUCT_TYPE=osl
 
 ICUVERSION_DEPENDENT_FILES= \
Index: scp2/source/ooo/profileitem_ooo.scp
===================================================================
RCS file: /cvs/installation/scp2/source/ooo/profileitem_ooo.scp,v
retrieving revision 1.42
retrieving revision 1.42.20.1
diff -u -p -u -p -r1.42 -r1.42.20.1
--- scp2/source/ooo/profileitem_ooo.scp	15 Jan 2007 12:40:16 -0000	1.42
+++ scp2/source/ooo/profileitem_ooo.scp	7 Feb 2007 16:33:28 -0000	1.42.20.1
@@ -711,7 +711,12 @@ ProfileItem gid_Profileitem_Uno_Uno_Type
     Section = "Bootstrap";
     Order = 7;
     Key = "UNO_TYPES";
+#if defined( ENABLE_VBA ) && !defined( VBA_EXTENSION )
+    Value = "$ORIGIN/oovbaapi.rdb $ORIGIN/types.rdb ${$PKG_SharedUnoFile:UNO_TYPES} ${$PKG_UserUnoFile:UNO_TYPES}";
+#else
     Value = "$ORIGIN/types.rdb ${$PKG_SharedUnoFile:UNO_TYPES} ${$PKG_UserUnoFile:UNO_TYPES}";
+#endif
+
 End
 
 ProfileItem gid_Profileitem_Uno_Uno_Services
